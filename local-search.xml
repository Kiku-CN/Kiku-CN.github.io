<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/10/17/%E8%A7%A3%E5%86%B3%20Nginx%20%E5%92%8C%20trojan%20%E5%85%AC%E7%94%A8%20443%20%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/10/17/%E8%A7%A3%E5%86%B3%20Nginx%20%E5%92%8C%20trojan%20%E5%85%AC%E7%94%A8%20443%20%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="trojan-和-Nginx-公用-443-端口"><a href="#trojan-和-Nginx-公用-443-端口" class="headerlink" title="trojan 和 Nginx 公用 443 端口"></a>trojan 和 Nginx 公用 443 端口</h1><p>由于 trojan 默认工作在服务器的 443 端口，而 Nginx 的 HTTPS 服务端口也在 443，如果此时想同时使用两种服务。那么要么更改 trojan 默认端口，要么更改 Nginx 的 HTTPS 端口。如果选择更改 HTTPS 端口那么所有 URL 都要补充上端口号，既麻烦也不美观。那么更改 trojan 的默认监听端口可行吗？</p><p>trojan 的工作机制是客户端使用 TLS 对要代理的流量进行加密伪装成 HTTPS 流量发送给 trojan 服务端，trojan 服务端工作在 443 端口，对 TLS 加密的数据解密后进行流量识别，如果流量是 trojan 协议并且检查合法（检查 trojan 密码是否正确），说明来自正确的 trojan 客户端，对流量代理转发。如果流量不是 trojan 协议，说明不是来自 trojan 客户端的数据，则转发到则转发到服务端本地的 80 端口，而 80 端口则提前配置好一个 HTTP 伪装站点，向客户端响应 HTML 页面。</p><p>之前的代理协议例如 Shadowsocks、VMess，思路普遍都是使用各种复杂的加密，来避免流量特征被 GFW 识别，而 trojan 选择的是把 trojan 服务伪装成一个提供 HTTPS Web 服务的站点，流量在 GFW 看来和普通的 HTTPS 流量没什么区别，进而来躲避 GFW 的审查和封锁。 trojan 相比之前的协议传输效率更高（只有一层加密），抗封锁效果反而更好。</p><p>个人理解对 trojan 的伪装可以体现在下面几个方面</p><ol><li>  TCP 端口号和 HTTPS 一样工作在 443 端口。</li><li>  和普通 HTTPS 流量一样使用 TLS 协议进行加密。</li><li>  如果用户（可能是探针）使用 HTTPS 协议来访问 trojan server，用户看到的是预先准备好的伪装 Web 站点，和普通 Web 站点没有任何区别。</li></ol><p>因此 trojan 工作在 443 端口也是伪装的一部分，可以增加服务的隐蔽性，因此建议不要更改 trojan 的默认工作端口。</p><p><strong>注意：没有谁能确认 GFW 真正的工作机制，有的人改了 trojan 端口用的好好的，有的人没改还是被封，没有准确的统计数据来说明 trojan 使用 443 端口是否能真正减少封禁的几率。并且使用 trojan 协议在 443 端口也不代表永远不会被封禁，就可以高枕无忧、一劳永逸了。每种协议新出的时候大家都是充满了乐观，但是 GFW 的检测手段也在不断进化，有可能 GFW 已经检测出流量异常只不过没下手罢了。如果滥用节点，比如拿来开机场，或者发表一些敏感言论，被封禁的风险就会大大增加，甚至请你过去喝茶。此外特殊敏感时期的无差别封禁也有可能误伤到你的 VPS。</strong></p><p>那么有没有让 trojan 和 Nginx 公用 443 端口的办法呢？一番搜索之后得到了肯定的答案——利用 TLS 握手阶段的 SNI 信息进行在 4 层进行转发。关于 SNI 转发的工作原理请看程小白的这篇文章 <a href="https://www.chengxiaobai.com/trouble-maker/trojan-shared-443-port-scheme">Trojan 共用 443 端口方案</a>。</p><p>前置环境：已经使用 <a href="https://github.com/Jrohy/trojan">Jrohy 的一键脚本</a> 安装了 trojan 和 trojan web 管理程序，trojan 所使用的域名为 <code>free.kiku.vip</code>， 访问 <a href="https://free.kiku.vip/">https://free.kiku.vip</a> 看到的 trojan web 管理面板。搭建可以看</p><p>![image-20211017193404608](解决 Nginx 和 trojan 公用 443 的问题 images/image-20211017193404608.png)</p><p>想要达到的目标：<code>free.kiku.vip</code> 还是用用来使用 trojan 代理服务，直接访问 <a href="https://free.kiku.vip/">https://free.kiku.vip</a> 看到的是伪装站点，访问 <a href="https://free.kiku.vip/admin">https://free.kiku.vip/admin</a> 才是 trojan web 管理面板。除了 <code>free.kiku.vip</code> 外的 <code>*.kiku.vip</code> 访问到正常的 HTTPS 服务，如果通过 HTTP 协议访问则强制跳转到 HTTPS。服务端除了 80 和 443 端口，其余端口关闭。</p><p>![image-20211017193845759](解决 Nginx 和 trojan 公用 443 的问题 images/image-20211017193845759.png)</p><p>具体的配置步骤：</p><ol><li><p>为 Nginx 设置 SNI 识别转发，如果是通过宝塔安装的 Nginx，配置文件路径在：<code>/www/server/nginx/conf/nginx.conf</code>。<br>  在配置文件的 events 和 http 模块之间添加下面的内容。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 流量转发核心配置</span><br><span class="hljs-section">stream</span> &#123;<br>    <span class="hljs-comment"># 这里就是 SNI 识别，将域名映射成一个配置名</span><br>    <span class="hljs-attribute">map</span> $ssl_preread_server_name $backend_name &#123;<br>        *.kiku.vip web;<br>        free.kiku.vip trojan;<br>        <span class="hljs-comment"># 域名都不匹配情况下的默认值</span><br>        <span class="hljs-attribute">default</span> web;<br>    &#125;<br><br>    <span class="hljs-comment"># web，配置转发详情</span><br>    <span class="hljs-attribute">upstream</span> web &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:4431</span>;<br>    &#125;<br>    <span class="hljs-comment"># trojan，配置转发详情</span><br>    <span class="hljs-attribute">upstream</span> trojan &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:4432</span>;<br>    &#125;<br><br>    <span class="hljs-comment"># 监听 443 并开启 ssl_preread</span><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> reuseport;<br>        <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">443</span> reuseport;<br>        <span class="hljs-attribute">proxy_pass</span>  $backend_name;<br>        <span class="hljs-attribute">ssl_preread</span> <span class="hljs-literal">on</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  也可以直接在宝塔面板 Nginx 管理中直接修改配置。</p><p>  ![image-20211017175843811](解决 Nginx 和 trojan 公用 443 的问题 images/image-20211017175843811.png)</p></li><li><p>修改 trojan 的监听地址和端口号以及如果识别为非 trojan 流量的回落端口号，trojan配置文件路径为 <code>/usr/local/etc/trojan/config.json</code> 。<br>  下面是配置文件的关键内容：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;run_type&quot;</span>: <span class="hljs-string">&quot;server&quot;</span>,<br>    <span class="hljs-attr">&quot;local_addr&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;local_port&quot;</span>: <span class="hljs-number">4432</span>,<br>    <span class="hljs-attr">&quot;remote_addr&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;remote_port&quot;</span>: <span class="hljs-number">82</span>,<br><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改 <code>free.kiku.vip</code> 的站点的 Nginx 配置文件，文件路径为 <code>/www/server/panel/vhost/nginx/free.kiku.vip.conf</code>。<br>  下面是配置文件的完整内容：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs nginx">server<br>&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">127.0.0.1:82</span>;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><br>    <span class="hljs-attribute">server_name</span> free.kiku.vip;<br>    <span class="hljs-attribute">index</span> index.php index.html index.htm default.php default.htm default.html;<br>    <span class="hljs-attribute">root</span> /www/wwwroot/free.kiku.vip;<br><br>    <span class="hljs-comment"># 80 端口的访问强制跳转到 https 443</span><br>    <span class="hljs-attribute">if</span> ($server_port =  <span class="hljs-number">80</span>)&#123;<br>        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(/.*)$</span> https://$host<span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br>    &#125;<br><br>    <span class="hljs-comment"># 后台管理页面,通过 free.kiku.vip/admin 访问</span><br>    <span class="hljs-attribute">location</span> /admin &#123;<br>        <span class="hljs-attribute">proxy_pass</span>   http://localhost:81/;<br>    &#125;<br><br>    <span class="hljs-comment"># 由于 trojan web 前端的部分资源是写在二进制中的，这些资源的访问路径固定</span><br>    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~* ^/(static|common|auth|trojan)/</span> &#123;<br>        <span class="hljs-attribute">proxy_pass</span>  http://localhost:81;<br>        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Upgrade $http_upgrade;<br>        <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;Upgrade&quot;</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Host $host;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>  也可以选择直接在宝塔面板中修改站点的配置文件。</p><p>  ![image-20211017175540571](解决 Nginx 和 trojan 公用 443 的问题 images/image-20211017175540571.png)</p></li><li><p>修改 <code>kiku.vip</code> 的站点的 Nginx 配置文件，文件路径为 <code>/www/server/panel/vhost/nginx/kiku.vip.conf</code>。<br>  下面是配置文件的关键内容：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx">server<br>&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">4431</span> ssl http2;<br>    <span class="hljs-attribute">server_name</span> kiku.vip;<br>    <br>    <span class="hljs-comment"># http 强制跳转到 https</span><br>    <span class="hljs-attribute">if</span> ($server_port !<span class="hljs-regexp">~ 443)</span>&#123;<br>        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(/.*)$</span> https://$host<span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改 trojan web 管理面板的监听端口号为 81，trojan web 的配置文件路径为 <code>/etc/systemd/system/trojan-web.service</code> 。<br>  下面是配置文件的完整内容，和原版配置区别在于第 9 行结尾使用 <code>-p</code> 指定了端口号。</p>  <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs txt">[Unit]<br>Description=trojan-web<br>Documentation=https://github.com/Jrohy/trojan<br>After=network.target network-online.target nss-lookup.target mysql.service mariadb.service mysqld.service docker.service<br><br>[Service]<br>Type=simple<br>StandardError=journal<br>ExecStart=/usr/local/bin/trojan web -p 81<br>ExecReload=/bin/kill -HUP \$MAINPID<br>Restart=on-failure<br>RestartSec=3s<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure></li><li><p>配置完毕后重启 Nginx 和 trojan，让配置生效。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">service nginx restart<br>trojan restart<br></code></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>  <a href="https://trojan-gfw.github.io/trojan/">trojan 官方文档</a></li><li>  <a href="https://github.com/Jrohy/trojan/wiki">trojan 多用户管理部署程序 Wiki</a></li><li>  <a href="https://www.chengxiaobai.com/trouble-maker/trojan-shared-443-port-scheme">Trojan 共用 443 端口方案</a></li><li>  <a href="https://www.v2rayssr.com/trojanwordpress.html">Trojan+Nginx+WordPress个人博客，共用443端口！所有访问全部开启HTTPS，Trojan终极伪装！</a></li><li>  <a href="https://github.com/jinwyp/one_click_script#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-advanced-usage-%E4%B8%8E%E7%8E%B0%E6%9C%89%E7%BD%91%E7%AB%99%E5%85%B1%E5%AD%98">一键安装 trojan v2ray xray. Install v2ray / xray (VLESS) and trojan (trojan-go) script</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>cate1</category>
      
      <category>cate2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>trojan</tag>
      
      <tag>HTTP</tag>
      
      <tag>HTTPS</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 SSH 客户端登录远程主机</title>
    <link href="/2021/10/14/%E4%BD%BF%E7%94%A8%20SSH%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/"/>
    <url>/2021/10/14/%E4%BD%BF%E7%94%A8%20SSH%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用-SSH-客户端登录远程主机"><a href="#使用-SSH-客户端登录远程主机" class="headerlink" title="使用 SSH 客户端登录远程主机"></a>使用 SSH 客户端登录远程主机</h1><h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><p>Linux 发行版  和最新的 Windows 10 都自带了 OpenSSH 客户端，以 Windows 10为例，OpenSSH 客户端程序位于<code>C:\Windows\System32\OpenSSH\ssh.exe</code> 这个路径下，该路径已经被添加到系统环境变量 PATH 中，因此在终端中可以直接使用 <code>ssh</code> 命令来运行 SSH 客户端。在 <code>ssh</code> 命令后面接 <code>-V</code> 参数来查看 SSH 客户端版本号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -V<br></code></pre></td></tr></table></figure><p>SSH 客户端最常用的功能就是用来登录远程的服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh hostname<br></code></pre></td></tr></table></figure><p><code>hostname</code> 用来指定主机名，可以是域名、主机的 IP 地址、也可以是配置文件中的主机别名。默认使用当前客户端的用户名（也就是当前 Windows 所使用的的用户名）去登录远程主机。</p><p>可以在主机名前面用指定要登录的用户名，用 <code>@</code> 符号分隔。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh username@hostname<br></code></pre></td></tr></table></figure><p>也可以使用 <code>-l</code> 参数来指定要登录的用户名，和上面等效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh hostname -l username <br></code></pre></td></tr></table></figure><p>SSH 客户端默认连接服务器的 22 端口（SSH 服务端程序的默认监听端口），<code>-p</code> 参数可以指定其他端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh hostname -p 2222<br></code></pre></td></tr></table></figure><p>当客户端向服务端发起 SSH 连接请求时，SSH 服务端会将 <code>/etc/ssh</code> 目录下的 Host Key 公钥发回客户端，用来认证服务端的身份信息。</p><p>如果用户是第一次连接到该主机，SSH 客户端会提示用户确认服务端的公钥指纹。</p><p>如果选择信任该公钥，会将主机名和对应的公钥都储存在本机的 <code>~/.ssh/known_hosts</code> 文件中。以后再连接该主机时，如果主机发回的公钥和文件中的不符，则提示可能遭受中间人攻击并断开连接（HTTPS 用 CA 证书中心解决了该问题）。</p><p>如果确认是远程主机因为某些原因，例如重装系统或者重装 SSH 服务而重新生成了 Host Key公钥，那就需要在本地主机上使用以下命令将原来的公钥信息删除，或者手动打开 <code>~/.ssh/known_hosts</code> 文件删除对应的项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -R hostname # hostname 是发生公钥变更的主机名。<br></code></pre></td></tr></table></figure><p>删除了原来的公钥信息后，重新执行 ssh 命令连接远程服务器，重新确认服务端的公钥指纹，就可以发起连接请求了。</p><p>发起连接请求后 SSH 客户端会和服务端是进行版本协商、算法协商、秘钥交换，其中又用到了对称加密、非对称加密和密钥交换的各种算法（思路有和 HTTPS 中的 SSL/TLS 协议类似的地方，都是用非对称加密来交换对称秘钥，真正的消息内容都是使用的都是基于对称加密的的临时回话密钥（Session Key）进行加密，如果全程都使用非对称加密效率太低）。只需要知道 SSH 连接成功后建立了安全通道，具体的连接过程在此不深究。</p><p>客户端就与服务器建立连接 SSH 连接成功后，ssh 就会要求用户输入所要登录账户的密码，输入用户密码验证正确以后，就可以得到远程服务器的 Shell 环境了。</p><h2 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h2><h3 id="原理步骤"><a href="#原理步骤" class="headerlink" title="原理步骤"></a>原理步骤</h3><p>公钥免密登录步骤是：</p><ol><li>  用户根据非对称加密算法，生成一对密钥对。</li><li>  提前将密钥对中的公钥放置在远程主机用户目录下的 <code>~/.ssh/authorized_keys</code> 文件中。</li><li>   SSH 客户端指定某用户发起登录请求。</li><li>  SSH 服务端收到该用户的登录请求，SSH 服务端生成一个随机数，使用指定用户的用户目录下的 <code>~/.ssh/authorized_keys</code> 文件中的公钥列表中一个公钥加密，将加密后的数据给客户端。</li><li>  客户端使用密钥对中的私钥对这段随机数解密，解密结果和 Session ID 使用 MD5 算法生成摘要发回给服务端。如果私钥解密的数据发回服务器的时候如果被中间人劫持因为 Session  ID 也可以</li><li>  SSH 服务端用之前生成的随机数同样加上 Session ID 计算 MD5 hash 值，如果和客户端发过来的摘要匹配成功，就说明请求者拥有公钥所对应的私钥，即可以以该用户登录，不再需要输入密码。如果不匹配则回到第 4 步中使用公钥文件中的剩余公钥重复这个过程。如果所有的公钥都失败，则说明公钥登录失败，会提示用户输入密码登录。</li><li>  SSH 服务端遍历登录请求中指定用户的用户目录下的 <code>~/.ssh/authorized_keys</code> 文件中的公钥来解密，如果有一条公钥的解密结果和服务端之前发出的数据一致，如果该文件中的所有公钥的解密结果都匹配不上则显示输入密码登录。</li></ol><p>（其实还有 Session ID 等其他信息）数字签名，然后发回给服务端。</p><p>关于第 4 步中发送的随机数到底是直接发送还是使用 <code>authorized_keys</code> 中的公钥将加密后再发送的有不少的争议。</p><p>阮一峰的文章说的直接发送，但是要在第 5 步对响应给服务端的数据进行数字签名，如果第 5 步服务端使用公钥解签得到的摘要和原本的摘要一致也能证明认证用户的身份。</p><blockquote><p>  所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。——阮一峰：SSH原理与运用（一）：远程登录</p></blockquote><p>个人觉得阮提出的方法效率会更高，因为 <code>~/.ssh/authorized_keys</code> 文件中可以存放多个公钥，每一行都是一个公钥，服务端并不知道应该用哪个公钥来加密随机数，最差结果就是所有公钥都要按照上面的流程尝试一边，效率显然不如直接发送然后在服务端遍历公钥列表来解密私钥签名信息对比效率高。并且哪怕是随机数被中间人偷听了也无所谓，中间人没有真正的私钥能对随机数据进行正确签名的。</p><p>具体是哪一种也没去看底层代码验证过，无论是公钥加密，私钥解密，还是私钥签名，公钥解签，都能证明你是私钥的拥有者即可。</p><p>虽然个人很信任阮大，但是因为持后一种说法人太多，并且差了不少英文文章都是这样说，还是采纳了后一种说法。</p><p><strong>注意：很多人的文章说用户在发起登录请求会把公钥发送给服务端，这样服务端就知道用哪个公钥加密了，但是经过实验在本地主机删除了公钥文件也可以成功登录，说明并不存在发送公钥的行为。</strong></p><h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><p>首先要使用 <code>ssh-keygen</code> 命令，生成一对密钥对。<code>-t</code> 是用来指定非对称加密使用的算法，可选 dsa 或者 rsa，默认值是 rsa。<code>-b</code> 是用来指定秘钥的二进制位数，<code>-b </code>至少应该是 <code>1024</code>，更安全一些可以设为 <code>2048</code> 或者更高。<code>-b</code> 至少应该是 <code>1024</code>，更安全一些可以设为 <code>2048</code> 或者更高。<code>-C</code> 参数可以为密钥文件指定新的注释，建议的格式为 <code>username@hostname</code>。<code>-f</code>参数指定生成的秘钥文件路径和名称。这些参数包括注释都是可选的，如果省略就使用默认值。</p><p><strong>注意：如果之前使用过 Github 的 SSH 免密登录功能，该目录下会有生成过的秘钥对，可以直接使用这套秘钥对来进行免密登录。当然也可以再创建新的密钥对，但是注意用 <code>-f</code> 参数指定秘钥文件路径和名称，不要把原来的秘钥文件覆盖了，否则 GitHub 的免密登录会失败。</strong></p><p>输入下面的命令就会在 SSH 的配置目录 <code>~/.ssh</code> 下生成名为 <code>id_rsa</code>（私钥）和<code>id_rsa.pub</code>（公钥）秘钥对文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096 -C &quot;root@kiku.vip&quot;<br></code></pre></td></tr></table></figure><p>在生成秘钥的过程中会询问是否要为私钥设定密码（passphrase，为了和用户密码 password 区别），如果设定密码则在使用私钥前还要输入密码对私钥解锁，虽然和密码口令登录一样时要输入密码，但是更加安全。如果为了方便，不想设定密码，直接输入两次回车就好。</p><h3 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h3><p>免密登录能成功的前提是用户已经将提前将秘钥对中的公钥添加到远程主机的 <code>~/.ssh/authorized_keys</code> 文件中，因此生成密钥对以后，还得把公钥必须上传到服务器，才能使用公钥登录。</p><p>要以哪个用户的身份登录到服务器，密钥就必须保存在该用户主目录的<code>~/.ssh/authorized_keys</code>文件。</p><p>下面提供三种上传公钥到远程主机上的方法：</p><ol><li><p>如果购买的是大厂云服务器，可以直接在控制台中上传公钥。以腾讯轻量应用服务器为例：<br>  首先要在控制台中创建秘钥：<br>  ![image-20211014162335502](Untitled images/image-20211014162335502.png)<br>  ![image-20211014162545603](Untitled images/image-20211014162545603.png)<br>  然后将秘钥绑定到我们远程主机上。<br>  <strong>注意：腾讯云控制台上传的公钥只能绑定在 root 用户下，并且绑定后将不能再通过密码方式 SSH 登录。</strong><br>  ![image-20211015175759714](Untitled images/image-20211015175759714.png)</p></li><li><p>手动将本地的公钥文件写入到远程主机上。<br>  在远程主机执行下面的命令。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/.ssh  <br>chmod 700 ~/.ssh<br>vi ~/.ssh/authorized_keys<br>chmod 600 ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>  第 1、2 行是在用户的主目录下创建 <code>.ssh</code> 的目录并设置权限为只有该用户可以访问，第 3 行打开信任的公钥文件，将公钥粘贴进去然后保存退出，第 4 行更改公钥文件的权限只有所有者有读写权限。如果权限设置不对，SSH 服务器可能会拒绝读取该文件。</p><p>  <strong>注意：该文件中可以存放多个公钥，每一行都是一个公钥，为了不影响其他客户端的登录应该把公钥追加到末尾，而不是直接覆盖。并且最后在后面添加一个换行，防止下次添加的公钥接在了同一行后面。</strong></p><p>  也可以使用在本地主机运行下面的命令将公钥上传到远程主机，其中<code>~/.ssh/id_rsa.pub</code> 替换成本地公钥存放的位置， <code>username@hostname </code> 要替换成你所要登录的用户名和主机名。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat ~/.ssh/id_rsa.pub | ssh user@host &quot;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys&quot;<br></code></pre></td></tr></table></figure><p>  但是还是要登录远程主机，执行下面的命令修改目录和文件的权限才能成功。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 700 ~/.ssh<br>chmod 600 ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>ssh-copy-id</code> 命令：自动上传公钥，Linux 上自带的 OpenSSH 自带一个 <code>ssh-copy-id</code> 命令，可以自动将公钥拷贝到远程服务器的<code>~/.ssh/authorized_keys</code>文件。<br>  用户在本地 Linux 计算机执行下面的命令，就可以把本地的公钥拷贝到服务器。 <code>-i</code> 参数指定上传的公钥文件。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ssh-copy-id -i key_file user@host</span><br></code></pre></td></tr></table></figure><p>  <strong>注意：Windows 10 的自带的 OpenSSH 并没有 <code>ssh-copy-id</code> 工具，因此无法使用该命令，网上有一些第三方对的实现，可用性没有测试过，建议 Windows 使用前面两种方法，</strong></p></li></ol><p>上传成功后使用下面命令就可以顺利免密登录，不用再输入密码。可以使用 <code>-i</code> 参数指定使用的私钥文件，默认使用的私钥文件为 <code>~/.ssh/id_rsa</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh admin@kiku.vip -p 2222 -i ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>SSH 客户端的相关配置文件在本地主机的 <code>~/.ssh</code> 目录下，使用 <code>ssh-keygen</code> 命令生成的密钥对，还有信任主机列表 <code>known_hosts</code> 文件都在该目录下。</p><p>而 <code>~/.ssh/config</code> 文件是 SSH 客户端配置文件，如果该目录下不存在该文件，可以手动创建一个名为 <code>config</code> 无后缀格式的纯文本文件。</p><p>使用 SSH 客户端配置文件，可以按照不同服务器，列出各自的连接参数，从而不必每一次登录都输入重复的参数。下面是一个例子，例子里面的缩进格式并不是必需的，只是为了视觉上区分不同主机的设置。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Host</span> *<br>     <span class="hljs-attribute">Port</span> <span class="hljs-number">2222</span><br>     <span class="hljs-comment"># 断开时重试连接的次数</span><br>     <span class="hljs-attribute">ServerAliveCountMax</span> <span class="hljs-number">5</span><br>     <span class="hljs-comment"># 每隔 60 秒自动发送一个空的请求以保持连接</span><br>     <span class="hljs-attribute">ServerAliveInterval</span> <span class="hljs-number">60</span><br>     <br><span class="hljs-attribute">Host</span> bloghost<br>    <span class="hljs-attribute">HostName</span> kiku.vip<br>    <span class="hljs-attribute">User</span> root<br>    <span class="hljs-attribute">Port</span> <span class="hljs-number">2222</span><br>    <span class="hljs-attribute">IdentityFile</span> ~/.ssh/bloghost<br></code></pre></td></tr></table></figure><p><code>Host *</code>表示对所有主机生效，后面的 <code>Port 2222 </code> 表示以后连接所有服务端都使用 2222 端口而不是默认的 22 端口，这样就不用在每次登录时都使用 <code>-p</code> 特别指定端口了。</p><p>SSH 客户端连接服务端长时间不操作会终止回话断开连接，下次连接又要发起登录请求，后面的两行可以保持长时间连接。</p><p><code>Host bloghost</code> 表示新的一项主机设置，真正连接主机名由下面的 <code>HostName</code> 决定，<code>bloghost</code> 可以理解为 <code>kiku.vip</code> 这个主机名的别名，如果使用 <code>ssh</code> 连接的是配置文件中的别名，就会套用后面指定的参数。例如 <code>ssh bloghost</code> 就相当于下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh kiku@kiku.vip -p 2222 -i ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p>  <a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">阮一峰：SSH原理与运用（一）：远程登录</a></p></li><li><p>  <a href="https://wangdoc.com/ssh/index.html">网道：SSH 教程</a></p></li><li><p>  <a href="https://www.bilibili.com/video/BV1Tf4y1x7vo">B 站：2.1.2 SSH工作原理</a></p></li><li><p>  <a href="https://ccstudio.org/linux/part1/remote.html#41-ssh%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">ssh基础使用</a></p></li><li><p>  <a href="https://www.jianshu.com/p/33461b619d53">图解 SSH 原理</a></p></li><li><p>  <a href="https://zhuanlan.zhihu.com/p/108161141">每天都在用 SSH，你知道 SSH 的原理吗？</a></p></li><li><p>  <a href="https://datatracker.ietf.org/doc/html/rfc4252#section-7">rfc4252：Public Key Authentication Method: “publickey”</a></p></li><li><p>  <a href="http://www.unixwiz.net/techtips/ssh-agent-forwarding.html#chal">How Key Challenges Work</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>cate1</category>
      
      <category>cate2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSH</tag>
      
      <tag>Linux</tag>
      
      <tag>安全</tag>
      
      <tag>VPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用阿里云 OSS 服务搭建博客图床</title>
    <link href="/2021/02/26/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/"/>
    <url>/2021/02/26/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用阿里云-OSS-服务搭建博客图床"><a href="#使用阿里云-OSS-服务搭建博客图床" class="headerlink" title="使用阿里云 OSS 服务搭建博客图床"></a>使用阿里云 OSS 服务搭建博客图床</h1><p>此前使用单独的 GitHub 仓库作为博客的图床，配合 jsDelivr 的免费 CDN 服务，访问起来没感到什么卡顿，并且还免费，存储空间暂时也不用担心。</p><p>但是使用 Typora 配合 PicGo 一键批量上传本地图片到 GitHub 仓库的成功率实在太低了。上传速度慢不说，经常连着上传好多次都失败，而 Typora 又不支持断点续传，下次又要重复上传已经成功上传的图片，使 GitHub 仓库中出现大量重复的图片。刚开始以为是 PicGo 的问题，并且每次 PicGo 报错日志都不一样。去 PicGo 的 issue 搜索了一下报错信息，作者的回复大都是网络原因导致，能顺利访问 GitHub 主站，不代表能顺利访问 GItHub API 地址。</p><p>但是更换几次网络环境还是问题依旧，终于，在经历一次连续几天的上传失败后终于忍无可忍，遂想着购买 OSS 服务来存储图片，之前尝试过七牛的 OSS 服务，虽然有免费空间，但是要自己的域名经过备案才让使用，否则只能使用七牛的子域名，最要命的是这个域名是临时的，一个月更换一次，意味着每个月得去替换博客中图片地址。因为自己的域名没备案，也懒得去备案，遂放弃七牛云。看了看腾讯和阿里的 OSS 产品，阿里的更加便宜，并且支付宝登录付款也安全方便。最后选择了阿里云 OSS 产品。</p><p>登录<a href="https://www.aliyun.com/">阿里云</a>，在产品 -&gt; 存储 -&gt; 中选择对象存储 OSS，开通服务。</p><p>![image-20210226165835593](阿里云OSS搭建博客图床 images/image-20210226165835593.png)</p><p>右上角进入阿里云控制台，左边列表中选择对象存储 OSS。</p><p>![image-20210226174816254](阿里云OSS搭建博客图床 images/image-20210226174816254.png)</p><p>点击左侧菜单的 Bucket 列表，创建一个新的 Bucket，一个 Bucket 可以理解为一个单独存储仓库，这个仓库可以用来存放任何文件，不只是图片。<strong>注意：Bucket 名称要全网唯一，读写权限改为公共读。</strong></p><p>![image-20210226175332347](阿里云OSS搭建博客图床 images/image-20210226175332347.png)</p><p>接下来需要获取阿里云账户 AccessKey ID 和 AccessKey Secret，这样就可以使用 PicGo 来管理仓库了。建议在当前账户创建一个 RAM 子账号，使用子账号的 AccessKey 更加安全。具体操作可以看阿里云的官方帮助：<a href="https://help.aliyun.com/knowledge_detail/38738.html">阿里云：如何获取AccessKey ID和AccessKey Secret</a>，<a href="https://help.aliyun.com/document_detail/28637.html">阿里云：创建RAM用户</a>。</p><p>打开 PicGo 的图床设置，填入上面提到的相关信息。</p><p>![image-20210226181918717](阿里云OSS搭建博客图床 images/image-20210226181918717.png)</p><p>存储空间名称即 Bucket 名称，存储区域和当初创建 Bucket 时选择的地域有关，可以进入自己刚才创建的 Bucket 概览页面查看。</p><p>![image-20210226182251848](阿里云OSS搭建博客图床 images/image-20210226182251848.png)</p><p>然后在 PicGo 上传区中选择阿里云 OSS 作为默认上传图床。</p><p>![image-20210226182534736](阿里云OSS搭建博客图床 images/image-20210226182534736.png)</p><p>至此 PicGo 设置完毕，使用 Typora 一键上传文章中所有本地图片，20 张图片几乎秒传，再也没碰到过各种上传失败了，看来之前真是错怪 PicGo 了。</p><p>![image-20210226183058424](阿里云OSS搭建博客图床 images/image-20210226183058424.png)</p><p><strong>注意：不要同时打开多个 Typora 窗口批量上传图片，否则可能在 PicGo 重命名图片上出现两张同名的图片发生覆盖的情况。</strong></p><p>有一个无伤大雅的小问题是，如果直接在新标签页中打开图片会被强制下载，绑定自定义域名可以解决这个问题，但是绑定的域名需要经过备案。详见：<a href="https://help.aliyun.com/document_detail/39545.html">阿里云：访问OSS资源后资源被强制下载</a></p><p>![image-20210226185319437](阿里云OSS搭建博客图床 images/image-20210226185319437.png)</p><p>使用几天后发现，如果博客只是搭给自己看的，没什么访问量的话，选择按量付费，经过抹零后甚至一分钱都不用花。</p><p>![image-20210226184555215](阿里云OSS搭建博客图床 images/image-20210226184555215.png)</p><p>![image-20210226184734486](阿里云OSS搭建博客图床 images/image-20210226184734486.png)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/63557477">知乎：阿里云oss搭建图床以及使用PicGO上传图片到图床</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
      <tag>PicGo</tag>
      
      <tag>阿里云</tag>
      
      <tag>OSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
