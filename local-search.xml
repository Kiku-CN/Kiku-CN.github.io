<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>VPS 初体验（五）将 Hexo 静态博客一键部署到 VPS</title>
    <link href="/2021/10/18/Hexo%20%E9%83%A8%E7%BD%B2%E5%88%B0%20VPS/"/>
    <url>/2021/10/18/Hexo%20%E9%83%A8%E7%BD%B2%E5%88%B0%20VPS/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用 Hexo 配合免费的 Github 的仓库和 Github Pages 可以快速在互联网上<a href="https://kiku.vip/2020/12/21/Hexo/">搭建自己的个人博客</a>。但是因为 GitHub Pages 在国内的访问速度太差，为了得到更好的访问体验，可以选择将博客部署到自己的 VPS 上。最直接的方法就是手动将生成的博客静态文件手动使用 FTP 上传到 Nginx 上的博客站点目录下，但是这样每次更新都要手动 FTP 上传显得麻烦且不优雅。</p><p>而 Hexo 本身提供了快速方便的<a href="https://hexo.io/zh-cn/docs/one-command-deployment.html">一键部署功能</a>，支持包括 Git、Netlify、SFTP 等多种部署方式。虑到稳定性和同步速度，最终选择了使用 Git 方式部署到 VPS。</p><p>首先需要在 VPS 上准备一个 Git 裸仓库作为 Hexo 的部署仓库。当运行 <code>hexo deploy</code> 命令时，会自动使用 <code>git push</code> 将博客的静态文件上传到 VPS 的 Git 仓库中。</p><p><strong>注意：裸仓一般都是用来当做远程的中心公共仓库，专门用来存储和同步分发，裸仓库可以被正常 <code>clone</code> 和 <code>push</code> ，但是裸仓没有 worktree 的，不能像普通仓库那样进行 <code>commit</code> 等 Git 操作。</strong></p><p>光把博客静态文件上传到仓库还不够，还需要拷贝到 Nginx 的博客站点目录一下才能被 HTTP(S) 访问。为此需要使用到 <a href="https://www.git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">Git Hooks</a> 功能，当服务器端的 Git 裸仓收到 git push 之后，会自动触发 Git Hooks 中的 <code>post-receive</code> 脚本，该脚本将 Git 裸仓中的文件拷贝到 Nginx 的博客站点目录下。这样就可以真正达到了 <code>hexo deploy</code> 命令全程自动部署的效果。</p><p>![<a href="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157666.png">使用Git Hook自动部署Hexo到个人VPS</a>](Hexo 部署到 VPS images/2755175395.png)</p><ol><li><p>  在宝塔面板已经创建好 kiku.vip 站点作为博客入口，站点的根目录为 <code>/www/wwwroot/kiku.vip</code>。</p></li><li><p>在 VPS 上安装 git，部分 Linux 发行版自带 git，可以跳过安装了。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install git<br></code></pre></td></tr></table></figure></li><li><p>在当前用户目录初始化一个 git 裸仓。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init --bare ~/hexoblog.git<br></code></pre></td></tr></table></figure></li><li><p>为创建的裸仓配置 <code>post-receive</code>这个钩子，当仓库有收发的时候就会自动调用这个钩子。 在 <code>~/blog.git</code> 裸库的 <code>hooks</code>文件夹中，新建并编辑 <code>post-receive</code>文件。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/hexoblog.git/hooks/post-receive<br></code></pre></td></tr></table></figure><p>  在文件中添加下面的脚本代码。如果为文件都修改了正确的权限下面出现的代码可以不加 <code>sudo</code>，为了图方便都和避免各种意想不到的权限错误，推荐直接加上 <code>sudo</code>。</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo rm -rf /www/wwwroot/kiku.vip<br>sudo git clone ~/hexoblog.git /www/wwwroot/kiku.vip<br></code></pre></td></tr></table></figure><p>  脚本的第 1 行是删除 <code>/www/wwwroot/kiku.vip</code> （即 <code>kiku.vip</code> 站点目录）下的文件，第 2 行将 <code>~/hexoblog.git</code>下的文件 <code>git clone</code> 到 <code>/www/wwwroot/kiku.vip</code> （即 <code>kiku.vip</code> 站点目录）。</p><p>  但更加推荐使用下面的脚本，效果和上面的两行脚本等效，但是比使用 <code>git clone</code> 的效率更高。<code>--work-tree</code> 参数后面是的是站点目录，<code>--git-dir</code> 参数指定的是 git 裸仓地址，注意要使用 <code>~/hexoblog.git</code> 因为用到了 sudo， <code>~</code> 会指向 root 用户目录，直接使用 <code>/home/Kiku/hexoblog.git</code>。</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo git --work-tree=/www/wwwroot/kiku.vip --git-dir=/home/Kiku/hexoblog.git checkout -f<br></code></pre></td></tr></table></figure><p>  整个的第 4 步可以用下面一行代码代替，省去了 vim 打开编辑的麻烦。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo sudo git --work-tree=/www/wwwroot/kiku.vip --git-dir=/home/Kiku/hexoblog.git checkout -f &gt; ~/hexoblog.git/hooks/post-receive<br></code></pre></td></tr></table></figure></li><li><p>赋予 <code>post-receive</code> 脚本文件可执行权限</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x ~/hexoblog.git/hooks/post-receive<br></code></pre></td></tr></table></figure></li><li><p>修改本地 Hexo 配置文件 <code>_config.yml</code> 中的 deploy 选项。<br>  <strong>注意如果 VPS 上的 SSH 的连接端口不是默认的 22 需要手动指定端口。</strong> </p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">Kiku@kiku.vip:/home/Kiku/hexoblog.git</span><br></code></pre></td></tr></table></figure><p>  如果想同时部署到 GitHub 和 VPS 上的 git 裸仓 deploy 应该如下：</p><p>  <strong>注意有多个部署选项时 <code>type</code> 时前面要添加 <code>-</code>。</strong></p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Kiku-CN/Kiku-CN.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">Kiku@kiku.vip:/home/Kiku/hexoblog.git</span><br></code></pre></td></tr></table></figure></li><li><p>重新生成部署 Hexo 博客，查看是部署是否成功。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean  # 先删除曾静态文件和缓存，避免可能的 Bug<br>hexo g -d  # hexo generate deploy<br></code></pre></td></tr></table></figure></li></ol><p>前前后后花了接近半个月的时间在 VPS 上，才终于把服务器折腾成自己想要的效果。在这个过程中学到了不少网络和服务器相关的知识，见识了中文互联网环境背后的那一面，发现了不少优质的博客。最好将自己的折腾过程总结成为 5 篇博客，VPS 折腾暂告一段，接下来全力准备找工作了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>  <a href="http://www.liuxinggang.com/archives/gethook_hexo_vps.html">使用Git Hook自动部署Hexo到个人VPS</a></li><li>  <a href="https://moelove.info/2016/12/04/Git-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%A3%B8%E4%BB%93%E5%BA%93/">Git 本地仓库和裸仓库</a></li><li>  <a href="https://hexo.io/zh-cn/docs/one-command-deployment.html">Hexo 一键部署</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>VPS</tag>
      
      <tag>Git</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPS 初体验（四）trojan 和 Nginx 共用 443 端口</title>
    <link href="/2021/10/17/trojan%20%E5%92%8C%20Nginx%20%E5%85%B1%E7%94%A8%20443%20%E7%AB%AF%E5%8F%A3/"/>
    <url>/2021/10/17/trojan%20%E5%92%8C%20Nginx%20%E5%85%B1%E7%94%A8%20443%20%E7%AB%AF%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于 trojan 默认工作在服务器的 443 端口，而 Nginx 的 HTTPS 服务端口也在 443，如果此时想同时使用两种服务。那么要么更改 trojan 默认端口，要么更改 Nginx 的 HTTPS 端口。如果选择更改 HTTPS 端口那么所有 URL 都要补充上端口号，既麻烦也不美观。那么更改 trojan 的默认监听端口可行吗？</p><p>trojan 的工作机制是客户端使用 TLS 对要代理的流量进行加密伪装成 HTTPS 流量发送给 trojan 服务端，trojan 服务端工作在 443 端口，对 TLS 加密的数据解密后进行流量识别，如果流量是 trojan 协议并且检查合法（检查 trojan 密码是否正确），说明来自正确的 trojan 客户端，对流量代理转发。如果流量不是 trojan 协议，说明不是来自 trojan 客户端的数据，则转发到则转发到服务端本地的 80 端口，而 80 端口则提前配置好一个 HTTP 伪装站点，向客户端响应 HTML 页面。</p><p>之前的代理协议例如 Shadowsocks、VMess，思路普遍都是使用各种复杂的加密，来避免流量特征被 GFW 识别，而 trojan 选择的是把 trojan 服务伪装成一个提供 HTTPS Web 服务的站点，流量在 GFW 看来和普通的 HTTPS 流量没什么区别，进而来躲避 GFW 的审查和封锁。 trojan 相比之前的协议传输效率更高（只有一层加密），抗封锁效果反而更好。</p><p>个人理解对 trojan 的伪装可以体现在下面几个方面</p><ol><li>  TCP 端口号和 HTTPS 一样工作在 443 端口。</li><li>  和普通 HTTPS 流量一样使用 TLS 协议进行加密。</li><li>  如果用户（可能是探针）使用 HTTPS 协议来访问 trojan server，用户看到的是预先准备好的伪装 Web 站点，和普通 Web 站点没有任何区别。</li></ol><p>因此 trojan 工作在 443 端口也是伪装的一部分，可以增加服务的隐蔽性，因此建议不要更改 trojan 的默认工作端口。</p><p><strong>注意：没有谁能确认 GFW 真正的工作机制，有的人改了 trojan 端口用的好好的，有的人没改还是被封，没有准确的统计数据来说明 trojan 使用 443 端口是否能真正减少封禁的几率。并且使用 trojan 协议在 443 端口也不代表永远不会被封禁，就可以高枕无忧、一劳永逸了。每种协议新出的时候大家都是充满了乐观，但是 GFW 的检测手段也在不断进化，有可能 GFW 已经检测出流量异常只不过没下手罢了。如果滥用节点，比如拿来开机场，或者发表一些敏感言论，被封禁的风险就会大大增加，甚至请你过去喝茶。此外特殊敏感时期的无差别封禁也有可能误伤到你的 VPS。</strong></p><p>那么有没有让 trojan 和 Nginx 公用 443 端口的办法呢？一番搜索之后得到了肯定的答案——利用 TLS 握手阶段的 SNI 信息将流量在 4 层进行转发。关于 SNI 转发的工作原理请看程小白的这篇文章 <a href="https://www.chengxiaobai.com/trouble-maker/trojan-shared-443-port-scheme">Trojan 共用 443 端口方案</a>。</p><p>前置环境：已经使用 <a href="https://github.com/Jrohy/trojan">Jrohy 的一键脚本</a> 安装了 trojan 和 trojan web 管理程序，trojan 所使用的域名为 <code>free.kiku.vip</code>， 访问 <a href="https://free.kiku.vip/">https://free.kiku.vip</a> 看到的 trojan web 管理面板。搭建可以看</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216487.png" alt="image-20211017193404608"></p><p>想要达到的目标：<code>free.kiku.vip</code> 还是用用来使用 trojan 代理服务，直接访问 <a href="https://free.kiku.vip/">https://free.kiku.vip</a> 看到的是伪装站点，访问 <a href="https://free.kiku.vip/admin">https://free.kiku.vip/admin</a> 才是 trojan web 管理面板。除了 <code>free.kiku.vip</code> 外的 <code>*.kiku.vip</code> 访问到正常的 HTTPS 服务，如果通过 HTTP 协议访问则强制跳转到 HTTPS。服务端除了 80 和 443 端口，其余端口关闭。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216489.png" alt="image-20211017193845759"></p><p>具体的配置步骤：</p><ol><li><p>为 Nginx 设置 SNI 识别转发，如果没有安装过 Nginx，可以直接在宝塔面板的应用商店搜索 Nginx 安装即可。如果是通过宝塔安装的 Nginx，配置文件路径在：<code>/www/server/nginx/conf/nginx.conf</code>。<br>  在配置文件的 events 和 http 模块之间添加下面的内容。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 流量转发核心配置</span><br><span class="hljs-section">stream</span> &#123;<br>    <span class="hljs-comment"># 这里就是 SNI 识别，将域名映射成一个配置名</span><br>    <span class="hljs-attribute">map</span> $ssl_preread_server_name $backend_name &#123;<br>        *.kiku.vip web;<br>        free.kiku.vip trojan;<br>        <span class="hljs-comment"># 域名都不匹配情况下的默认值</span><br>        <span class="hljs-attribute">default</span> web;<br>    &#125;<br><br>    <span class="hljs-comment"># web，配置转发详情</span><br>    <span class="hljs-attribute">upstream</span> web &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:4431</span>;<br>    &#125;<br>    <span class="hljs-comment"># trojan，配置转发详情</span><br>    <span class="hljs-attribute">upstream</span> trojan &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:4432</span>;<br>    &#125;<br><br>    <span class="hljs-comment"># 监听 443 并开启 ssl_preread</span><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> reuseport;<br>        <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">443</span> reuseport;<br>        <span class="hljs-attribute">proxy_pass</span>  $backend_name;<br>        <span class="hljs-attribute">ssl_preread</span> <span class="hljs-literal">on</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  也可以直接在宝塔面板 Nginx 管理中直接修改配置。</p><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216490.png" alt="image-20211017175843811"></p></li><li><p>修改 trojan 的监听地址和端口号以及如果识别为非 trojan 流量的回落端口号，trojan配置文件路径为 <code>/usr/local/etc/trojan/config.json</code> 。<br>  下面是配置文件的关键内容：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;run_type&quot;</span>: <span class="hljs-string">&quot;server&quot;</span>,<br>    <span class="hljs-attr">&quot;local_addr&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;local_port&quot;</span>: <span class="hljs-number">4432</span>,<br>    <span class="hljs-attr">&quot;remote_addr&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;remote_port&quot;</span>: <span class="hljs-number">82</span>,<br><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改 <code>free.kiku.vip</code> 的站点的 Nginx 配置文件，文件路径为 <code>/www/server/panel/vhost/nginx/free.kiku.vip.conf</code>。<br>  下面是配置文件的完整内容：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs nginx">server<br>&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">127.0.0.1:82</span>;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br><br>    <span class="hljs-attribute">server_name</span> free.kiku.vip;<br>    <span class="hljs-attribute">index</span> index.php index.html index.htm default.php default.htm default.html;<br>    <span class="hljs-attribute">root</span> /www/wwwroot/free.kiku.vip;<br><br>    <span class="hljs-comment"># 80 端口的访问强制跳转到 https 443</span><br>    <span class="hljs-attribute">if</span> ($server_port =  <span class="hljs-number">80</span>)&#123;<br>        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(/.*)$</span> https://$host<span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br>    &#125;<br><br>    <span class="hljs-comment"># 后台管理页面,通过 free.kiku.vip/admin 访问</span><br>    <span class="hljs-attribute">location</span> /admin &#123;<br>        <span class="hljs-attribute">proxy_pass</span>   http://localhost:81/;<br>    &#125;<br><br>    <span class="hljs-comment"># 由于 trojan web 前端的部分资源是写在二进制中的，这些资源的访问路径固定</span><br>    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~* ^/(static|common|auth|trojan)/</span> &#123;<br>        <span class="hljs-attribute">proxy_pass</span>  http://localhost:81;<br>        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Upgrade $http_upgrade;<br>        <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;Upgrade&quot;</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Host $host;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>  也可以选择直接在宝塔面板中修改站点的配置文件。</p><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216491.png" alt="image-20211017175540571"></p></li><li><p>修改 <code>kiku.vip</code> 的站点的 Nginx 配置文件，文件路径为 <code>/www/server/panel/vhost/nginx/kiku.vip.conf</code>。<br>  下面是配置文件的关键内容：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx">server<br>&#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">4431</span> ssl http2;<br>    <span class="hljs-attribute">server_name</span> kiku.vip;<br>    <br>    <span class="hljs-comment"># http 强制跳转到 https</span><br>    <span class="hljs-attribute">if</span> ($server_port !<span class="hljs-regexp">~ 443)</span>&#123;<br>        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(/.*)$</span> https://$host<span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改 trojan web 管理面板的监听端口号为 81，trojan web 的配置文件路径为 <code>/etc/systemd/system/trojan-web.service</code> 。<br>  下面是配置文件的完整内容，和原版配置区别在于第 9 行结尾使用 <code>-p</code> 指定了端口号。</p>  <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs txt">[Unit]<br>Description=trojan-web<br>Documentation=https://github.com/Jrohy/trojan<br>After=network.target network-online.target nss-lookup.target mysql.service mariadb.service mysqld.service docker.service<br><br>[Service]<br>Type=simple<br>StandardError=journal<br>ExecStart=/usr/local/bin/trojan web -p 81<br>ExecReload=/bin/kill -HUP \$MAINPID<br>Restart=on-failure<br>RestartSec=3s<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure></li><li><p>配置完毕后重启 Nginx 和 trojan，让配置生效。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">service nginx restart<br>trojan restart<br></code></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>  <a href="https://trojan-gfw.github.io/trojan/">trojan 官方文档</a></li><li>  <a href="https://github.com/Jrohy/trojan/wiki">trojan 多用户管理部署程序 Wiki</a></li><li>  <a href="https://www.chengxiaobai.com/trouble-maker/trojan-shared-443-port-scheme">Trojan 共用 443 端口方案</a></li><li>  <a href="https://www.v2rayssr.com/trojanwordpress.html">Trojan+Nginx+WordPress个人博客，共用443端口！所有访问全部开启HTTPS，Trojan终极伪装！</a></li><li>  <a href="https://github.com/jinwyp/one_click_script#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-advanced-usage-%E4%B8%8E%E7%8E%B0%E6%9C%89%E7%BD%91%E7%AB%99%E5%85%B1%E5%AD%98">一键安装 trojan v2ray xray. Install v2ray / xray (VLESS) and trojan (trojan-go) script</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>trojan</tag>
      
      <tag>HTTP</tag>
      
      <tag>HTTPS</tag>
      
      <tag>Nginx</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPS 初体验（三）在 VPS 上快速搭建 trojan 服务</title>
    <link href="/2021/10/16/%E5%9C%A8%20VPS%20%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20trojan%20%E6%9C%8D%E5%8A%A1/"/>
    <url>/2021/10/16/%E5%9C%A8%20VPS%20%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20trojan%20%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>安装前需要准备好一个域名已经解析到 VPS 的 IP 地址，二级域名三级域名都可以。</p><p>运行下面的一键安装脚本（需要切换到 root 用户）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">安装/更新</span><br>source &lt;(curl -sL https://git.io/trojan-install)<br><br><span class="hljs-meta">#</span><span class="bash">卸载</span><br>source &lt;(curl -sL https://git.io/trojan-install) --remove<br></code></pre></td></tr></table></figure><p>因为 trojan 协议中用到了 TLS 加密，需要申请证书。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218946.png" alt="image-20211016150810283"></p><p>输入 <code>1</code> 回车，申请免费的 Let’s Encrypt 证书，时长为 3 个月，到期前会自动续签。</p><p>然后输入提前准备好的域名，这里以 free.kiku.vip 为例</p><p>接下来需要安装数据库，如果没有安装过 MySQL 就选择 1。 </p><p>接下来提示设置管理员密码，使用该密码以管理员登录 trojan web 管理后台，管理员用户名默认为 admin 且不可更改。</p><p>然后给 trojan 初始用户设置用户名和密码，生成的 trojan 分享链接有关，也可以使用该初始用户登录 trojan web 管理后台查看自己的流量使用情况。</p><p>安装完毕后 trojan 会自动启动，在 Shell 中输入 <code>trojan</code> 可以对 trojan 进行一些管理设置。输入 <code>5</code> 可以得到 trojan 的分享链接，和之前设置初始的用户相对应。不输入任何数字直接回车可以退出管理程序，回到 Shell 环境。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218947.png" alt="image-20211016232340427"></p><p>浏览器访问之前输入的域名 <a href="https://free.kiku.vip/">https://free.kiku.vip</a> 访问 trojan web 管理面板，通过管理员帐号和用户都能登录。</p><p>管理员可以在 Web 界面中查看 trojan 的运行统计数据，对 trojan 用户进行管理。普通用户只能查看到自己的流量统计。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218948.png" alt="image-20211017130244204"></p><p>在管理界面的用户管理栏也能得到用户对应的 trojan 分享链接。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218950.png" alt="image-20211017130719579"></p><p>至此服务端已经搭建完毕，接下来是客户端配置。</p><p>在安卓手机可以使用 trojan 协议专用的客户端 <a href="https://github.com/trojan-gfw/igniter">Igniter</a> 来进行代理。只需要点击右上角粘贴上面得到的分享连接即可。</p><p>在 PC 中除了要下载客户端外还要为浏览器或者应用设置代理。</p><p>PC 上推荐使用 v2rayN 客户端，支持协议众多，最新的 v2rayN 已经支持 trojan 协议。<a href="https://github.com/2dust/v2rayN/releases/download/4.20/v2rayN.zip">下载 v2rayN 客户端</a>并运行，复制上面的分享链接，在 v2rayN 中选择从剪贴板导入服务器。选择刚才添加的 trojan 服务器然后回车，列表前面有 √ 的服务器代表当前连接使用的服务器。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218951.png" alt="image-20211017132241969"></p><p>服务器添加成功后，有下面两种方式使用代理上网：</p><ol><li><p>右键任务栏的 v2rayN 图标，选择自动配置系统代理。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218952.png" alt="image-20211016233558949"><br>  设置成功后代理服务器会自动被添加到 Internet 选项中。系统代理对所有浏览器以及部分自动使用系统代理的桌面应用生效，这些生效的应用的所有流量都会走代理。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218953.png" alt="image-20211016233811251"></p></li><li><p>下载 <a href="https://github.com/FelisCatus/SwitchyOmega/releases/download/v2.5.20/SwitchyOmega_Chromium.crx">SwitchyOmega</a> 插件拖动到浏览器中安装，或者直接从 <a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif">Chrome 应用商店</a>安装。</p><p>  新建情景模式，选择代理服务器模式。</p><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218954.png" alt="image-20211017002821872"></p><p>  填写的代理协议和端口要和 v2rayN 主界面最下面下面状态栏的本地代理服务器地址和端口匹配。</p><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218955.png" alt="image-20211017132040245"></p><p>  新建情景模式，选择自动切换模式，参考下图设置，规则列表的地址是 <code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>。</p><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218956.png" alt="image-20211017003300414"></p><p>  设置成功后将模式切换为 auto switch 模式，这样就会自动分流，访问国内网站的时候不走代理，访问谷歌等科学网站就会自动使用代理。也可以在某些网站添加新的切换规则或者临时使用代理，相比第 1 中方法更加灵活方便，因此更加推荐使用第 2 中方法。</p><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218957.png" alt="image-20211017125821159"></p><p>  使用第 2 种方法建议右键任务栏的 v2rayN 图标，清除掉系统代理，这样只有使用 <a href="https://github.com/FelisCatus/SwitchyOmega/releases/download/v2.5.20/SwitchyOmega_Chromium.crx">SwitchyOmega</a> 插件的浏览器才通过代理上网，避免对其他的应用的上网方式产生影响。如果某个应用需要使用代理，需要手动在应用设置找到代理设置填写代理协议和端口。以 Telegram 桌面应用为例：</p><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218958.png" alt="image-20211017132815559"></p></li></ol><p>代理设置成功后在浏览器中使用 SpeedTest 测试代理速度，本地使用的是电信 50 M 校园网，可以跑满 VPS  30 Mbps 的带宽。</p><p>长沙联通节点：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218959.png" alt="image-20211016154612731"></p><p>黄冈电信节点：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218960.png" alt="image-20211016230623209"></p><p>香港节点：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218961.png" alt="image-20211016153727954"></p><p>下午 4 点 YouTube 连接情况：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218962.png" alt="image-20211016155320235"></p><p>晚上 11 点高峰期 YouTube 连接情况：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218963.png" alt="1c2g50GB youtubetest"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>  <a href="https://trojan-gfw.github.io/trojan/">trojan 官方文档</a></li><li>  <a href="https://github.com/Jrohy/trojan">trojan 多用户管理部署程序</a></li><li>  <a href="https://trojan-tutor.github.io/2019/04/10/p41.html">自建梯子教程 –Trojan版本</a></li><li>  <a href="https://github.com/V2RaySSR/Trojan_panel_web">一键更改 Trojan-Panel 面板端口并设置伪装站点</a></li><li>  <a href="https://breakthewa11.com/archives/trojan-%E4%BB%8E%E6%9C%AA%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95.html">Trojan，从未如此简单！</a></li><li>  <a href="https://www.v2rayssr.com/trojan-set.html">Trojan史上最全面的脚本！Trojan所有脚本集合！Trojan面板，单Trojan服务！</a></li><li>  <a href="https://ssr.tools/150">强大代理扩展插件SwitchyOmega使用教程 火狐/Chrome适用</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VPS</tag>
      
      <tag>trojan</tag>
      
      <tag>Linux</tag>
      
      <tag>Chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPS 初体验（二）使用 SSH 连接远程主机</title>
    <link href="/2021/10/14/%E4%BD%BF%E7%94%A8%20SSH%20%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/"/>
    <url>/2021/10/14/%E4%BD%BF%E7%94%A8%20SSH%20%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><p>Linux 发行版  和最新的 Windows 10 都自带了 OpenSSH 客户端，以 Windows 10为例，OpenSSH 客户端程序位于<code>C:\Windows\System32\OpenSSH\ssh.exe</code> 这个路径下，该路径已经被添加到系统环境变量 PATH 中，因此在终端中可以直接使用 <code>ssh</code> 命令来运行 SSH 客户端。在 <code>ssh</code> 命令后面接 <code>-V</code> 参数来查看 SSH 客户端版本号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -V<br></code></pre></td></tr></table></figure><p>SSH 客户端最常用的功能就是用来登录远程的服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh hostname<br></code></pre></td></tr></table></figure><p><code>hostname</code> 用来指定主机名，可以是域名、主机的 IP 地址、也可以是配置文件中的主机别名。默认使用当前客户端的用户名（也就是当前 Windows 所使用的的用户名）去登录远程主机。</p><p>可以在主机名前面用指定要登录的用户名，用 <code>@</code> 符号分隔。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh username@hostname<br></code></pre></td></tr></table></figure><p>也可以使用 <code>-l</code> 参数来指定要登录的用户名，和上面等效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh hostname -l username <br></code></pre></td></tr></table></figure><p>SSH 客户端默认连接服务器的 22 端口（SSH 服务端程序的默认监听端口），<code>-p</code> 参数可以指定其他端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh hostname -p 2222<br></code></pre></td></tr></table></figure><p>当客户端向服务端发起 SSH 连接请求时，SSH 服务端会将 <code>/etc/ssh</code> 目录下的 Host Key 公钥发回客户端，用来认证服务端的身份信息。</p><p>如果用户是第一次连接到该主机，SSH 客户端会提示用户确认服务端的公钥指纹。</p><p>如果选择信任该公钥，会将主机名和对应的公钥都储存在本机的 <code>~/.ssh/known_hosts</code> 文件中。以后再连接该主机时，如果主机发回的公钥和文件中的不符，则提示可能遭受中间人攻击并断开连接（HTTPS 用 CA 证书中心解决了该问题）。</p><p>如果确认是远程主机因为某些原因，例如重装系统或者重装 SSH 服务而重新生成了 Host Key公钥，那就需要在本地主机上使用以下命令将原来的公钥信息删除，或者手动打开 <code>~/.ssh/known_hosts</code> 文件删除对应的项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -R hostname # hostname 是发生公钥变更的主机名。<br></code></pre></td></tr></table></figure><p>删除了原来的公钥信息后，重新执行 ssh 命令连接远程服务器，重新确认服务端的公钥指纹，就可以发起连接请求了。</p><p>发起连接请求后 SSH 客户端会和服务端是进行版本协商、算法协商、秘钥交换，其中又用到了对称加密、非对称加密和密钥交换的各种算法（思路有和 HTTPS 中的 SSL/TLS 协议类似的地方，都是用非对称加密来交换对称秘钥，真正的消息内容都是使用的都是基于对称加密的的临时回话密钥（Session Key）进行加密，如果全程都使用非对称加密效率太低）。只需要知道 SSH 连接成功后建立了安全通道，具体的连接过程在此不深究。</p><p>客户端就与服务器建立连接 SSH 连接成功后，ssh 就会要求用户输入所要登录账户的密码，输入用户密码验证正确以后，就可以得到远程服务器的 Shell 环境了。</p><h2 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h2><h3 id="原理步骤"><a href="#原理步骤" class="headerlink" title="原理步骤"></a>原理步骤</h3><p>公钥免密登录步骤是：</p><ol><li>  用户根据非对称加密算法，生成一对密钥对。</li><li>  提前将密钥对中的公钥放置在远程主机用户目录下的 <code>~/.ssh/authorized_keys</code> 文件中。</li><li>   SSH 客户端指定某用户发起登录请求。</li><li>  SSH 服务端收到该用户的登录请求，SSH 服务端生成一个随机数，使用指定用户的用户目录下的 <code>~/.ssh/authorized_keys</code> 文件中的公钥列表中一个公钥加密，将加密后的数据给客户端。</li><li>  客户端使用密钥对中的私钥对这段随机数解密，解密结果和 Session ID 使用 MD5 算法生成摘要发回给服务端。如果私钥解密的数据发回服务器的时候如果被中间人劫持因为 Session  ID 也可以</li><li>  SSH 服务端用之前生成的随机数同样加上 Session ID 计算 MD5 hash 值，如果和客户端发过来的摘要匹配成功，就说明请求者拥有公钥所对应的私钥，即可以以该用户登录，不再需要输入密码。如果不匹配则回到第 4 步中使用公钥文件中的剩余公钥重复这个过程。如果所有的公钥都失败，则说明公钥登录失败，会提示用户输入密码登录。</li><li>  SSH 服务端遍历登录请求中指定用户的用户目录下的 <code>~/.ssh/authorized_keys</code> 文件中的公钥来解密，如果有一条公钥的解密结果和服务端之前发出的数据一致，如果该文件中的所有公钥的解密结果都匹配不上则显示输入密码登录。</li></ol><p>（其实还有 Session ID 等其他信息）数字签名，然后发回给服务端。</p><p>关于第 4 步中发送的随机数到底是直接发送还是使用 <code>authorized_keys</code> 中的公钥将加密后再发送的有不少的争议。</p><p>阮一峰的文章说的直接发送，但是要在第 5 步对响应给服务端的数据进行数字签名，如果第 5 步服务端使用公钥解签得到的摘要和原本的摘要一致也能证明认证用户的身份。</p><blockquote><p>  所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。——阮一峰：SSH原理与运用（一）：远程登录</p></blockquote><p>个人觉得阮提出的方法效率会更高，因为 <code>~/.ssh/authorized_keys</code> 文件中可以存放多个公钥，每一行都是一个公钥，服务端并不知道应该用哪个公钥来加密随机数，最差结果就是所有公钥都要按照上面的流程尝试一边，效率显然不如直接发送然后在服务端遍历公钥列表来解密私钥签名信息对比效率高。并且哪怕是随机数被中间人偷听了也无所谓，中间人没有真正的私钥能对随机数据进行正确签名的。</p><p>具体是哪一种也没去看底层代码验证过，无论是公钥加密，私钥解密，还是私钥签名，公钥解签，都能证明你是私钥的拥有者即可。</p><p>虽然个人很信任阮大，但是因为持后一种说法人太多，并且差了不少英文文章都是这样说，还是采纳了后一种说法。</p><p><strong>注意：很多人的文章说用户在发起登录请求会把公钥发送给服务端，这样服务端就知道用哪个公钥加密了，但是经过实验在本地主机删除了公钥文件也可以成功登录，说明并不存在发送公钥的行为。</strong></p><h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><p>首先要使用 <code>ssh-keygen</code> 命令，生成一对密钥对。<code>-t</code> 是用来指定非对称加密使用的算法，可选 dsa 或者 rsa，默认值是 rsa。<code>-b</code> 是用来指定秘钥的二进制位数，<code>-b </code>至少应该是 <code>1024</code>，更安全一些可以设为 <code>2048</code> 或者更高。<code>-b</code> 至少应该是 <code>1024</code>，更安全一些可以设为 <code>2048</code> 或者更高。<code>-C</code> 参数可以为密钥文件指定新的注释，建议的格式为 <code>username@hostname</code>。<code>-f</code>参数指定生成的秘钥文件路径和名称。这些参数包括注释都是可选的，如果省略就使用默认值。</p><p><strong>注意：如果之前使用过 Github 的 SSH 免密登录功能，该目录下会有生成过的秘钥对，可以直接使用这套秘钥对来进行免密登录。当然也可以再创建新的密钥对，但是注意用 <code>-f</code> 参数指定秘钥文件路径和名称，不要把原来的秘钥文件覆盖了，否则 GitHub 的免密登录会失败。</strong></p><p>输入下面的命令就会在 SSH 的配置目录 <code>~/.ssh</code> 下生成名为 <code>id_rsa</code>（私钥）和<code>id_rsa.pub</code>（公钥）秘钥对文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096 -C &quot;root@kiku.vip&quot;<br></code></pre></td></tr></table></figure><p>在生成秘钥的过程中会询问是否要为私钥设定密码（passphrase，为了和用户密码 password 区别），如果设定密码则在使用私钥前还要输入密码对私钥解锁，虽然和密码口令登录一样时要输入密码，但是更加安全。如果为了方便，不想设定密码，直接输入两次回车就好。</p><h3 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h3><p>免密登录能成功的前提是用户已经将提前将秘钥对中的公钥添加到远程主机的 <code>~/.ssh/authorized_keys</code> 文件中，因此生成密钥对以后，还得把公钥必须上传到服务器，才能使用公钥登录。</p><p>要以哪个用户的身份登录到服务器，密钥就必须保存在该用户主目录的<code>~/.ssh/authorized_keys</code>文件。</p><p>下面提供三种上传公钥到远程主机上的方法：</p><ol><li><p>如果购买的是大厂云服务器，可以直接在控制台中上传公钥。以腾讯轻量应用服务器为例：<br>  首先要在控制台中创建秘钥：<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218790.png" alt="image-20211014162335502"><br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218791.png" alt="image-20211014162545603"><br>  然后将秘钥绑定到我们远程主机上。<br>  <strong>注意：腾讯云控制台上传的公钥只能绑定在 root 用户下，并且绑定后将不能再通过密码方式 SSH 登录。</strong><br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218792.png" alt="image-20211015175759714"></p></li><li><p>手动将本地的公钥文件写入到远程主机上。<br>  在远程主机执行下面的命令。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/.ssh  <br>chmod 700 ~/.ssh<br>vi ~/.ssh/authorized_keys<br>chmod 600 ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>  第 1、2 行是在用户的主目录下创建 <code>.ssh</code> 的目录并设置权限为只有该用户可以访问，第 3 行打开信任的公钥文件，将公钥粘贴进去然后保存退出，第 4 行更改公钥文件的权限只有所有者有读写权限。如果权限设置不对，SSH 服务器可能会拒绝读取该文件。</p><p>  <strong>注意：该文件中可以存放多个公钥，每一行都是一个公钥，为了不影响其他客户端的登录应该把公钥追加到末尾，而不是直接覆盖。并且最后在后面添加一个换行，防止下次添加的公钥接在了同一行后面。</strong></p><p>  也可以使用在本地主机运行下面的命令将公钥上传到远程主机，其中<code>~/.ssh/id_rsa.pub</code> 替换成本地公钥存放的位置， <code>username@hostname </code> 要替换成你所要登录的用户名和主机名。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat ~/.ssh/id_rsa.pub | ssh user@host &quot;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys&quot;<br></code></pre></td></tr></table></figure><p>  但是还是要登录远程主机，执行下面的命令修改目录和文件的权限才能成功。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 700 ~/.ssh<br>chmod 600 ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>ssh-copy-id</code> 命令：自动上传公钥，Linux 上自带的 OpenSSH 自带一个 <code>ssh-copy-id</code> 命令，可以自动将公钥拷贝到远程服务器的<code>~/.ssh/authorized_keys</code>文件。<br>  用户在本地 Linux 计算机执行下面的命令，就可以把本地的公钥拷贝到服务器。 <code>-i</code> 参数指定上传的公钥文件。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ssh-copy-id -i key_file user@host</span><br></code></pre></td></tr></table></figure><p>  <strong>注意：Windows 10 的自带的 OpenSSH 并没有 <code>ssh-copy-id</code> 工具，因此无法使用该命令，网上有一些第三方对的实现，可用性没有测试过，建议 Windows 使用前面两种方法，</strong></p></li></ol><p>上传成功后使用下面命令就可以顺利免密登录，不用再输入密码。可以使用 <code>-i</code> 参数指定使用的私钥文件，默认使用的私钥文件为 <code>~/.ssh/id_rsa</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh admin@kiku.vip -p 2222 -i ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>SSH 客户端的相关配置文件在本地主机的 <code>~/.ssh</code> 目录下，使用 <code>ssh-keygen</code> 命令生成的密钥对，还有信任主机列表 <code>known_hosts</code> 文件都在该目录下。</p><p>而 <code>~/.ssh/config</code> 文件是 SSH 客户端配置文件，如果该目录下不存在该文件，可以手动创建一个名为 <code>config</code> 无后缀格式的纯文本文件。</p><p>使用 SSH 客户端配置文件，可以按照不同服务器，列出各自的连接参数，从而不必每一次登录都输入重复的参数。下面是一个例子，例子里面的缩进格式并不是必需的，只是为了视觉上区分不同主机的设置。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Host</span> *<br>    <span class="hljs-attribute">Port</span> <span class="hljs-number">2222</span><br>    <span class="hljs-comment"># 断开时重试连接的次数</span><br>    <span class="hljs-attribute">ServerAliveCountMax</span> <span class="hljs-number">5</span><br>    <span class="hljs-comment"># 每隔 60 秒自动发送一个 keepalive 信号以保持连接</span><br>    <span class="hljs-attribute">ServerAliveInterval</span> <span class="hljs-number">60</span><br>     <br><span class="hljs-attribute">Host</span> bloghost<br>    <span class="hljs-attribute">HostName</span> kiku.vip<br>    <span class="hljs-attribute">User</span> root<br>    <span class="hljs-attribute">Port</span> <span class="hljs-number">2222</span><br>    <span class="hljs-attribute">IdentityFile</span> ~/.ssh/bloghost<br></code></pre></td></tr></table></figure><p><code>Host *</code>表示对所有主机生效，后面的 <code>Port 2222 </code> 表示以后连接所有服务端都使用 2222 端口而不是默认的 22 端口，这样就不用在每次登录时都使用 <code>-p</code> 特别指定端口了。</p><p>SSH 客户端连接服务端长时间不操作会终止回话断开连接，下次连接又要发起登录请求，后面的两行可以保持长时间连接。</p><p><code>Host bloghost</code> 表示新的一项主机设置，真正连接主机名由下面的 <code>HostName</code> 决定，<code>bloghost</code> 可以理解为 <code>kiku.vip</code> 这个主机名的别名，如果使用 <code>ssh</code> 连接的是配置文件中的别名，就会套用后面指定的参数。例如 <code>ssh bloghost</code> 就相当于下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh kiku@kiku.vip -p 2222 -i ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p>  <a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">阮一峰：SSH原理与运用（一）：远程登录</a></p></li><li><p>  <a href="https://wangdoc.com/ssh/index.html">网道：SSH 教程</a></p></li><li><p>  <a href="https://www.bilibili.com/video/BV1Tf4y1x7vo">B 站：2.1.2 SSH工作原理</a></p></li><li><p>  <a href="https://ccstudio.org/linux/part1/remote.html#41-ssh%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8">ssh基础使用</a></p></li><li><p>  <a href="https://www.jianshu.com/p/33461b619d53">图解 SSH 原理</a></p></li><li><p>  <a href="https://zhuanlan.zhihu.com/p/108161141">每天都在用 SSH，你知道 SSH 的原理吗？</a></p></li><li><p>  <a href="https://datatracker.ietf.org/doc/html/rfc4252#section-7">rfc4252：Public Key Authentication Method: “publickey”</a></p></li><li><p>  <a href="http://www.unixwiz.net/techtips/ssh-agent-forwarding.html#chal">How Key Challenges Work</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VPS</tag>
      
      <tag>SSH</tag>
      
      <tag>Linux</tag>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPS 初体验（一）基础配置</title>
    <link href="/2021/10/13/VPS%20%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/10/13/VPS%20%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>去年刚开始捣鼓静态博客的时候，就有买一台云服务器来托管博客的想法，但需求又不是那么强烈。GitHub Pages 虽然在国内访问确实龟速，还时不时会挂掉。但是一想到又要额外花一笔钱和精力在上面又有点觉得不值，反正博客只是自己个人看看，访问速度慢点就慢点吧，实在不行再去套一层 CDN 试试，再加上后来有段时间博客没怎么打理，买云服务器的想法也就不了了之了。</p><p>最近又萌生了买云服务器的想法。</p><p>一是因为要准备找工作，简历上要给出项目的在线预览地址，这时再用 GitHub Pages 来展示就不太好了，说不定面试官预览的时候半天刷新不出来甚至就挂掉了，毕竟 GitHub 的网络不确定性太大了，与其挑战面试官的耐心还是多花几个钱提升下访问速度。</p><p>二是最近科学上网频繁，免费的代理工具虽白嫖很爽，但体验普遍都不怎么样，速度差且不稳定，有时候加载个搜索结果都要好几秒，看高清视频就更不用想了，不停的卡顿浪费时间和心情。再者流量要经过别人服务器，存在一定安全隐患，用起来总归是有点不安心。</p><p><strong>注意：代理提供方完全有能力收集用户的全部上网信息（例如访问者的 IP，目标的的域名或者 IP，访问时间等），甚至使用深度包检测提取 HTTP 明文流量中的户名和密码，然后将数据专卖给黑产。这并不是杞人忧天，此前已有先例。不要以为自己作为普通人的隐私数据没有什么价值不会被盯上。举个简单的例子，比如你通过代理工具上网注册了某平台的足彩网站，一段时间后就可能别的平台的博彩广告找到你，到底是代理提供方还是注册平台贩卖了你的电话不得而知，这个例子只是为了说明个人的隐私完全是有利可图的。总之就是时刻注意隐私泄漏问题，尽可能不要在不可信的信道传输自己的敏感信息。特别是那些打着永久免费旗号软件中还没有广告插入的的代理提供方需要格外注意。天下没有免费的午餐，有时候免费的反而是最贵的。即使使用的是付费服务就并不代表就没有风险，特别是一些可能随时跑路小机场，本来就和灰黑产走的很近，滥权也不奇怪。使用国内外知名大厂的  VPS 自建代理服务器可以把泄露风险降到最低。这些大厂和国内三大运营商比某些无良机场主值得信赖得多，只要不滥用，一般不会有被请喝茶的风险</strong></p><p>三是除了搭博客外还有其他可能用得到服务器的地方，例如后端接口项目，内网穿透，搭建图床。</p><p>尽管入坑的理由又更加充足，但还是纠结了两天。如果决定入坑，不只是下单付款那么简单，有太多知识要学习了，肯定要花不少时间，准备秋招的时间就更少了。</p><p>考虑再三，终于下定决心购买了年轻人的第一台 VPS，开启了 VPS 的折腾之路。</p><h2 id="购买-VPS"><a href="#购买-VPS" class="headerlink" title="购买 VPS"></a>购买 VPS</h2><p>关于 VPS 的选购其实个人不做任何产品推荐，因为我也才刚刚入坑，我真正上手测试过的 VPS 就两家，不像很多大佬对很多自己就有几十上百台 VPS 同时在线，对不同厂商的套餐类型线路都如数家珍。这里仅仅谈一谈自己选购的思路。</p><p>根据前面的提到我对 VPS 的几点需求（一句话说就是托管博客和前端项目以及搭建代理），列出了下面几条筛选条件：</p><ol><li>  服务器地点一定要是非大陆，一是备案麻烦，二是有爬墙需求。</li><li>  离大陆越近越好，最好直接接壤，延迟会低一点。结合上第 1 条其实可选择的地点范围就已经出来了：香港、韩国、日本、俄罗斯。不知为什么我对海底光缆充满了不信任，但其实只要线路优质，跨洋距离远也不是什么大问题，延迟高一点关系但只要不丢包体验一样也很好。</li><li>  对 CPU 性能，内存、硬盘无要求，性能再弱鸡跑个静态网页和代理服务器应该没什么问题。</li><li>  带宽能看流畅观看 1080P 视频就可以，10 Mbps 就满足了，再个人而言高带宽的意义不是很大。国内的服务器带宽贵的离谱，普遍都是 1M 2M 小水管，而国外的 VPS 带宽往往都很足，动辄上 G 的带宽（尽管是共享带宽），平常时间可以跑出几百兆的下载速度，但是毕竟国内总的出口带宽有限，一到晚上高峰期体验就会急剧下降，除非是选择像 CN2 GIA 那样的优质线路，注意优质线路的同时也意味着价格可能会成倍上涨。</li><li>  老牌厂商，不会有跑路和隐私泄漏风险。</li></ol><p>对比国内外知名厂商的一些产品套餐，结合群里大佬们给出的意见，最后选择腾讯轻量应用服务器香港节点 24 元每月的套餐：CPU - 1核，内存 - 1GB，系统盘 - SSD 25GB，流量包 - 1024 GB/月（峰值带宽 30 Mbps）。如果以后性能不够可以在原套餐上无缝升级，无需迁移备份。如果选择绑定代理的话实际到手价格还能更优惠一点。</p><p>腾讯云在国内的云厂商中还算比较良心了，虽然这款目前已经不走 CN2 GIA 线路了，但是线路质量也还算不错，几天轻度使用下来也没高峰期的也没感到什么卡顿。这款 24 元套餐性价比在国内厂商中算很高了，基本每天开售十几分钟就售罄了（腾讯轻量云是每天十点补货）。阿里云有款同配置同价格的套餐，传说腾讯轻量云的线路会好点。</p><p>云主机，云服务器，虚拟主机在大多数场景几个名词可以相互替换，不用严格去区分概念，都可以简单理解为一台带公网 IP 的 7 * 24 小时运行的计算机。但注意要和网页主机（Web Host）区分，网页主机实际上只是提供云空间来存储静态网页或者例如 WordPress 这种特定的动态网站，使用方向非常受限。VPS（Virtual Private Server）更喜欢用来称呼个人或着小企业用的小型云服务器，相比传统的云服务器，VPS 的硬件规模更小，价格也亲民许多，当然性能也会有很大差距。</p><p>以<a href="https://cloud.tencent.com/document/product/1207/49819">腾讯云</a>官方对这两种服务器的的为例：</p><blockquote><p>  对比 <a href="https://cloud.tencent.com/document/product/213/495">云服务器 CVM</a>，轻量应用服务器 TencentCloud Lighthouse 更聚焦于中小企业、开发者、云计算入门者、学生等用户群体。相比云服务器 CVM 更加简单易用，精简了云服务器 CVM 的高阶概念及功能，提供高带宽流量包并以高性价比的套餐形式整体售卖基础云资源，将热门开源软件融合打包实现一键构建应用，更适合于支撑中小型网站、Web 应用、博客、论坛、小程序/小游戏、电商、云盘/图床、云端开发测试和学习环境等轻量级、低负载且访问量适中的应用场景。</p></blockquote><p>国外的有不少专门面对个人 VPS 厂商，而在国内的云服务商中这类产品往往不直接叫 VPS，比如阿里云、腾讯云产品中叫做轻量应用服务器，有的厂商叫经典云服务器（相对的是弹性云服务器）。在购买国内厂商的 VPS 一定要主要和传统的云服务器的区别开，传统的云服务器往往月费价格价格都成百上千，而 VPS 则会便宜不少。</p><h2 id="基本测试"><a href="#基本测试" class="headerlink" title="基本测试"></a>基本测试</h2><p>购买完主机后第一步就应该对主机进行一些基础的测试，第一时间发现可能的问题，比如 IP 被墙无法连接硬件性能和购买页面的宣传指标相差太多。发现异常一定要联系客服退款重开或者更换其他产品，不要等到最后环境搭了半天白忙活一场。</p><ol><li><p>网络连通性测试：首先在本地 ping 远程的主机看是否能够 ping 通，如果不能 ping 通说明该台 VPS 的 IP 地址已经被墙了，就需要退款重开一台新的机器，或者部分云厂商支持直接更换 IP。一般大厂的 VPS 不会新开到 IP 被墙的机子，但是国外的 VPS 厂商 IP 池中有不少都已经被国人给玩坏了，运气差一点就很容易中奖。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping 43.135.29.251<br></code></pre></td></tr></table></figure></li><li><p>硬件性能测试：在服务器控制台直接登录到远程主机，然后运行以下脚本查看 VPS 的 Linux 系统信息，还可以查看服务器配置信息，测试网络带宽及硬盘读写速率你可以</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -qO- bench.sh | bash<br></code></pre></td></tr></table></figure><p>  这是在腾讯轻量应用服务器香港节点 24 元每月套餐得到的结果。可以看到上传速度没有虚标，30 Mbps 的带宽可以跑满，硬盘连续读写 100 多 MB 每秒，虽然购买页面写着是 SSD 硬盘，但是实际也就是机械硬盘的水平，不过也比一些读写个位数的石头硬盘强太多了，考虑到价格完全可以接受。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955475.png" alt="image-20211015111557658"></p><p>  下面是腾讯轻量应用服务器香港节点 34 元每月套餐的测试结果，可以做个对比。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955476.png" alt="1c2g50GB bench"></p></li><li><p>路由测试：很多人最关心 VPS 的去程回程路由走的什么线路，线路确实可以一定程度上决定网络质量，但是和自己的的网络供应商、物理位置也有着很大的关系，可能同一台机子不同人的访问速度截然不同。路由线路只能做参考，自己平日特别是晚上网络高峰期的使用感受更能说明网络质量的好坏，没必要过分追捧 CN2 GIA 线路，当让如果有钱任性请无脑上 GIA。<br>  以下路由测试均是基本的网络环境（湖北武汉，电信校园网）。<br>  去程测试，在本机运行以下命令：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tracert 43.135.29.251<br></code></pre></td></tr></table></figure><p>  去程路由结果：<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955477.png" alt="image-20211015112415667"></p><p>  回程测试，在服务器控制台 WebShell 运行以下命令：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mtr 27.18.195.81 -r<br></code></pre></td></tr></table></figure><p>  上面的 27.18.195.81 地址是本人访问互联网的显示的公网 IP 地址，回程路由结果：<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955478.png" alt="image-20211015113516101"></p><p>  可以看到去程回程都走的是 AS4134，即电信传统的 163 骨干网，没有经过 CN 2 GIA 节点。目前腾讯轻量服务器香港地区的 VPS 据说只有少量机器仍然是 CN 2 GIA 路线了，询问客服得到的回答线路是随机的，猜测可能和开到的 VPS 的 IP 有关。</p><p>  如果关心多地的访问情况可以在 IPIP 上使用 <a href="https://tools.ipip.net/traceroute.php">TraceRoute 工具</a>查看不同地域节点去程线路，运行下面的网络回程测试脚本（需要 root 权限）查看不同地点的回程路线：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl https://raw.githubusercontent.com/zhucaidan/mtr_trace/main/mtr_trace.sh|bash<br></code></pre></td></tr></table></figure><p>  多地回程路由结果：</p><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955479.png" alt="image-20211015152457648"></p></li></ol><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>如果想使用自己注册的域名来访问主机，需要先在 DNS 解析服务商添加解析记录。</p><p><strong>注意：这一步对连接 VPS 不是必须的，即使自己没有域名也可以通过 IP 地址来访问主机。</strong></p><p>此前我的个人域名是注册在 NameSilo 名下，NameSilo 的自带的解析服务要接近一个小时才在国内生效，并且域名管理页面实在是太卡了。而使用 DNSPod 在国内几分钟解析记录就更新生效了，后台管理界面和流畅度也比 NameSilo 好太多。于是决定将将 DNS 域名解析服务从 NameSilo 迁移到腾讯 DNSPod，具体迁移步骤参见腾讯的官方文档： <a href="https://cloud.tencent.com/document/product/302/5518#edit">其他注册商域名修改 DNS</a>。</p><p>迁移之后在 NameSilo 域名管理后台看到的效果：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955480.png" alt="Image"></p><p><strong>注意：域名的管理权和解析权是独立的，可以仅仅把迁移解析权，管理权仍然在原来的注册商。</strong></p><p>进入腾讯 <a href="https://console.cloud.tencent.com/cns">DNS 解析 DNSPod 控制台</a>，添加域名，然后设置解析记录。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955481.png" alt="image-20211015100440630"></p><p>添加一条 @ 类型的解析记录，把自己的域名直接指向 VPS 的 IP 地址。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955483.png" alt="image-20211015115836550"></p><p>过一段时间后，使用 <code>nslookup</code> 命令来看解析记录是否生效。如果十分钟过去还没有生效，尝试使用 <code>ipconfig /flushdns</code> 命令刷新一下本地的 DNS 缓存或者重启路由器。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955484.png" alt="image-20211015115920642"></p><h2 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h2><p>部分 VPS 厂商在新开通服务器时会为 root 用户自动生成了一串随机的密码，可以直接使用 root 用户登录。</p><p>而腾讯云中新开通的轻量应用服务器要先在控制台重置 root 用户的密码才能切换到 root 用户。重置密码需要在关机状态，可以先手动关机或者直接强制关机。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955485.png" alt="image-20211015102234813"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955486.png" alt="image-20211015102715107"></p><p>重置完密码就可以使用 SSH 客户端来登录 VPS 了，Windows 10 自带 SSH 客户端，直接在终端中输入以下命令即可向 VPS 发出登录请求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@kiku.vip<br></code></pre></td></tr></table></figure><p>在第一次连接陌生的 VPS 主机会发出确认提示，输入 yes 然后回车。接着输入自己刚才重置的 root 用户密码即可以 root 用户身份连接上 VPS。关于 SSH 的更多配置可以参考后面的安全设置这一节以及我的另一篇博客<a href="https://kiku.vip/2021/10/14/%E4%BD%BF%E7%94%A8%20SSH%20%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/">使用 SSH 连接远程主机</a>。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955487.png" alt="image-20211015122821186"></p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>下面中的操作都以 CentOS 7.6 为例，如果是 Debian 系列的 Linux 发行版，请将下面命令中的 <code>yum</code> 用 <code>apt-get</code> 替换。如果是较老版本的 CentOS 先安装 wget 工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install wget <br></code></pre></td></tr></table></figure><ol><li><p>更新系统和软件包。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum update -y<br></code></pre></td></tr></table></figure><p>  新开的机器建第一步先将系统内核和软件包更新到最新，环境搭建好后不再轻易更新。在更新完毕清理安装包的时候，清理结束后可能会卡住不会自动退出，直接手动 <code>ctrl + c</code> 结束就好。</p></li><li><p>安装 BBRplus 加速。</p><blockquote><p>  BBR 是 Google 提出的一种新型拥塞控制算法，可以使 Linux 服务器显著地提高吞吐量和减少 TCP 连接的延迟。</p></blockquote><p>  简单理解就是开启 BBR 可以提高机器的网络速度，从 Linux 4.9 版开始，内核就自带了该功能（但是部分发行版需要手动启用 BBR 加速功能）。</p><p>  依次输入以下命令下载并运行一键安装BBR/暴力BBR/魔改BBR/BBRplus/锐速 (Lotserver)四合一的脚本。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;<br>chmod +x tcp.sh<br>./tcp.sh<br></code></pre></td></tr></table></figure><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955488.png" alt="image-20211015134335662"></p><p>  输入 <code>2</code> 回车，安装 BBRplus 内核。BBRplus 是在原版 BBR 基础上的改进版本，加速效果更好。据说 BBR 魔改版和锐速的加速效果更好，但可能存在兼容和稳定性问题，本人也没有具体在测试过。</p><p>  安装成功会提示是否现在重启机器。输入 <code>y</code> 确认现在重启。</p><p>  重启完毕后重新登录 VPS，输入以下命令再次运行该脚本，</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">./<span class="hljs-selector-tag">tcp</span><span class="hljs-selector-class">.sh</span><br></code></pre></td></tr></table></figure><p>  输入 <code>7</code> 回车，提示 BBRplus 启动成功！</p><p>  输入下面的命令查看 brr 内核模块。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsmod | grep bbr<br></code></pre></td></tr></table></figure><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955489.png" alt="image-20211015134842826"></p></li><li><p>安装宝塔 Linux 面板。</p><p>  如果对 Linux 系统不熟悉的，强烈建议装一个可视化图形化面板，大大降低了 Linux 系统的上手难度。无论是装一些常用的软件，修改服务配置，编辑配置文件，查看系统负载情况。都可以直接通过面板操作。当然，还是有些配置必须通过 SSH 登录服务器操作，因此熟悉下常用的 Linux 命令也是很有必要的。   </p><p>  安装宝塔需要确保当前是较为干净的操作系统，VPS 最好此前没有安装过 Apache / Nginx / php / MySQL 等软件，否则很可能产生冲突。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh    <br></code></pre></td></tr></table></figure><p>  安装成功后，末尾给出访问面板的入口地址以及初始的用户名和密码，这些都是随机生成的，也可以之后手动修改。如果忘记了初始的默认账户和密码可以使用下面命令查看。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bt default<br></code></pre></td></tr></table></figure><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955490.png" alt="image-20211015142221381"></p><p>  国内的大部分云产品都默认有安全组，在访问面板前需要去服务器控制台放行宝塔默认的 <code>8888</code> 端口，同样以腾讯云轻量应用服务器为例：</p><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955491.png" alt="image-20211015141122173"></p><p>  放行成功后就可以通过网址来默认入口地址访问宝塔面板了，输入初始的默认账户和密码，同意用户协议就进入了面板主界面。</p><p>  最新的宝塔面板强制用户绑定宝塔账户才能使用，如果不想绑定可以使用运行下面的命令绕过宝塔的登录要求。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;&#123;\&quot;uid\&quot;:1000,\&quot;username\&quot;:\&quot;admin\&quot;,\&quot;serverid\&quot;:1&#125;&quot; &gt; /www/server/panel/data/userInfo.json<br></code></pre></td></tr></table></figure><p>  <strong>注意：因为宝塔面板官方的限制方法也在不断的变更，可能有些绕过登录的方法已经失效，截止 2021.10 使用该方法有效。</strong></p><p>  在左侧的软件商店搜索下载宝塔跑分跑个分看一看。这是在腾讯轻量应用服务器香港节点 24 元每月套餐得到的跑分结果。</p><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955492.png" alt="image-20211015143825173"></p><p>  下面是腾讯轻量应用服务器香港节点 34 元每月套餐的跑分结果，可以做个对比。不过对比也就图一乐，分高也不能说明性能就一定更强，因为都是虚拟出来的资源，也和跑分时宿主服务器上别的虚拟服务器资源抢占情况有关。</p><p>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955493.png" alt="Image"></p></li></ol><h2 id="安全设置"><a href="#安全设置" class="headerlink" title="安全设置"></a>安全设置</h2><h3 id="更改-sshd-默认端口"><a href="#更改-sshd-默认端口" class="headerlink" title="更改 sshd 默认端口"></a>更改 sshd 默认端口</h3><ol><li><p>使用 nano 编辑器打开 SSH 服务端程序 sshd 的配置文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p> 对新手来说 nano 比 vi 编辑器更加友好，常用的操作快捷键都列在最下面，如果没有耐心学习 vi，nano 也是个不错的选择。</p></li><li><p>找到 <code>#Port 22</code> 这一行，将 <code>22</code> 修改成修改成你想替换的端口，建议把它改成一个大于<code>1024</code>小于<code>65535</code>的整数，但是注意不要和其他常用软件的默认端口冲突，例如 MySQL 服务的 <code>3306</code> 端口。<code>#</code> 开头的表示注释，有一些注释代表了 sshd 所采用的默认值。因此改完端口号后别忘了去掉注释符号 <code>#</code>，否则并不会真正生效。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955494.png" alt="image-20211015145006778"></p></li><li><p>   <code>ctrl + o</code> 然后回车确认保存配置文件，<code>ctrl + x</code> 退出 nano 编辑器。</p></li><li><p>重启 SSH 服务端程序使端口生效。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service sshd restart<br></code></pre></td></tr></table></figure></li><li><p>和之前放行宝塔 8888 端口一样，在服务器的控制台防火墙放行 2222端口，除此之外还要在宝塔面板的安全选项卡中放行 2222 端口。因为安装了宝塔后相当于有两层防火墙，一层为腾讯服务器自带的，一层是宝塔中的安全控制。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955495.png" alt="image-20211015145909664"></p></li><li><p>在客户端打开一个新的 SSH 客户端来测试新端口能否连接成功。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@kiku.vip -p 2222<br></code></pre></td></tr></table></figure><p>  <strong>注意：不要直接在原来的终端窗口中测试，使用新端口登录测试成功，确保修改后的端口可用，再关闭原来的已经连接成功的 SSH 客户端，防止和服务器失联。</strong></p></li></ol><h3 id="创建非-root-用户"><a href="#创建非-root-用户" class="headerlink" title="创建非 root 用户"></a>创建非 root 用户</h3><p>直接使用 root 用户进行操作方便是方便，但是 root 用户的权限太大，说不定某些时候就误操作了。建议创建一个普通用户，需要使用 root 权限的再使用 <code>su root</code> 切换 root 用户或者使用 <code>sudo</code> 来赋予某些操作 root 权限。</p><p>下面的命令添加一个普通用户，名为 admin。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adduser admin<br></code></pre></td></tr></table></figure><p>给 admin 用户设置密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">passwd admin<br></code></pre></td></tr></table></figure><p>sudo 工具能够给 admin 的操作临时添加上 root 权限，较新 Linux 发行版已经集成了该工具可以直接使用，如果没有可以使用下面的命令安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install sudo<br></code></pre></td></tr></table></figure><p>输入下面的命令编辑 sudo 的配置文件，让 admin 用户也能拥有 root 权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">visudo<br></code></pre></td></tr></table></figure><p>在配置文件末尾添加 <code>vpsadmin ALL=(ALL:ALL) ALL</code> 或者 <code>vpsadmin ALL=(ALL) NOPASSWD: ALL</code> 然后保存退出，前者每次使用 <code>sudo</code> 需要输入 admin 的密码进行确认，后者不需要输入任何密码。选择哪种取决于你是想要更安全还是更方便。</p><h3 id="禁止-root-登录和密码登录"><a href="#禁止-root-登录和密码登录" class="headerlink" title="禁止 root 登录和密码登录"></a>禁止 root 登录和密码登录</h3><ol><li><p>使用 nano 编辑器打开 SSH 服务端程序 sshd 的配置文件。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>  找到 <code>#PermitRootLogin yes</code> 这一行，然后把它后面的设定值改为 <code>no</code> 并去掉 <code>#</code>，这将会禁止 root 用户通过 SSH 的方式登录。找到 <code>#PasswordAuthentication yes</code> 这一行，同样把它后面的设定值改为 <code>no</code>，并去掉 <code>#</code> 保存退出，将会禁止使用密码登录，只能使用公钥登录。请确保已经正确的配置了公钥，请参考<a href="">使用 SSH 客户端登录远程主机</a>。</p><p>  修改完保存文件退出。</p></li><li><p>重启 SSH 服务端程序使端口生效。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service sshd restart<br></code></pre></td></tr></table></figure></li><li><p>在客户端打开一个新的 SSH 客户端以 root 用户登录。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@kiku.vip -p 2222<br></code></pre></td></tr></table></figure><p>  仍会提示输入密码，但是即使密码输入正确也无法登录成功。</p></li><li><p>可以通过前面创建的 admin 用户登录，之后可以使用 <code>su root</code> 切换到 root 用户。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh admin@kiku.vip -p 2222<br></code></pre></td></tr></table></figure></li></ol><h3 id="更改宝塔的默认设置"><a href="#更改宝塔的默认设置" class="headerlink" title="更改宝塔的默认设置"></a>更改宝塔的默认设置</h3><p>修改宝塔面板的默认端口，也可以在该页面修改宝塔的入口地址和登录账号和密码。修改完端口后务必记得在服务器的控制台防火墙放行新的端口。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955496.png" alt="image-20211015173049867"></p><h2 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h2><p>如果以上都设置成功，建议在当前状态生成一份快照，备份 VPS 当前的状态，之后如果损坏了某些环境又修复不好，就可以直接回滚到快照，而不必重置系统再重新做一遍这些基本设置。</p><p>大多数厂商都在控制台中提供了快照功能，以腾讯云为例，每个 VPS 可以创建两个免费快照。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110191955497.png" alt="image-20211016125916092"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>  <a href="https://blog.laoda.de/archives/how-to-secure-a-linux-server#toc-head-7">保护好你的小鸡！保姆级服务器安全教程！</a></li><li>  <a href="https://blog.laoda.de/archives/vps-choose">VPS服务器选购不完全指南</a></li><li>  <a href="https://blog.laoda.de/archives/666clouds">新拿到手一台服务器，怎么样给它做个全方位的“体检”？</a></li><li>  <a href="https://www.gubo.org/hongkong-cn2-gia-vps/">香港CN2 VPS/香港CN2 GIA VPS及可靠商家介绍推荐</a></li><li>  <a href="https://www.itbulu.com/unbind-btaccount.html">解除宝塔面板绕过强制绑定官网账号几个有效方法</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VPS</tag>
      
      <tag>Linux</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax 与前后端交互</title>
    <link href="/2021/09/08/Ajax/"/>
    <url>/2021/09/08/Ajax/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Ajax-概述"><a href="#Ajax-概述" class="headerlink" title="Ajax 概述"></a>Ajax 概述</h2><p>Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML）。</p><p>简单理解：在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是 Ajax。</p><p>XMLHttpRequest（简称 xhr）是浏览器提供的 JavaScript 成员，如果要在网页中请求服务器上的数据资源，则需要用到 XMLHttpRequest 对象。</p><p>客户端请求服务器时，请求的方式有很多种，最常见的两种请求方式分别为 get 和 post 请求。</p><ul><li>get 请求通常用于获取服务端资源（向服务器要资源），例如：根据 URL 地址，从服务器获取 HTML 文件、CSS 文件、JS 文件、图片文件、数据资源等。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154514.png" alt="image-20210917221919876"></li><li>post 请求通常用于向服务器提交数据（往服务器发送资源），例如：登录注册时向服务器提交的登录信息、向服务器上传文件等各种数据提交操作。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154516.png" alt="image-20210917221943692"></li></ul><p>Ajax 能让我们轻松实现网页与服务器之间的数据交互，Ajax 的典型应用场景：</p><ul><li>  用户名检测：注册用户时，动态检测用户名是否被占用；</li><li>  搜索提示：当输入搜索关键字时，动态加载搜索提示列表；</li><li>  数据分页显示：当点击页码值的时候，不用刷新页面动态刷新表格的数据；</li><li>  数据的增删改查：数据的添加、删除、修改、查询操作。</li></ul><h2 id="jQuery-中的-Ajax"><a href="#jQuery-中的-Ajax" class="headerlink" title="jQuery 中的 Ajax"></a>jQuery 中的 Ajax</h2><p>浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数，极大地降低了 Ajax 的使用难度。</p><p>jQuery 中发起 Ajax 请求最常用的三个方法如下：</p><ul><li><p><code>$.get(url, [data], [callback])</code>：专门用来发起 get 请求，从而将服务器上的资源请求到客户端来进行使用。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154517.png" alt="image-20210917215749095"></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// $.get()发起不带参数的请求</span><br>$.get(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(res) <span class="hljs-comment">// 这里的 res 是服务器返回的数据</span><br>&#125;)<br><br><span class="hljs-comment">// $.get()发起带参数的请求</span><br>$.get(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>, &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(res)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><code>$.post(url, [data], [callback])</code>：专门用来发起 post 请求，从而向服务器提交数据。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154518.png" alt="image-20210917220139328"></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">$.post(<br>   <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbook&#x27;</span>, <span class="hljs-comment">// 请求的URL地址</span><br>   &#123; <span class="hljs-attr">bookname</span>: <span class="hljs-string">&#x27;水浒传&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;施耐庵&#x27;</span>, <span class="hljs-attr">publisher</span>: <span class="hljs-string">&#x27;上海图书出版社&#x27;</span> &#125;, <span class="hljs-comment">// 提交的数据</span><br>   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123; <span class="hljs-comment">// 回调函数</span><br>      <span class="hljs-built_in">console</span>.log(res)<br>   &#125;<br>)<br></code></pre></td></tr></table></figure></li><li><p>  <code>$.ajax(settings)</code>：<code>$.get()</code>, <code>$.post()</code> 的底层实现，它允许我们对 Ajax 请求进行更详细的配置。上传文件只能使用 <code>$.ajax()</code> 不能使用 <code>$.post()</code>，并且必须指定配置对象中的 <code>processData</code> 和 <code>contentType</code> 属性。</p></li><li><pre><code class="js">  $.ajax(&#123;     type: &#39;&#39;, // 请求的方式，例如 GET 或 POST，请求方式可以小写可以大写，推荐大写     url: &#39;&#39;,  // 请求的 URL 地址     data: &#123; &#125;,// 这次请求要携带的数据     success: function(res) &#123; &#125; // 请求成功之后的回调函数  &#125;)  // 使用 $.ajax() 发起 GET 请求  $.ajax(&#123;     type: &#39;GET&#39;, // 请求的方式     url: &#39;http://www.liulongbin.top:3006/api/getbooks&#39;,  // 请求的 URL 地址     data: &#123; id: 1 &#125;,// 这次请求要携带的数据     success: function(res) &#123; // 请求成功之后的回调函数         console.log(res)     &#125;  &#125;)  // 使用 $.ajax() 发起 POST 请求  $.ajax(&#123;     type: &#39;POST&#39;, // 请求的方式     url: &#39;http://www.liulongbin.top:3006/api/addbook&#39;,  // 请求的 URL 地址     data: &#123; // 要提交给服务器的数据        bookname: &#39;水浒传&#39;,        author: &#39;施耐庵&#39;,        publisher: &#39;上海图书出版社&#39;      &#125;,     success: function(res) &#123; // 请求成功之后的回调函数         console.log(res)     &#125;  &#125;)  <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>`<span class="javascript">$(<span class="hljs-built_in">document</span>).ajaxStart()</span>` 和  `<span class="javascript">$(<span class="hljs-built_in">document</span>).ajaxStop()</span>` 函数会监听当前文档内所有的 Ajax 请求，当发出新的 Ajax 请求或 Ajax 请求结束（可能是请求成功或者请求超时失败）会触发相应的回调函数。<br><br>```<span class="javascript">js</span><br><span class="javascript"><span class="hljs-comment">// 自 jQuery 版本 1.8 起，ajaxStart() 和 ajaxStop() 方法只能被附加到文档</span></span><br><span class="javascript">$(<span class="hljs-built_in">document</span>).ajaxStart(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;发出了一个 Ajax 请求&quot;</span>);</span><br><span class="javascript">&#125;)</span><br><br><span class="javascript">$(<span class="hljs-built_in">document</span>).ajaxStop(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Ajax 请求结束&quot;</span>);</span><br><span class="javascript">&#125;)</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h2 id="接口文档规范"><a href="#接口文档规范" class="headerlink" title="接口文档规范"></a>接口文档规范</h2><p>使用 Ajax 请求数据时，被请求的 URL 地址，就叫做数据接口（简称接口）。</p><p>接口文档，顾名思义就是接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对接口 URL，参数以及输出内容的说明，参照接口文档就能方便的知道接口的作用，以及接口如何进行调用。</p><p>接口文档可以包含很多信息，也可以按需进行精简，不过，一个合格的接口文档，应该包含以下 6 项内容，从而为接口的调用提供依据：</p><ol><li>  接口名称：用来标识各个接口的简单说明，如登录接口，获取图书列表接口等。</li><li>  接口 URL：接口的调用地址。</li><li>  调用（请求）方式：接口的调用（请求）方式，如 GET 或 POST。</li><li>  参数格式：接口需要传递的参数，每个参数必须包含参数名称、参数类型否必选、参数说明这4项内容。</li><li>  响应格式：接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容。</li><li>  返回示例（可选）：通过对象的形式，例举服务器返回数据的结构。</li></ol><p>接口文档实例：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154519.png" alt="image-20210917222659894"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154520.png" alt="image-20210917222725164"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154521.png" alt="image-20210917222732127"></p><h2 id="form-表单"><a href="#form-表单" class="headerlink" title="form 表单"></a>form 表单</h2><p>表单在网页中主要负责数据采集功能。HTML 中的 <code>&lt;form&gt;</code> 标签，就是用于采集用户输入的信息。通过 <code>&lt;form&gt;</code> 标签的提交操作，把采集到的信息提交到服务器端进行处理。</p><p><code>&lt;form&gt;</code> 标签中的属性则是用来规定如何把采集到的数据发送到服务器。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154522.png" alt="image-20210918154941942"></p><ul><li>  <code>action</code>：用来规定当提交表单时，向何处发送表单数据。一般来说 <code>action</code> 属性的值应该是后端提供的一个 URL 地址，这个 URL 地址专门负责接收表单提交过来的数据。当 <code>&lt;form&gt;</code> 表单在未指定 <code>action</code> 属性值的情况下，<code>action</code> 的默认值为当前页面的 URL 地址。</li><li><code>target</code>：用来规定在何处打开 <code>action</code> 属性指定的 URL 。<code>target</code> 的默认值是 <code>_self</code>，表示在相同的框架中打开，当提交表单后，当前标签会立即跳转到 <code>action</code> 属性指定的 URL 地址。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154523.png" alt="image-20210918155829957"></li><li>  <code>method</code>：用来规定以何种方式把表单数据提交到服务器。可选值有两个，分别是 <code>get</code> 和 <code>post</code>。<code>method</code> 的默认值为 <code>get</code>，表示以 URL 查询参数形式把表单数据提交到 <code>action</code> 属性指定的 URL 地址。get 方式适合用来提交少量的、简单的数据。post 方式适合用来提交大量的、复杂的、或包含文件上传的数据。实际开发中，<code>&lt;form&gt;</code> 表单的 post 提交方式用的最多，很少用 get。例如登录、注册、添加数据等表单操作，都需要使用 post 方式来提交表单。</li><li>  <code>enctype</code>：用来规定在发送表单数据之前如何对数据进行编码。可选值有三个，<code>enctype</code> 的默认值为 <code>application/x-www-form-urlencoded</code>，表示在发送前编码所有的字符。在涉及到文件上传的操作时，必须将 <code>enctype</code> 的值设置为 <code>multipart/form-data</code>。如果表单的提交不涉及到文件上传操作，则不设置直接使用默认值即可。<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154524.png" alt="image-20210918155938355"></li></ul><p>通过点击表单域中提交按钮，触发表单提交的操作，从而使页面跳转到 action URL 的行为，叫做表单的同步提交。</p><p>同步提交后，整个页面会发生跳转，跳转到 <code>action</code> 属性中所指向的 URL 地址，页面之前的状态和数据会丢失，用户体验很差。</p><p>实际开发中往往表单只负责采集数据，再使用 Ajax 请求将表单中数据提交到服务器，这也叫做表单的异步提交。</p><p>使用 Ajax 提交表单数据有以下几个步骤：</p><ol><li><p>监听表单提交事件，在 jQuery 中，可以使用如下两种方式，监听到表单的提交事件：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#form1&#x27;</span>).submit(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>   alert(<span class="hljs-string">&#x27;监听到了表单的提交事件&#x27;</span>)<br>&#125;)<br><br>$(<span class="hljs-string">&#x27;#form1&#x27;</span>).on(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>   alert(<span class="hljs-string">&#x27;监听到了表单的提交事件&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>阻止表单默认提交行为，当监听到表单的提交事件以后，可以调用事件对象的 <code>event.preventDefault()</code> 函数，来阻止表单的提交和页面的跳转：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#form1&#x27;</span>).submit(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>   <span class="hljs-comment">// 阻止表单的提交和页面的跳转</span><br>   e.preventDefault()<br>&#125;)<br><br>$(<span class="hljs-string">&#x27;#form1&#x27;</span>).on(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>   <span class="hljs-comment">// 阻止表单的提交和页面的跳转</span><br>   e.preventDefault()<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>获取表单中的数据，通过 DOM 操作获取表单域 <code>&lt;input&gt;</code> 元素的值。在 jQuery 中使用 <code>serialize()</code> 函数，可以一次性获取到表单中的所有的数据，简化表单中数据的获取操作。<br>  <strong>注意：使用 <code>serialize()</code> 函数快速获取表单数据时，必须为每个表单元素添加 <code>name</code> 属性！</strong></p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zhangsan&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">&#x27;#form1&#x27;</span>).serialize());<span class="hljs-comment">// username=zhangsan&amp;password=123456</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art-template 模板引擎"></a>art-template 模板引擎</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>以往我们要通过字符串拼接或者 ES6 中的模板字符串将数据嵌套到 HTML 结构字符串中，然后根据得到的新字符串创建新的元素节点插入到 DOM 中，来动态添加新元素。</p><p>如果元素结构比较复杂，则拼接字符串的时候需要格外注意引号之间的嵌套。且一旦需求发生变化，修改起来也非常麻烦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;爱好：<br>    &lt;ul id=<span class="hljs-string">&quot;hobby&quot;</span>&gt;<br>        &lt;li&gt;爱好<span class="hljs-number">1</span>&lt;/li&gt;<br>        &lt;li&gt;爱好<span class="hljs-number">2</span>&lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    <span class="hljs-keyword">var</span> data = &#123;<br>        hobby: [<span class="hljs-string">&#x27;吃饭&#x27;</span>, <span class="hljs-string">&#x27;睡觉&#x27;</span>, <span class="hljs-string">&#x27;打豆豆&#x27;</span>]<br>    &#125;<br>    <span class="hljs-keyword">var</span> rows = [];<br>    <span class="hljs-comment">// 循环拼接字符串</span><br>    $.each(data.hobby, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i, item</span>) </span>&#123;<br>        rows.push(<span class="hljs-string">&#x27;&lt;li&gt;&#x27;</span> + item + <span class="hljs-string">&#x27;&lt;/li&gt;&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-comment">// 将字符串数组转换为一个长的字符串让后渲染到页面</span><br>    $(<span class="hljs-string">&#x27;#hobby&#x27;</span>).html(rows.join(<span class="hljs-string">&#x27;&#x27;</span>)); <span class="hljs-comment">// $(&#x27;#hobby&#x27;).empty().append(rows.join(&#x27;&#x27;));</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>而模板引擎可以根据程序员指定的模板结构和数据，自动生成一个完整的 HTML 页面（片段）。使用模板引擎减少了字符串的拼接操作，使代码结构更清晰，更易于阅读与维护。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154525.png" alt="image-20210919155101947"></p><p><a href="http://aui.github.io/art-template/zh-cn/">art-template</a> 是一个简约、超快的模板引擎。中文官网首页为 <a href="http://aui.github.io/art-template/zh-cn/index.html">http://aui.github.io/art-template/zh-cn/index.html</a></p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li><p>导入 art-template：从<a href="http://aui.github.io/art-template/zh-cn/docs/installation.html">官网</a>将 <code>template-web.js</code> 下载到本地或者直接引入 CDN 上的脚本文件。导入脚本后就可以在全局中使用 <code>template()</code> 函数。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;https://unpkg.com/art-template@4.13.2/lib/template-web.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>定义模板：在 <code>&lt;script&gt;</code> 标签中，定义模板的 HTML 结构，HTML 结构里面可以根据 art-template 的语法嵌入各种占位符。 <code>&lt;script&gt;</code> 标签 <code>type</code> 属性的默认值为 <code>text/javascript</code>，所以一定要显示指定 <code>type</code> 属性的值为 <code>text/html</code>，否则其中的 HTML 片段会被当成 JavaScript 代码执行。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/html&quot;</span> id=<span class="hljs-string">&quot;tpl-hobby&quot;</span>&gt;<br>    &lt;ul id=<span class="hljs-string">&quot;hobby&quot;</span>&gt;<br>        &lt;li&gt;&#123;&#123;hobby[<span class="hljs-number">0</span>]&#125;&#125;&lt;/li&gt;<br>        &lt;li&gt;&#123;&#123;hobby[<span class="hljs-number">1</span>]&#125;&#125;&lt;/li&gt;<br>        &lt;li&gt;&#123;&#123;hobby[<span class="hljs-number">2</span>]&#125;&#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>  准备要渲染的数据。</p></li><li><p>  调用 <code>template(templateID, data)</code> 函数生成 HTML 结构字符串，<code>templateID</code> 是模板的 ID 属性值，<code>data</code> 是需要渲染的数据对象，返回经过模板引擎处理后的 HTML 结构字符串。</p></li><li><p>  通过 DOM 操作将 HTML 结构字符串渲染到页面上。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;<br>    &lt;meta http-equiv=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> content=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;!-- <span class="hljs-number">1.</span>导入 art-template --&gt;<br>    &lt;script src=<span class="hljs-string">&quot;./template-web.js&quot;</span>&gt;&lt;/script&gt;<br>    &lt;script src=<span class="hljs-string">&quot;./jquery-3.6.0.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div&gt;爱好：<br>    &lt;/div&gt;<br>    &lt;!-- <span class="hljs-number">2.</span>定义模板 --&gt;<br>    &lt;script type=<span class="hljs-string">&quot;text/html&quot;</span> id=<span class="hljs-string">&quot;tpl-hobby&quot;</span>&gt;<br>        &lt;ul id=<span class="hljs-string">&quot;hobby&quot;</span>&gt;<br>            &lt;li&gt;&#123;&#123;hobby[<span class="hljs-number">0</span>]&#125;&#125;&lt;/li&gt;<br>            &lt;li&gt;&#123;&#123;hobby[<span class="hljs-number">1</span>]&#125;&#125;&lt;/li&gt;<br>            &lt;li&gt;&#123;&#123;hobby[<span class="hljs-number">2</span>]&#125;&#125;&lt;/li&gt;<br>        &lt;/ul&gt;<br>    &lt;/script&gt;<br>    &lt;script&gt;<br>        <span class="hljs-comment">// 3.准备数据</span><br>        <span class="hljs-keyword">var</span> data = &#123;<br>            hobby: [<span class="hljs-string">&#x27;吃饭&#x27;</span>, <span class="hljs-string">&#x27;睡觉&#x27;</span>, <span class="hljs-string">&#x27;打豆豆&#x27;</span>]<br>        &#125;;<br>        <span class="hljs-comment">// 4.调用 `template(templateID, data)` 函数生成 HTML 结构字符串</span><br>        <span class="hljs-keyword">var</span> htmlStr = template(<span class="hljs-string">&quot;tpl-hobby&quot;</span>, data);<br>        <span class="hljs-comment">// 5.通过 DOM 操作将 HTML 结构字符串渲染到页面上。</span><br>        $(<span class="hljs-string">&#x27;div&#x27;</span>).append(htmlStr);<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="标准语法"><a href="#标准语法" class="headerlink" title="标准语法"></a>标准语法</h3><p>在模板的两个大括号内可以进行变量输出，或循环数组等基基础操作，这种 <code>&#123;&#123; &#125;&#125;</code> 语法在 art-template 中被称为标准语法。</p><ul><li><p>基本输出：变量的输出、对象属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;value&#125;&#125;<br>&#123;&#123;obj.key&#125;&#125;<br>&#123;&#123;obj[&#x27;key&#x27;]&#125;&#125;<br>&#123;&#123;a ? b : c&#125;&#125;<br>&#123;&#123;a || b&#125;&#125;<br>&#123;&#123;a + b&#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>原文输出：如果要输出的变量值中，包含了 HTML 标签结构，则需要使用原文输出语法，才能保证 HTML 标签被正常渲染。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;@ value &#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>条件输出：使用 if … else if … /if 对变量的值进行判断，按需输出。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;if conditionExpression&#125;&#125; 按需输出的内容 &#123;&#123;/if&#125;&#125;<br><br>&#123;&#123;if exp1&#125;&#125; 按需输出的内容 &#123;&#123;else if exp2&#125;&#125; 按需输出的内容 &#123;&#123;/if&#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>循环输出：通过 each 语法循环数组，当前循环的索引使用 <code>$index</code> 进行访问，当前的循环项使用 <code>$value</code> 进行访问。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;each arr&#125;&#125;<br>    &#123;&#123;$index&#125;&#125;<br>&#123;&#123;$value&#125;&#125;<br>&#123;&#123;/each&#125;&#125;  <br></code></pre></td></tr></table></figure><p>  在前面使用步骤的举例的模板就可以使用 each 循环语法：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/html&quot;</span> id=<span class="hljs-string">&quot;tpl-hobby&quot;</span>&gt;<br>    &lt;ul id=<span class="hljs-string">&quot;hobby&quot;</span>&gt;<br>        &#123;&#123;each hobby&#125;&#125;<br>        &lt;li&gt;&#123;&#123;$value&#125;&#125;&lt;/li&gt;<br>        &#123;&#123;/each&#125;&#125;<br>    &lt;/ul&gt;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>过滤器：过滤器语法使用管道操作符将变量和多个过滤器连接起来，它的上一个输出作为下一个输入，最后一个函数的返回值才是最终的结果。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123;value | filterName1 | filterName2&#125;&#125;<br></code></pre></td></tr></table></figure><p>  过滤器本质就是一个处理函数，将原始输入经过一系列处理后再输出。只有使用如下语法定义的函数对象才能在模板中被使用。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">template.defaults.imports.filterName1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;<br>    <span class="hljs-comment">/* 将原始输入经过一系列处理 */</span><br>    <br>    <span class="hljs-comment">/*return处理的结果*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  例如定义一个格式化时间的过滤器 dateFormat 如下：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">template.defaults.imports.dateFormat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">date</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> y = date.getFullYear()<br>    <span class="hljs-keyword">var</span> m = date.getMonth() + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> d = date.getDate()<br><br>    <span class="hljs-keyword">return</span> y + <span class="hljs-string">&#x27;-&#x27;</span> + m + <span class="hljs-string">&#x27;-&#x27;</span> + d <span class="hljs-comment">// 注意，过滤器最后一定要 return 一个值</span><br> &#125;<br></code></pre></td></tr></table></figure><p>  在模板中就可以使用这个格式化时间的过滤器：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/html&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tpl-demo&quot;</span>&gt;</span><br><span class="handlebars"><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>注册时间：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">regTime</span> | dateFormat&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="模板引擎实现原理"><a href="#模板引擎实现原理" class="headerlink" title="模板引擎实现原理"></a>模板引擎实现原理</h3><p>模板引擎的主要功能就是用正则表达式和字符串替换操作来实现的。</p><p>正则表达式对象的 <code>exec()</code> 函数用于检索传入的字符串中和该正则表达式的匹配情况。如果匹配成功，则返回一个数组（但是包含额外的属性 <code>index</code> 和 <code>input</code>），里面有匹配结果的相关信息，否则返回 <code>null</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/o/</span><br><span class="hljs-comment">// [&quot;o&quot;, index: 4, input: &quot;hello&quot;, groups: undefined]</span><br><span class="hljs-built_in">console</span>.log(pattern.exec(str)) <br></code></pre></td></tr></table></figure><p>正则表达式中小括号包起来的内容表示一个分组，分组会单独提取成为匹配结果伪数组中一个元素。</p><p>伪数组中第一个元素为该正则表达式所匹配到的完整字符串，后面的元素为小括号分组匹配到的子字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&lt;div&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/div&gt;&#x27;</span><br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/&#123;&#123;([a-zA-Z]+)&#125;&#125;/</span><br><span class="hljs-keyword">var</span> patternResult = pattern.exec(str)<br><span class="hljs-built_in">console</span>.log(patternResult) <span class="hljs-comment">// [&#x27;&#123;&#123;name&#125;&#125;&#x27;, &#x27;name&#x27;, index: 7, input: input: &#x27;&lt;div&gt;姓名：&#123;&#123;namea&#125;&#125;&lt;/div&gt;&#x27;,groups: undefined]</span><br>str = str.replace(patternResult[<span class="hljs-number">0</span>], patternResult[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 使用 `replace()` 进行字符串替换</span><br><span class="hljs-built_in">console</span>.log(str); <span class="hljs-comment">// &lt;div&gt;姓名：name&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><p>使用循环匹配替换所有的占位符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123;name&#125;&#125;今年&#123;&#123; age &#125;&#125;岁了&lt;/div&gt;&#x27;</span>;<br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/&#123;&#123;\s*([a-zA-Z]+)\s*&#125;&#125;/</span>;<span class="hljs-comment">// 使用 \s 修剪两端的空格</span><br><span class="hljs-keyword">var</span> patternResult = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 所有都匹配结束，patternResult 为 null 结束循环</span><br><span class="hljs-keyword">while</span>(patternResult = pattern.exec(str)) &#123;<br>   str = str.replace(patternResult[<span class="hljs-number">0</span>], patternResult[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-built_in">console</span>.log(str) <span class="hljs-comment">// &lt;div&gt;name今年age岁了&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><p>将 <code>replace()</code> 函数的第二个参数换成真正想要替换的对象中的属性值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123;name&#125;&#125;今年&#123;&#123; age &#125;&#125;岁了&lt;/div&gt;&#x27;</span>;<br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/&#123;&#123;\s*([a-zA-Z]+)\s*&#125;&#125;/</span>;<br><span class="hljs-keyword">var</span> patternResult = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span> ((patternResult = pattern.exec(str))) &#123;<br>   str = str.replace(patternResult[<span class="hljs-number">0</span>], data[patternResult[<span class="hljs-number">1</span>]]);<br>&#125;<br><span class="hljs-built_in">console</span>.log(str);<br></code></pre></td></tr></table></figure><p>实现简易的模板引擎：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user-box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 定义模板结构 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/html&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tpl-user&quot;</span>&gt;</span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>姓名：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>年龄：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">age</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>性别：</span><span class="hljs-template-variable">&#123;&#123;  <span class="hljs-name">gender</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>住址：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">address</span>  &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-comment">// 封装的 template 函数</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">template</span>(<span class="hljs-params">id, data</span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> str = <span class="hljs-built_in">document</span>.getElementById(id).innerHTML</span><br><span class="handlebars"><span class="xml">            var pattern = /</span><span class="hljs-template-variable">&#123;&#123;\<span class="hljs-name">s</span>*(<span class="hljs-name">[a-zA-Z]</span>+)\s*&#125;&#125;</span><span class="xml">/</span></span><br><span class="javascript">            <span class="hljs-keyword">var</span> pattResult = <span class="hljs-literal">null</span></span><br><span class="javascript">            <span class="hljs-keyword">while</span> ((pattResult = pattern.exec(str))) &#123;</span><br>                str = str.replace(pattResult[0], data[pattResult[1]])<br>            &#125;<br><span class="javascript">            <span class="hljs-keyword">return</span> str</span><br>        &#125;<br><span class="javascript">        <span class="hljs-comment">// 定义数据</span></span><br><span class="javascript">        <span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;北京顺义马坡&#x27;</span> &#125;</span><br><span class="javascript">        <span class="hljs-comment">// 调用模板函数</span></span><br><span class="javascript">        <span class="hljs-keyword">var</span> htmlStr = template(<span class="hljs-string">&#x27;tpl-user&#x27;</span>, data)</span><br><span class="javascript">        <span class="hljs-comment">// 渲染 HTM L结构</span></span><br><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;user-box&#x27;</span>).innerHTML = htmlStr</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Ajax-加强"><a href="#Ajax-加强" class="headerlink" title="Ajax 加强"></a>Ajax 加强</h2><h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><p><code>XMLHttpRequest</code>（简称 xhr）是浏览器预置的 JavaScript 成员，通过它可以请求服务器上的数据资源。jQuery 中的 Ajax 相关的函数，就是基于 xhr 对象封装出来的。</p><p>使用 xhr 发起 GET 请求的步骤：</p><ol><li>  创建 <code>XMLHttpRequest</code> 对象；</li><li>  调用 xhr 对象的<code>open()</code> 函数；</li><li>  调用 xhr 对象的 <code>send()</code> 函数；</li><li>  监听 xhr 对象的<code>onreadystatechange</code> 事件，请求完成时对响应对处理。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建 XHR 对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br><span class="hljs-comment">// 2. 调用 open 函数，指定 请求方式 与 URL地址</span><br>xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>)<br><span class="hljs-comment">// 3. 调用 send 函数，发起 Ajax 请求</span><br>xhr.send()<br><span class="hljs-comment">// 4. 监听 onreadystatechange 事件</span><br>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 4.1 监听 xhr 对象的请求状态 readyState ；与服务器响应的状态 status</span><br>    <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-comment">// 4.2 打印服务器响应回来的数据</span><br>        <span class="hljs-built_in">console</span>.log(xhr.responseText)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 xhr 发起 POST请求的步骤：</p><ol><li>  创建 <code>XMLHttpRequest</code> 对象；</li><li>  调用 xhr 对象的<code>open()</code> 函数；</li><li>  设置 xhr 对象的 <code>Content-Type</code> 属性，application/x-www-form-urlencoded</li><li>  调用 xhr 对象的 <code>send()</code> 函数，同时指定要发送的数据；</li><li>  监听 xhr 对象的<code>onreadystatechange</code> 事件，请求完成时对响应对处理。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建 xhr 对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br><span class="hljs-comment">// 2. 调用 open()</span><br>xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbook&#x27;</span>)<br><span class="hljs-comment">// 3. 设置 Content-Type 属性（固定写法）</span><br>xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>)<br><span class="hljs-comment">// 4. 调用 send()，同时将数据以查询字符串的形式，提交给服务器</span><br>xhr.send(<span class="hljs-string">&#x27;bookname=水浒传&amp;author=施耐庵&amp;publisher=天津图书出版社&#x27;</span>)<br><span class="hljs-comment">// 5. 监听 onreadystatechange 事件</span><br>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(xhr.responseText)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 xhr 发起 POST 请求的步骤和发起 GET 请求的步骤大致一样，区别是在调用 <code>open()</code> 函数时请求方式改为 ‘POST’，在调用 <code>send()</code> 函数之前需要设置 <code>Content-Type</code> 属性。</p><p><code>XMLHttpRequest</code> 对象的 <code>readyState</code> 属性，用来表示当前 Ajax 请求所处的状态。每个 Ajax 请求必然处于以下状态中的一个：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154526.png" alt="image-20210919225529979"></p><h3 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h3><p>查询字符串（Query String）是指在 URL 地址末尾加上的用于向服务器发送参数信息的字符串，也叫 URL 参数。<br>查询字符串的格式：将英文的 <code>?</code> 放在 URL 中请求路径的末尾，传递的参数信息用 <code>=</code> 连接成键值对，如果有多个参数的话，使用 <code>&amp;</code> 符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到 URL 中。</p><p>下面 URL 最后面的 <code>?wd=JavaScript&amp;ie=UTF-8</code> 就是查询字符串。<strong>注意：查询字符串不包括 <code>#</code> 后面的锚点信息。</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.baidu.com/s?wd=JavaScript&amp;ie=UTF-<span class="hljs-number">8</span><span class="hljs-comment">#11</span><br></code></pre></td></tr></table></figure><p>使用 xhr 对象发起带参数的 GET 请求时，只需在调用 <code>open()</code> 函数时在 URL 地址后面按照格式拼接上参数即可。</p><p>jQuery 中使用 <code>$.ajax()</code> 和  <code>$.get()</code> 发起带参数的 GET 请求，可以使用对象来传递参数信息。但本质上，都是直接将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">$.get(<span class="hljs-string">&#x27;url&#x27;</span>, &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;)<br><span class="hljs-comment">// 等价于</span><br>$.get(<span class="hljs-string">&#x27;url?name=zs&amp;age=20&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;)<br><br>$.ajax(&#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-attr">data</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;, <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125; &#125;)<br><span class="hljs-comment">// 等价于</span><br>$.ajax(&#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;url?name=zs&amp;age=20&#x27;</span>, <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125; &#125;)<br></code></pre></td></tr></table></figure><h3 id="JSON-数据交换格式"><a href="#JSON-数据交换格式" class="headerlink" title="JSON 数据交换格式"></a>JSON 数据交换格式</h3><p>数据交换格式，就是服务器端（后端）与客户端（前端）之间进行数据传输与交换的格式。</p><p>比较流行的两种数据交换格式分别是 XML 和 JSON。其中 XML 因为格式臃肿，传输效率低和解析不方便，已经很少在数据传输上被使用了，更多用在服务端的配置文件上。而 JSON 是在 2001 年开始被推广和使用的数据格式，到现今为止，JSON 已经成为了主流的数据交换格式。因此重点要学习的数据交换格式就是 JSON。</p><p>JSON 是一种轻量级的文本数据交换格式，在作用上类似于 XML，专门用于存储和传输数据，但是 JSON 比 XML 更小、更快、更易解析。</p><p>概念：JSON 的英文全称是 JavaScript Object Notation，即 JavaScript 对象表示法。准确来说是 Javascript 对象和数组的字符串表示法，它使用文本（即一个长的字符串）表示一个 JavaScript 对象或数组的信息，JSON 的本是一个字符串。</p><p>JSON 中只包含对象和数组两种结构，JSON 的最外层必须是对象或数组格式。通过这两种结构的相互嵌套，可以表示各种复杂的数据结构。</p><ul><li><p>对象结构：对象结构在 JSON 中表示为花括号括起来的形如 { key: value, key: value, … } 键值对结构。其中，key 必须是使用英文的双引号包裹的字符串，value 的数据类型只能是数字、字符串、布尔值、null、数组、对象这 6 种类型。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;zs&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-string">&quot;gender&quot;</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>    <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;hobby&quot;</span>: [<span class="hljs-string">&quot;吃饭&quot;</span>, <span class="hljs-string">&quot;睡觉&quot;</span>, <span class="hljs-string">&quot;打豆豆&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>数组结构：数组结构在 JSON 中表示为方括号括起来的形如 [ “javascript”, 30, true … ] 有序列表结构 。数组中数据的类型只能是数字、字符串、布尔值、null、数组、对象这 6 种类型。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[ <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;php&quot;</span> ]<br>[ <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300.5</span> ]<br>[ <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span> ]<br>[ &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;zs&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>&#125;, &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">30</span>&#125; ]<br>[ [ <span class="hljs-string">&quot;苹果&quot;</span>, <span class="hljs-string">&quot;榴莲&quot;</span>, <span class="hljs-string">&quot;椰子&quot;</span> ], [ <span class="hljs-number">4</span>, <span class="hljs-number">50</span>, <span class="hljs-number">5</span> ] ]<br></code></pre></td></tr></table></figure></li></ul><p>JSON 语法和 JavaScript 中的对象声明和数组声明很像，但不是严格意义上的 JavaScript 子集。典型区别如下：</p><ol><li>  字符串类型的值必须使用双引号包裹，不允许使用单引号表示字符串。</li><li>  JSON 对象结构中 key 必须是字符串，即被双引号包裹，而 JavaScript 中对象属性名可以使用单引号，甚至省略引号。</li><li>  JSON 对象结构中 value 不能为 undefined，表示值为空应该使用 null。</li><li>  JSON 对象结构中 value 不能为函数对象。</li><li>  JSON 规范中使用逗号分割相邻的元素，但是最后一个元素的末尾不能有多余的逗号。</li><li>  JSON 规范不允许加注释，防止过多的注释，影响了文件本身的数据载体的目的，因为 JSON 本意就是让程序来处理的，而不是让人类去读的。<a href="https://json5.org/">JSON5</a>（JSON for Humans） 在 JSON 规范的基础上做了一些拓展，允许使用单行和多行注释。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;gender&quot;</span>: &#x27;男&#x27;,   <span class="hljs-comment">// 违反上面第 1 条</span><br>    name: &quot;zs&quot;,// 违反上面第 2 条<br>    &#x27;age&#x27;: 20,// 违反上面第 2 条<br>    &quot;address&quot;: undefined,// 违反上面第 3 条<br>    say: function() &#123;&#125;,// 违反上面第 4 条<br>    &quot;hobby&quot;: [&quot;吃饭&quot;, &quot;睡觉&quot;, &#x27;打豆豆&#x27;],// 违反上面第 5 条<br>&#125;<br></code></pre></td></tr></table></figure><p>JSON 字符串可以和 JavaScript 对象（包括数组）相互转换。</p><p>把字符串转换为数据对象的过程，叫做反序列化，使用 <code>JSON.parse()</code> 方法从 JSON 字符串转换为 JavaScript 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(obj);<span class="hljs-comment">// &#123; a: &#x27;Hello&#x27;, b: &#x27;World&#x27; &#125;</span><br></code></pre></td></tr></table></figure><p>把数据对象转换为字符串的过程，叫做序列化，使用 <code>JSON.stringify()</code> 方法从 JavaScript 对象转换为 JSON 字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> json = <span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;World&#x27;</span> &#125;)<br><span class="hljs-built_in">console</span>.log(json);<span class="hljs-comment">// &#123;&quot;a&quot;:&quot;Hello&quot;,&quot;b&quot;:&quot;World&quot;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="XMLHttpRequest-Level2-的新特性"><a href="#XMLHttpRequest-Level2-的新特性" class="headerlink" title="XMLHttpRequest Level2 的新特性"></a>XMLHttpRequest Level2 的新特性</h3><p>在很早之前 <code>XMLHttpRequest</code> 对象只支持文本数据的传输，无法用来读取和上传文件，并且传送和接收数据时，没有进度信息，只能监听请求有没有完成。<br>XMLHttpRequest Level2 赋予了 <code>XMLHttpRequest</code> 对象新的特性：</p><ol><li><p>可以设置 Ajax 请求的时限：Ajax 操作时间受网络环境影响，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的 <code>XMLHttpRequest</code> 对象，增加了 <code>timeout</code> 属性，可以设置 HTTP 请求的时限，过了这个时限，就自动停止 Ajax 请求。与之配套的还有一个 <code>timeout</code> 事件，用来指定超时发生时的回调函数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.timeout = <span class="hljs-number">3000</span>;<br>xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;<br>    alert(<span class="hljs-string">&#x27;请求超时！&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>新增了一个 <code>FormData</code> 对象，方便表单处理。可以根据表单元素创建一个 <code>FormData</code> 对象，会自动将表单中的数据填充到 <code>FormData</code> 对象中：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取表单元素</span><br><span class="hljs-keyword">var</span> form = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#form1&#x27;</span>)<br><span class="hljs-comment">// 监听表单元素的 submit 事件</span><br>form.addEventListener(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    e.preventDefault()<br>    <span class="hljs-comment">// 根据 form 表单创建 FormData 对象，会自动将表单数据填充到 FormData 对象中</span><br>    <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> FormData(form)<br>    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br>    xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/formdata&#x27;</span>)<br>    xhr.send(fd)<br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>  也可以使用该对象来模拟表单的提交操作：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 新建 FormData 对象</span><br><span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> FormData()<br><span class="hljs-comment">// 2. 为 FormData 添加表单项</span><br>fd.append(<span class="hljs-string">&#x27;uname&#x27;</span>, <span class="hljs-string">&#x27;zs&#x27;</span>)<br>fd.append(<span class="hljs-string">&#x27;upwd&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)<br><span class="hljs-comment">// 3. 创建 XHR 对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br><span class="hljs-comment">// 4. 指定请求类型与URL地址</span><br>xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/formdata&#x27;</span>)<br><span class="hljs-comment">// 5. 直接提交 FormData 对象，这与提交网页表单的效果，完全一样</span><br>xhr.send(fd)<br></code></pre></td></tr></table></figure><p>  将文件对象追加到 <code>FormData</code> 对象中，就可以上传指定文件：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> files = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#file1&#x27;</span>).files;<br><span class="hljs-keyword">if</span> (files.length &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> alert(<span class="hljs-string">&#x27;请选择要上传的文件！&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 1. 创建 FormData 对象</span><br><span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> FormData()<br><span class="hljs-comment">// 2. 向 FormData 中追加文件</span><br>fd.append(<span class="hljs-string">&#x27;avatar&#x27;</span>, files[<span class="hljs-number">0</span>])<br><span class="hljs-comment">// 3 创建 xhr 对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br><span class="hljs-comment">// 4. 调用 open 函数，指定请求类型与URL地址。其中，请求类型必须为 POST</span><br>xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;</span>)<br><span class="hljs-comment">// 5. 发起请求</span><br>xhr.send(fd)<br></code></pre></td></tr></table></figure><p>  使用 jQuery 配合 <code>FormData</code> 对象发起上传文件的请求时，不能对数据进行编码，必须指定 <code>contentType</code> 和 <code>processData</code> 的属性值为 <code>false</code>：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建 FormData 对象</span><br><span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> FormData()<br><span class="hljs-comment">// 2. 向 FormData 中追加文件</span><br>fd.append(<span class="hljs-string">&#x27;avatar&#x27;</span>, files[<span class="hljs-number">0</span>])<br><br>$.ajax(&#123;<br>    method: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    url: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;</span>,<br>    data: fd,<br>    <span class="hljs-comment">// 不修改 Content-Type 属性，使用 FormData 默认的 Content-Type 值</span><br>    contentType: <span class="hljs-literal">false</span>,<br>    <span class="hljs-comment">// 不对 FormData 中的数据进行 url 编码，而是将 FormData 数据原样发送到服务器</span><br>    processData: <span class="hljs-literal">false</span>,<br>    success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(res)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>可以通过监听 <code>xhr.upload.onprogress</code> 事件，可以获取文件上传的进度信息：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建 XHR 对象</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br><span class="hljs-comment">// 监听 xhr.upload 的 onprogress 事件</span><br>xhr.upload.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-comment">// e.lengthComputable 是一个布尔值，表示当前上传的资源是否具有可计算的长度</span><br>    <span class="hljs-keyword">if</span> (e.lengthComputable) &#123;<br>        <span class="hljs-comment">// e.loaded 已传输的字节，e.total 需传输的总字节，相除即得传输进度百分比</span><br>        <span class="hljs-keyword">var</span> percentComplete = <span class="hljs-built_in">Math</span>.ceil((e.loaded / e.total) * <span class="hljs-number">100</span>)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios 是专注于网络数据请求的库。相比于原生的 XMLHttpRequest 对象，Axios 简单易用。相比于 jQuery，Axios 更加轻量化，只专注于网络数据请求。</p><p>导入 Axios：将 <code>axios.min.js</code> 下载到本地或者直接引入 CDN 上的脚本文件。导入脚本后就可以在全局中使用 <code>axios</code> 对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 <code>axios</code> 对象发起 get 请求的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 查询参数可以直接拼接在 URL 后面，或者通过参数对象传递 </span><br>axios.get(<span class="hljs-string">&#x27;url&#x27;</span>, &#123; <span class="hljs-attr">params</span>: &#123; <span class="hljs-comment">/*查询参数*/</span> &#125; &#125;).then(callback);<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 请求的 URL 地址</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span><br><span class="hljs-comment">// 请求的参数对象</span><br><span class="hljs-keyword">var</span> paramsObj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;<br><span class="hljs-comment">// 调用 axios.get() 发起 GET 请求</span><br>axios.get(url, &#123; <span class="hljs-attr">params</span>: paramsObj &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-comment">// res.data 是服务器返回的数据</span><br>    <span class="hljs-keyword">var</span> result = res.data<br>    <span class="hljs-built_in">console</span>.log(res)<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用 <code>axios</code> 对象发起 post 请求的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.post(<span class="hljs-string">&#x27;url&#x27;</span>, &#123; <span class="hljs-comment">/*参数*/</span> &#125;).then(callback)<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 请求的 URL 地址</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span><br><span class="hljs-comment">// 要提交到服务器的数据</span><br><span class="hljs-keyword">var</span> dataObj = &#123; <span class="hljs-attr">location</span>: <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;顺义&#x27;</span> &#125;<br><span class="hljs-comment">// 调用 axios.post() 发起 POST 请求</span><br>axios.post(url, dataObj).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-comment">// res.data 是服务器返回的数据</span><br>    <span class="hljs-keyword">var</span> result = res.data<br>    <span class="hljs-built_in">console</span>.log(result)<br>&#125;)<br></code></pre></td></tr></table></figure><p>直接使用 <code>axios()</code> 方法发起请求，类似于 jQuery 中 <code>$.ajax()</code> 的传入一个对象设置请求的相关信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">axios(&#123;<br>    method: <span class="hljs-string">&#x27;请求类型&#x27;</span>,<br>    url: <span class="hljs-string">&#x27;请求的URL地址&#x27;</span>,<br>    data: &#123; <span class="hljs-comment">/* POST数据 */</span> &#125;,<br>    params: &#123; <span class="hljs-comment">/* GET参数 */</span> &#125;<br>&#125;) .then(callback)<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 axios() 方法发起 get 请求   </span><br>axios(&#123;<br>    method: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>    url: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span>,<br>    params: &#123; <span class="hljs-comment">// GET 参数要通过 params 属性提供</span><br>        name: <span class="hljs-string">&#x27;zs&#x27;</span>,<br>        age: <span class="hljs-number">20</span><br>    &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(res.data)<br>&#125;)<br><br><span class="hljs-comment">// 使用 axios() 方法发起 post 请求  </span><br>axios(&#123;<br>    method: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    url: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span>,<br>    data: &#123; <span class="hljs-comment">// POST 数据要通过 data 属性提供</span><br>        bookname: <span class="hljs-string">&#x27;程序员的自我修养&#x27;</span>,<br>        price: <span class="hljs-number">666</span><br>    &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(res.data)<br>&#125;)<br></code></pre></td></tr></table></figure><p>关于 Axios 库的更多用法参考<a href="https://axios-http.com/zh/docs/intro">官方文档</a>。</p><h2 id="同源策略和跨域"><a href="#同源策略和跨域" class="headerlink" title="同源策略和跨域"></a>同源策略和跨域</h2><p>同源：如果两个页面的协议，域名和端口都相同，则两个页面具有相同的源。例如，下表给出了相对于 <a href="http://www.test.com/index.html">http://www.test.com/index.html</a> 页面的同源检测：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154527.png" alt="image-20210920235252171"></p><p>同源策略（Same origin policy）是浏览器提供的一个安全功能。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><p>通俗的理解：浏览器中 A 网站的 JavaScript 脚本，不允许和非同源的网站 B 之间，进行资源的交互，例如：</p><ul><li>  无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</li><li>  无法接触非同源网页的 DOM</li><li>  无法向非同源地址发送 Ajax 请求</li></ul><p>跨域：非同源的 URL 之间进行资源的交互访问。</p><p>浏览器允许发起跨域网络请求，但是，跨域请求回来的数据，会被浏览器的同源策略给拦截，无法被页面获取到。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154528.png" alt="image-20210921001055021"></p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>实现跨域数据请求，最主要的两种解决方案，分别是 JSONP 和 CORS。</p><ul><li>  JSONP：出现的早，兼容性好（兼容低版本IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。缺点是只支持 GET 请求，不支持 POST 请求。</li><li>  CORS：出现的较晚，它是 W3C 标准，属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器。</li></ul><p>JSONP（JSON with Padding) 是 JSON 的一种使用模式，可用于解决主流浏览器的跨域数据访问的问题。</p><p>由于浏览器同源策略的限制，网页中无法通过 Ajax 向非同源的接口请求数据。但是 <code>&lt;script&gt;</code> 标签不会受浏览器同源策略的影响，即可以请求接收非同源站点的 JavaScript 脚本。</p><p>JSONP 请求的原理：通过 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性，请求跨域的数据接口，接口返回一个函数调用的语句，该函数处理接口响应回来的数据（通常是 JSON）。</p><p>使用 JSONP 发起跨域请求的步骤。 </p><ol><li><p>定义一个成功回调函数，JSONP 请求成功后会自动动调用该函数对响应数据做处理：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">success</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;获取到了data数据：&#x27;</span>)<br>    <span class="hljs-built_in">console</span>.log(data)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>通过 <code>&lt;script&gt;</code> 标签，向接口请求数据，<code>src</code> 属性值即为 GET请求的 URL 地址，查询字符串中除了 GET 请求的相关参数信息，还要指定成功回调函数的名称。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;https://suggest.taobao.com/sug?q=apple&amp;callback=success&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>服务端返回脚本并执行，脚本中就是一行 JavaScript 代码——将服务器响应结果——JSON 对象直接作为实参传入成功回调函数中并调用。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">success(&#123;<br><span class="hljs-string">&quot;result&quot;</span>: [<br>[<br><span class="hljs-string">&quot;applewatch表带&quot;</span>,<br><span class="hljs-string">&quot;9306.792483204854&quot;</span><br>],<br>[<br><span class="hljs-string">&quot;applewatch&quot;</span>,<br><span class="hljs-string">&quot;9106.716268073735&quot;</span><br>],<br>[<br><span class="hljs-string">&quot;applepencil&quot;</span>,<br><span class="hljs-string">&quot;4213.880638420522&quot;</span><br>]<br>],<br><span class="hljs-string">&quot;shop&quot;</span>: <span class="hljs-string">&quot;apple&quot;</span>,<br><span class="hljs-string">&quot;tmall&quot;</span>: <span class="hljs-string">&quot;apple&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><p>由于 JSONP 是通过 <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性，来实现跨域数据获取的，而 <code>&lt;script&gt;</code> 标签只能发出 GET 请求，所以，JSONP 只支持 GET 数据请求，不支持 POST 请求。</p><p>JSONP 请求的 type 类型为 script 类型，本质就是请求了一个脚本文件。</p><blockquote><p>  json是理想的数据交换格式，但没办法跨域直接获取，于是就将json包裹(padding)在一个合法的js语句中作为js文件传过去。这就是json和jsonp的区别，json是想要的东西，jsonp是达到这个目的而普遍采用的一种方法，当然最终获得和处理的还是json。所以说json是目的，jsonp只是手段。json总会用到，而jsonp只有在跨域获取数据才会用到。<br>  ————————————————<br>  版权声明：本文为CSDN博主「一只大海」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>  原文链接：<a href="https://blog.csdn.net/weixin_44392418/article/details/88782809">https://blog.csdn.net/weixin_44392418/article/details/88782809</a></p></blockquote><p>JSONP 没有用到 <code>XMLHttpRequest</code> 这个对象，JSONP 和 Ajax 之间没有任何关系，不能把 JSONP 请求数据的方式叫做 Ajax 请求。</p><p>jQuery 提供的 <code>$.ajax()</code> 函数，除了可以发起真正的 Ajax 数据请求之外，还能够发起 JSONP 数据请求，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">$.ajax(&#123;<br>    url: <span class="hljs-string">&#x27;https://suggest.taobao.com/sug?q=apple&#x27;</span>,<br>    <span class="hljs-comment">// 如果要使用 $.ajax() 发起 JSONP 请求，必须指定 datatype 为 jsonp</span><br>    dataType: <span class="hljs-string">&#x27;jsonp&#x27;</span>,<br>    success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(res)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用 <code>$.ajax()</code> 发起 JSONP 请求时，配置对象的 <code>datatype</code> 属性值必须为 <code>&#39;jsonp&#39;</code>，这样请求就会默认携带一个 callback=jQueryxxx 的参数，会自动拼接在 GET 请求 URL 的查询字符串上，其中 jQueryxxx 是随机生成的成功回调函数名称，和配置对象中的 <code>success</code> 属性指向同一个函数对象。</p><p>有时服务端接口约定的成功回调函数参数名不一定是 <code>callback</code>，也可能是 <code>cb</code>、<code>cbk</code> 等。可以通过修改配置对象 <code>jsonp</code> 和 <code>jsonpCallback</code> 两个属性的来自定义 JSONP 请求中回调函数的参数名和参数值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">jQueryxxx$.ajax(&#123;<br>    url: <span class="hljs-string">&#x27;https://suggest.taobao.com/sug?q=apple&#x27;</span>,<br>    dataType: <span class="hljs-string">&#x27;jsonp&#x27;</span>,<br>    <span class="hljs-comment">// 发送到服务端的参数名称，默认值为 callback</span><br>    jsonp: <span class="hljs-string">&#x27;cb&#x27;</span>,<br>    <span class="hljs-comment">// 自定义的回调函数名称，默认值为 jQueryxxx 格式</span><br>    jsonpCallback: <span class="hljs-string">&#x27;abc&#x27;</span>,<br>    success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(res)<br>    &#125;<br>&#125;)<br><span class="hljs-comment">// 最终 JSONP 发出的 GET 请求的 URL 地址查询字符串为：?q=apple&amp;cb=abc</span><br><span class="hljs-comment">// 默认为 ?q=apple&amp;callback=success</span><br></code></pre></td></tr></table></figure><p>jQuery 中的 JSONP 请求也是通过 <code>&lt;script&gt;</code> 标签实现的，但是jQuery 采用的是动态创建和移除 <code>&lt;script&gt;</code> 标签的方式：在发起 JSONP 请求的时候，动态向 <code>&lt;header&gt;</code>  内部尾部追加一个 <code>&lt;script&gt;</code> 标签，JSONP 请求成功以后，动态从 <code>&lt;header&gt;</code> 中移除刚才追加进去的 <code>&lt;script&gt;</code> 标签。</p><p>跨域的接口请求是否要使用 JSONP 要根据服务端的设定而定，如果在服务器端已经处理好了该接口的跨域问题，那么直接通过普通的 Ajax 请求就可以跨域访问了；如果服务端想让前端来使用 JSONP 的方式来跨域访问，在服务端要提前配置好处理 JSONP 请求的函数，该函数根据 URL 中是否有 callback 参数判断是 JSONP 请求，如果是则将响应数据包裹在调用语句中作为脚本文件返回。当然服务端也有可能对 JSONP 请求不做特殊处理直接返回响应，这样返回的数据会被浏览器给拦截，而无法实现跨域访问。</p><h2 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h2><p>节流（throttle）策略当指事件被触发后，立即执行回调，但在一段时间内该时间不可以被再次触发。可以类比 moba 游戏中英雄释放技能有 CD，一段时间只能释放一次。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154529.png" alt="image-20210922160228397"></p><p>防抖（debounce）策略是当事件被触发后，延迟一段时间后再执行回调，如果在这段时间内事件又被触发，则重新开始计时。可以类比 moba 游戏中英雄释放回城技能有（前摇）等待时间，必须等待计时结束技能才生效，如果前摇被打断只能重新开始计时。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154530.png" alt="image-20210922160214740"></p><p>节流的应用场景</p><ol><li>  鼠标连续点击轮播图切换按钮，只在单位时间内只触发一次或者轮播图动画完成才能切换下一张。</li><li>  鼠标跟随事件不必时刻监听鼠标位置，可以间隔很短的时间监听。</li><li>  懒加载时要监听计算滚动条的位置，但不必每次页面滚动都触发事件，滚动一定距离再触发事件。</li></ol><p>防抖的应用场景：</p><ol><li>  在搜索框输入关键词，只有在停止输入一段时间后才会向服务器发送查询搜索建议的 Ajax 请求，这样可以减少请求次数，节约请求资源。</li><li>  当调整浏览器窗口大小时，resize 事件过于频繁，造成计算过多，此时可以使用防抖，调整完毕后再触发 resize 操作。</li><li>  在文本编辑器实时保存，当无任何更改操作一秒后再进行保存。</li></ol><p>节流和防抖的对比：当事件短时间内被频繁触发时，节流和防抖都能减少事件处理中某些步骤（例如Ajax 请求、DOM 操作）的触发频率，从而节约 CPU 、网络资源，提升性能。</p><p>节流是触发事件就立刻执行操作，但在该周期内后面的触发都会被忽略。防抖是某个周期内只有最后有一次触发事件会真正执行操作，这个周期内的前面的触发都会被忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">var</span> btn1 = $(<span class="hljs-string">&#x27;#button1&#x27;</span>);<br>    <span class="hljs-keyword">var</span> btn2 = $(<span class="hljs-string">&#x27;#button2&#x27;</span>);<br><br>    <span class="hljs-comment">// 定义节流阀开关</span><br>    <span class="hljs-keyword">var</span> timer1 = <span class="hljs-literal">null</span>;<br>    btn1.click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 每次执行操作前先判断节流阀开关状态，如果节流阀为空，表示可以执行操作</span><br>        <span class="hljs-keyword">if</span> (!timer1) &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;点击了节流按钮&quot;</span>);<br>            $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-literal">true</span>);<br>            timer1 = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-comment">// 将节流阀重置为空，下次可以执行操作</span><br>                timer1 = <span class="hljs-literal">null</span>;<br>                $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-literal">false</span>);<br><br>            &#125;, <span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-comment">// 定义防抖开关</span><br>    <span class="hljs-keyword">var</span> timer2 = <span class="hljs-literal">null</span>;<br>    btn2.click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 触发事件时先清空之前的计时器重新计时，一定要用 clearTimeout() 清空计时器而不是赋值 null</span><br>        <span class="hljs-built_in">clearTimeout</span>(timer2);<br>        $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 如果一段时间内没有再次触发事件即可执行操作</span><br>        timer2 = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;点击了防抖按钮&quot;</span>);<br>            $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-literal">false</span>);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>HTTP 协议即超文本传送协议 (HyperText Transfer Protocol) ，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。</p><p>HTTP 协议采用了 请求/响应 的交互模型。客户端要以 HTTP 协议要求的格式把数据提交到服务器。服务器要以 HTTP 协议要求的格式把内容响应给客户端。</p><p>由于 HTTP 协议属于客户端浏览器和服务器之间的通信协议。因此，客户端发起的请求叫做 HTTP 请求，客户端发送到服务器的消息，叫做 HTTP 请求消息；服务器返回的响应叫做 HTTP 响应，服务器响应给客户端的消息，叫做HTTP 响应消息。</p><h3 id="HTTP-请求消息"><a href="#HTTP-请求消息" class="headerlink" title="HTTP 请求消息"></a>HTTP 请求消息</h3><p>HTTP 请求消息又叫做 HTTP 请求报文。HTTP 请求消息由请求行（request line）、请求头部（ header）、空行和请求体 4 个部分组成。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154532.png" alt="image-20210922201015017"></p><ul><li><p>请求行：由请求方式、URL 和 HTTP 协议版本 3 个部分组成，他们之间使用空格隔开。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154533.png" alt="image-20210922201325974"><br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154534.png" alt="image-20210922201331151"></p></li><li><p>请求头部：用来描述客户端的基本信息，从而把客户端相关的信息告知服务器。请求头部由多行键值对组成，每行的键和值之间用英文的冒号分隔。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154535.png" alt="image-20210922201405689"><br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154536.png" alt="image-20210922201509234"><br>  常见的请求头字段说明：<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154537.png" alt="image-20210922201439011"></p></li><li><p>空行：用来分隔请求头部与请求体。最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154538.png" alt="image-20210922201619545"></p></li><li><p>请求体：存放着要通过 POST 方式提交到服务器的数据。<br>  <strong>注意：只有 POST 请求才有请求体，GET 请求没有请求体。</strong></p></li></ul><h3 id="HTTP-响应消息"><a href="#HTTP-响应消息" class="headerlink" title="HTTP 响应消息"></a>HTTP 响应消息</h3><p>HTTP 响应消息又叫作响应报文。HTTP响应消息由状态行、响应头部、空行 和 响应体 4 个部分组成。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154539.png" alt="image-20210922202529814"></p><ul><li>状态行：状态行由 HTTP 协议版本、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154540.png" alt="image-20210922202651567"><br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154541.png" alt="image-20210922202701352"></li><li>响应头部：用来描述服务器的基本信息。响应头部由多行键值对组成，每行的键和值之间用英文的冒号分隔。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154542.png" alt="image-20210922202732801"><br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154543.png" alt="image-20210922202750165"></li><li>空行：用来分隔响应头部与响应体。在最后一个响应头部字段结束之后，会紧跟一个空行，用来通知客户端响应头部至此结束。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154544.png" alt="image-20210922202934241"></li><li>响应体：存放的着服务器响应给客户端的资源内容。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154545.png" alt="image-20210922203009235"></li></ul><h3 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h3><p>HTTP 请求方法，属于 HTTP 协议中的一部分，请求方法的作用是：用来表明要对服务器上的资源执行的操作。最常用的请求方法是 GET 和 POST。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154546.png" alt="image-20210922203453243"></p><h3 id="HTTP-响应状态码"><a href="#HTTP-响应状态码" class="headerlink" title="HTTP 响应状态码"></a>HTTP 响应状态码</h3><p>HTTP 响应状态码（HTTP Status Code），也属于 HTTP 协议的一部分，用来标识响应的状态。响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次 HTTP 请求的结果是成功还是失败。</p><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字用来对状态码进行细分。根据第一位数字可以分为 5 种类型：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154547.png" alt="image-20210922204507100"></p><p>2** 成功相关的响应状态码，表示服务器已成功接收到请求并进行处理。常见的 2** 类型的状态码如下：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154549.png" alt="image-20210922204615484"></p><p>3** 重定向相关的响应状态码，表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的 3** 类型的状态码如下：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154550.png" alt="image-20210922204648894"></p><p>4** 客户端错误相关的响应状态码，表示客户端的请求有非法内容，从而导致这次请求失败。常见的 4** 类型的状态码如下：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154551.png" alt="image-20210922204719068"></p><p>5** 服务端错误相关的响应状态码，表示服务器未能正常处理客户端的请求而出现意外错误。常见的 5** 类型的状态码如下：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192154552.png" alt="image-20210922204752286"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p>  <a href="https://www.bilibili.com/video/BV11N411o7wU">2021黑马前端最新进阶班</a></p></li><li><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON">MDN：JSON</a></p></li><li><p>  <a href="https://www.json.org/json-zh.html">JSON 规范</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>jQuery</tag>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery 快速入门</title>
    <link href="/2021/06/30/jQuery%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/06/30/jQuery%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="jQuery-概述"><a href="#jQuery-概述" class="headerlink" title="jQuery 概述"></a>jQuery 概述</h3><p>jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。</p><p>在这个库中有很多预先定义好的函数，对 JavaScript 中的 DOM 操作、事件处理、动画设计和 Ajax 交互做了优化封装，调用这些函数可以加快开发速度，提高开发效率。</p><h3 id="jQuery-入口函数"><a href="#jQuery-入口函数" class="headerlink" title="jQuery 入口函数"></a>jQuery 入口函数</h3><p>当 DOM 结构渲染完毕（不必等到所有外部资源加载完成）即可执行入口函数里面的内部代码，相当于原生 JavaScript 中的 <code>DOMContentLoaded</code> 事件（原生 JavaScript 中的 load 事件是等页面文档、外部的 JS 文件、CSS 文件、图片加载完毕才执行内部代码）。利用入口函数，在任意位置书写的 JavaScript 代码都可以获取到完整的 DOM 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>... <span class="hljs-comment">// 此处是页面 DOM 加载完成的入口</span><br>&#125;) ;<br>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>... <span class="hljs-comment">// 此处是页面 DOM 加载完成的入口</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="jQuery-的顶级对象"><a href="#jQuery-的顶级对象" class="headerlink" title="jQuery 的顶级对象 $"></a>jQuery 的顶级对象 $</h3><p><code>$</code> 是 jQuery 的别称，在代码中可以使用 jQuery 代替 <code>$</code>，但一般为了方便，通常都直接使用 <code>$</code>，<code>$</code> 是 jQuery 的顶级对象， 地位相当于原生 JavaScript 中的 <code>window</code>。</p><p>利用原生 JavaScript （<code>getElementById()</code>、<code>querySelector()</code> 等）获取到的对象就是 DOM 对象。</p><p>利用 <code>$(&#39;selector&#39;)</code> 获取的元素就是 jQuery 对象（集合），本质是一个伪数组集合，其中存储了选择符匹配到的所有 DOM 对象。</p><p>DOM 对象与 jQuery 对象之间是可以相互转换的。 </p><p>将 DOM 对象转换为 jQuery 对象： <code>$(DOMElement)</code>。只有 jQuery 对象才能使用 jQuery 对象特有的属性和方法，利用 <code>$</code> 把 DOM 对象包装成 jQuery 对象，这样就可以调用 jQuery 对象特有的属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ele = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;div&quot;</span>);<br>$(ele).hide();<br></code></pre></td></tr></table></figure><p>但是普通 DOM 对象的一些属性和方法 jQuery 没有给我们封装到 jQuery 对象中，如果要想使用这些属性和方法需要把 jQuery 对象转换为普通 DOM 对象才能使用。jQuery 对象转换为 DOM 对象有下面两种方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;div&quot;</span>)[index]; <span class="hljs-comment">// index 是索引号, jQuery 对象实际上是一个存储着 DOM 对象的伪数组集合</span><br>$(<span class="hljs-string">&quot;div&quot;</span>).get(index) <span class="hljs-comment">// index 是索引号</span><br></code></pre></td></tr></table></figure><h3 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h3><p>原生 JavaScript 获取元素方式可能存在兼容性问题，jQuery 顶级对象使用类似 CSS 选择器的方式快速获取元素，并且解决了兼容性问题。</p><p>jQuery 基础选择器：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192214286.png" alt="image-20210629110925369"></p><p>jQuery 层级选择器：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192214287.png" alt="image-20210629110949061"></p><p>jQuery 筛选选择器：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192214288.png" alt="image-20210629151630436"></p><p><strong>注意：和 CSS 伪类选择器有些许区别。</strong></p><p>jQuery 筛选方法：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192214289.png" alt="image-20210629151756361"></p><p><code>:checked</code> 选择器：匹配所有被选中的表单元素（复选框、单选框等）。</p><h3 id="jQuery-排他思想和链式编程"><a href="#jQuery-排他思想和链式编程" class="headerlink" title="jQuery 排他思想和链式编程"></a>jQuery 排他思想和链式编程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-built_in">this</span>).css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>);  <span class="hljs-comment">// 给当前元素设置样式</span><br>$(<span class="hljs-built_in">this</span>).siblings().css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 清楚其余兄弟元素的样式</span><br><br>$(<span class="hljs-built_in">this</span>).css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>).siblings().css(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 链式编程</span><br></code></pre></td></tr></table></figure><h3 id="jQuery-操作元素样式"><a href="#jQuery-操作元素样式" class="headerlink" title="jQuery 操作元素样式"></a>jQuery 操作元素样式</h3><p>jQuery 对象没有 <code>style</code>  属性，因此不能直接通过 <code>style</code> 属性来设置样式，而是通过 jQuery 对象的 <code>css()</code> 方法来设置样式。 jQuery 对象具有隐式迭代特性：会自动遍历 jQuery 对象中的伪数组集合，一次调用即可同时修改其伪数组中所有 DOM 元素的样式。</p><p><code>css()</code> 方法参数只写样式的属性名，则返回的是该样式的属性值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;div&quot;</span>).css(<span class="hljs-string">&quot;color&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>css()</code> 方法参数是样式的属性名和属性值，用逗号分隔，设置一组样式。属性名必须加引号，属性值如果是数字可以不用跟单位和引号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;div&quot;</span>).css(<span class="hljs-string">&quot;width&quot;</span>, <span class="hljs-number">300</span>);<br></code></pre></td></tr></table></figure><p><code>css()</code> 方法参数还可以是键值对形式的 JavaScript 对象，用来一次设置多组样式。属性名和属性值用冒号隔开，键值对中的 CSS 属性名使用驼峰命名法，比如用 <code>marginLeft</code> 代替 <code>margin-left</code>。属性名可以不用加引号，属性值如果是数字可以不用跟单位和引号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;div&quot;</span>).css(&#123; <br>    width: <span class="hljs-number">400</span>,<br>    height: <span class="hljs-number">400</span>,<br>    backgroundColor: <span class="hljs-string">&quot;red&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>除了 <code>css()</code> 方法还可以通过修改元素的类名从而匹配不同的选择器。类似于 DOM 对象中的 <code>classList</code> 属性，jQuery 对象也有三个方法来修改类名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;div&quot;</span>).addClass(<span class="hljs-string">&quot;current&quot;</span>);<span class="hljs-comment">// 添加类</span><br>$(<span class="hljs-string">&quot;div&quot;</span>).removeClass(<span class="hljs-string">&quot;current&quot;</span>);<span class="hljs-comment">// 移除类</span><br>$(<span class="hljs-string">&quot;div&quot;</span>).toggleClass(<span class="hljs-string">&quot;current&quot;</span>);<span class="hljs-comment">// 切换类</span><br></code></pre></td></tr></table></figure><h3 id="jQuery-动画效果"><a href="#jQuery-动画效果" class="headerlink" title="jQuery 动画效果"></a>jQuery 动画效果</h3><p>基本显示隐藏效果：</p><ul><li><p>  <code>show([speed,[easing],[fn]])</code>：显示指定的元素。</p></li><li><p>  <code>hide([speed,[easing],[fn]])</code>：隐藏指定的元素。</p></li><li><p>  <code>toggle([speed,[easing],[fn]])</code>：在显示和隐藏之间切换，如果元素是可见的，则切换为隐藏的；如果元素是隐藏的，则切换为可见的。</p></li></ul><p>滑动显示隐藏效果：</p><ul><li>  <code>slideDown([speed,[easing],[fn]])</code>：下滑显示指定的元素。</li><li>  <code>slideUp([speed,[easing],[fn]])</code>：上滑隐藏指定的元素。</li><li>  <code>slideToggle([speed,[easing],[fn]])</code>：滑动切换指定的元素。</li></ul><p>淡入淡出效果：</p><ul><li>  <code>fadeIn([speed,[easing],[fn]])</code>：淡入显示指定的元素。</li><li>  <code>fadeOut([speed,[easing],[fn]])</code>：淡出隐藏指定的元素。</li><li>  <code>fadeToggle([speed,[easing],[fn]])</code>：淡入淡出切换指定的元素。</li><li>  <code>fadeTo(speed,opacity,[easing],[fn]])</code>：渐进地调整元素到指定不透明度。<code>speed</code> 和 <code>opacity</code> 参数值必须写，不透明度取值 0~1 之间，值越小越透明，值为 0 代表完全透明显示底层元素的颜色，值为 1 则是完全不透明即正常显示。</li></ul><p>自定义动画：</p><ul><li>  <code>animate(params,[speed],[easing],[fn])</code>：创建自定义动画，以 JavaScript 对象键值对的形式指定想要更改的样式属性，通过 <code>params</code> 参数传递，样式属性就会从当前的值渐变到指定的值。属性名可以不用带引号，如果对应的 CSS 属性带有连字符则需要采取驼峰命名法，比如用 <code>marginLeft</code> 代替 <code>margin-left</code>。</li></ul><p>上面动画函数中的出现的三个参数描述如下：</p><ul><li>  <code>speed</code>：三种预定速度之一的字符串（<code>&quot;slow&quot;</code>，<code>&quot;normal&quot;</code> 或者 <code>&quot;fast&quot;</code>）或表示动画时长的毫秒数值（不需要带单位，如：1000）。</li><li>  <code>easing</code>：来指定切换效果，默认是 <code>&quot;swing&quot;</code>，可用参数 <code>&quot;linear&quot;</code> 。</li><li>  <code>fn</code>：回调函数，在动画完成时执行该函数，每个元素执行一次。</li></ul><p>停止动画：</p><ul><li>  <code>stop()</code>：动画效果一旦触发就会执行，如果同时触发多个动画效果，就造成动画效果排队执行。<code>stop()</code> 方法用于手动停止该元素正在运行的动画效果，并且使队列中的其他动画直接完成。<code>stop()</code> 通常写到动画效果的前面：<code>$(this).stop().fadeIn();</code>，即先结束其他动画，再开始新的动画效果。</li></ul><h3 id="jQuery-操作元素属性"><a href="#jQuery-操作元素属性" class="headerlink" title="jQuery 操作元素属性"></a>jQuery 操作元素属性</h3><ul><li><code>prop()</code>：设置或获取元素固有的属性值（元素本身自带的属性）。<ul><li>  <code>prop(&quot;属性&quot;)</code>：获取固有属性值。</li><li>  <code>prop(&quot;属性&quot;, &quot;属性值&quot;)</code>：设置固有属性值。</li></ul></li><li><code>attr()</code>：设置或获取元素自定义的属性值。<ul><li>  <code>attr(&quot;属性&quot;)</code>：获取元素自定义属性值，类似原生 DOM API 中的 <code>getAttribute()</code>，该方法也可以获取 HTML 5 规范中的自定义属性 data-[key] 中的值。</li><li>  <code>attr(&quot;属性&quot;, &quot;属性值&quot;)</code>：设置元素自定义属性值，类似 DOM 中的 <code>setAttribute()</code>。</li></ul></li><li><code>data()</code>：该方法可以在指定的元素上附加数据，但不会修改 DOM 元素结构，即元素标签中并不会显示该属性，一旦页面刷新，之前存放的数据都将被移除。<ul><li>  <code>date(&quot;key&quot;)</code>：获取该元素中存储的与 key 对应的值，该方法也可以获取 HTML 5 规范中的自定义属性 data-[key] 中的值。</li><li>  <code>data(&quot;key&quot;, value)</code>：在该元素上存储 key-value 键值对的数据，<code>value</code> 可以是任何格式的数据，而不仅仅是字符串。</li></ul></li></ul><h3 id="jQuery-操作元素内容"><a href="#jQuery-操作元素内容" class="headerlink" title="jQuery 操作元素内容"></a>jQuery 操作元素内容</h3><ul><li><p>  <code>html()</code>：获取元素中的 HTML 内容，包括子元素的 HTML 标签，相当于原生 DOM API 中的 <code>innerHTML</code> 属性。</p></li><li><p>  <code>html(&quot;val&quot;)</code>：设定元素中的 HTML 内容，会解析字符串其中的 HTML 标签。</p></li><li><p>  <code>text()</code>：仅获取元素中的文本内容，不包括子元素的 HTML 标签，相当于 原生 DOM API 中的 <code>innerText</code> 属性。</p></li><li><p>  <code>text(&quot;val&quot;)</code>：设定元素中的文本内容，不会解析其中的 HTML 标签。</p></li><li><p>  <code>val()</code>：获取表单元素中 <code>value</code> 属性的值。</p></li><li><p>  <code>val(&quot;val&quot;)</code>：设定表单元素中 <code>value</code> 属性的值。</p></li></ul><h3 id="jQuery-操作元素"><a href="#jQuery-操作元素" class="headerlink" title="jQuery 操作元素"></a>jQuery 操作元素</h3><ul><li><p><code>each()</code>：jQuery 的隐式迭代是对同一类元素做了同样的操作，如果想要给同一类元素做不同操作，就需要用到 <code>each()</code> 方法遍历。</p><ul><li>  <code>$(&quot;div&quot;).each(function (index, domEle) &#123; xxx; &#125;）</code>：对匹配的 JQuery 对象中的伪数组集合中的每一个 DOM 元素都传入回调函数进行处理，回调函数有 2 个参数： <code>index</code> 是 DOM 元素在伪数组中的索引号，<code>domEle</code> 则是待处理的 DOM 元素对象。<strong>注意 <code>domEle</code> 不是一个 jQuery 对象，如果要调用 jQuery 方法要先利用 <code>$</code> 把 <code>domEle</code> 对象包装成 jQuery 对象。</strong></li><li>  <code>$.each(object，function (index, element) &#123; xxx; &#125;）</code>：遍历任何对象。主要用于数据处理，比如数组，对象，回调函数有 2 个参数： <code>index</code> 是每个元素的索引号，<code>element</code> 是待处理的元素。</li></ul></li><li><p>  <code>$(&quot;&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;&quot;).</code>：动态创建一个 div 元素（以及其中的所有内容）。</p></li><li><p>  <code>append(&quot;内容&quot;)</code>：在该元素的内部尾部追加内容，类似 DOM 中的 <code>appendChild()</code>，追加的元素和该元素是父子节点关系。</p></li><li><p>  <code>prepend(&quot;内容&quot;)</code>：在该元素的内部头部插入内容，追加的元素和该元素是父子节点关系。</p></li><li><p>  <code>appendTo(&quot;selector&quot;)</code>：把选择器所匹配的元素追加到该元素内部尾部中。颠倒了常规的<code>$(A).append(B)</code>的操作，即不是把 B 追加到 A 中，而是把 A 追加到  B 中。</p></li><li><p>  <code>prependTo(&quot;selector&quot;)</code>：把选择器所匹配的元素插入到该元素内部头部中。颠倒了常规的<code>$(A).prependTo(B)</code>的操作，即不是把 B 追加到 A 中，而是把 A 追加到  B 中。</p></li><li><p>  <code>after(&quot;内容&quot;)</code>：在该元素的外部尾部追加内容，追加的元素和该元素是兄弟节点关系。</p></li><li><p>  <code>before(&quot;内容&quot;)</code>：在该元素的外部头部追加内容，追加的元素和该元素是兄弟节点关系。</p></li><li><p>  <code>remove()</code>：删除元素本身，包括其中的子节点。</p></li><li><p>  <code>empty()</code>：删除元素的所有子节点，和 <code>html(&quot;&quot;)</code> 作用等价，都可以删除元素里面的内容，只不过 <code>html()</code> 方法在清空元素原来内容的同时还可以设置内容。</p></li></ul><h3 id="jQuery-操作元素尺寸"><a href="#jQuery-操作元素尺寸" class="headerlink" title="jQuery 操作元素尺寸"></a>jQuery 操作元素尺寸</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192214290.png" alt="image-20210820171256963"></p><p>以上方法的参数为空，则是获取相应值，返回的是数字型。可以传入参数设置相应值，参数为省略 px 单位的数字或者带单位的字符串。</p><h3 id="jQuery-操作元素位置"><a href="#jQuery-操作元素位置" class="headerlink" title="jQuery 操作元素位置"></a>jQuery 操作元素位置</h3><ul><li>  <code>offset()</code>：获取元素相对于文档（HTML 根元素）的偏移坐标对象，该对象有 2 个属性 <code>left</code>、<code>top</code> 。<code>offset().top</code> 用于获取距离文档顶部的距离，<code>offset().left</code> 用于获取距离文档左侧的距离。这两个属性是只读的，只能通过 <code>offset()</code> 方法传入一个带有 <code>top</code> 和 <code>left</code> 属性的对象来修改偏移距离，例如 <code>offset(&#123; top: 10, left: 30 &#125;);</code>。</li><li>  <code>postion()</code>：获取元素相对于带有定位的父级的偏移坐标对象，如果父级都没有定位，则是相对于文档（HTML 根元素）的偏移坐标。返回的对象有 2 个属性 <code>left</code>、<code>top</code>。<code>position().top</code> 用于获取距离带定位父级顶部的距离，<code>position().left</code> 用于获取距离带定位父级左侧的距离。该方法只能获取偏移不能修改偏移距离。</li><li>  <code>scrollTop()</code>：获取元素被卷去的头部距离，可以传入参数设置被卷去的头部距离，参数为省略 px 单位的数字或者带单位的字符串。<code>$(document).scrollTop()</code> 获取文档滚动的距离，多配合 <code>$(window).scroll()</code> 浏览器滚动事件使用。</li><li>  <code>scrollLeft()</code>：获取元素被卷去的左侧距离，可以传入参数设置被卷去的左侧距离，参数为省略 px 单位的数字或者带单位的字符串。</li></ul><h3 id="jQuery-添加事件"><a href="#jQuery-添加事件" class="headerlink" title="jQuery 添加事件"></a>jQuery 添加事件</h3><p>jQuery 对象能够使用一系列方法比如 <code>click()</code>，<code>mouseover()</code> 来添加事件，类似原生 DOM API 中给元素对象的事件属性如 <code>onclick</code>、<code>onmouseover</code> 赋值一个函数对象。</p><p><strong>注意：原生使用的是属性赋值， jQuery 是通过调用方法传入函数参数，并且 jQuery 的事件类型前面没有 on 前缀。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 原生 DOM API</span><br>element.onclick = <span class="hljs-function"><span class="hljs-title">funnction</span>(<span class="hljs-params"></span>)</span> &#123;Xxx;&#125;;<br><br><span class="hljs-comment">// jQuery 添加事件</span><br>$(<span class="hljs-string">&quot;div&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;Xxx;&#125;);<br></code></pre></td></tr></table></figure><p>但现在更推荐使用 <code>on()</code> 方法来为 jQuery 对象绑定事件。</p><ul><li>  <code>on(events-map,[selector])</code> 为对象同时绑定多个不同事件：<code>events-map</code> 中的键表示事件类型，值表示事件绑定的处理函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;div&quot;</span>).on(&#123;<br>    mouseover: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-comment">// 事件处理函数</span><br>    &#125;,<br>    mouseout: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-comment">// 事件处理函数</span><br>    &#125;,<br>    click: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-comment">// 事件处理函数</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>  <code>on(events,[selector],fn)</code> 为对象同时绑定多个相同事件，<code>events</code> 是一个或多个用空格分隔的事件类型，<code>fn</code> 为事件处理函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;div&quot;</span>).on(<span class="hljs-string">&quot;mouseover mouseout click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 事件处理函数</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>上面两个方法的 <code>selector</code> 参数用来指定触发事件的后代元素，通过把原本应该绑定在子元素身上的事件注册在父元素身上，配合事件冒泡机制可以实现事件委派。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 事件绑定在 ul 上，但是触发的对象是 ul 里面的小 li，也就是说点击 ul 中的非小 li 范围不会触发事件 </span><br>$(<span class="hljs-string">&quot;ul&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 事件处理函数</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>通过事件委派，之后动态生成的子元素也能触发事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;ul&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-string">&quot;click&quot;</span>);<br>&#125;);<br><span class="hljs-keyword">var</span> li = $(<span class="hljs-string">&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;</span>);<br>$(<span class="hljs-string">&quot;ol&quot;</span>).append(li); <span class="hljs-comment">// 点击该 li 可以 触发事件，前提是 ul 在已经提前存在</span><br></code></pre></td></tr></table></figure><p>如果是直接给子元素添加事件则只对之前已经存在的子元素才有效：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;ul li&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-string">&quot;click&quot;</span>);<br>&#125;);<br><span class="hljs-keyword">var</span> li = $(<span class="hljs-string">&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;</span>);<br>$(<span class="hljs-string">&quot;ul&quot;</span>).append(li); <span class="hljs-comment">// 点击该 li 无法触发事件，之前的已经存在的 li 可以触发事件</span><br></code></pre></td></tr></table></figure><h3 id="jQuery-解绑事件"><a href="#jQuery-解绑事件" class="headerlink" title="jQuery 解绑事件"></a>jQuery 解绑事件</h3><p>使用 <code>off()</code> 方法可以移除通过 <code>on()</code> 方法添加的事件处理程序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;p&quot;</span>).off(); <span class="hljs-comment">// 解绑p元素所有事件处理程序</span><br>$(<span class="hljs-string">&quot;p&quot;</span>).off(<span class="hljs-string">&quot;click&quot;</span>); <span class="hljs-comment">// 解绑p元素上面的点击事件 后面的 foo 是侦听函数名</span><br>$(<span class="hljs-string">&quot;ul&quot;</span>).off(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-string">&quot;li&quot;</span>); <span class="hljs-comment">// 解绑事件委托</span><br></code></pre></td></tr></table></figure><p>如果事件只想被触发一次， 可以使用 <code>one()</code> 方法来代替 <code>on()</code> 来为元素绑定一个一次性的事件处理函数，这个事件处理函数只会被执行一次，不用再手动解绑事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;div&quot;</span>).one(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-comment">// 事件处理函数</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="jQuery-手动触发事件"><a href="#jQuery-手动触发事件" class="headerlink" title="jQuery 手动触发事件"></a>jQuery 手动触发事件</h3><p>有时候需要手动触发某些时事件，比如中需要根据定时器自动触发右侧按钮点击事件来滚动图片。jQuery 中有三种手动触发事件的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一种，类似原生触发方式</span><br>$(<span class="hljs-string">&quot;a&quot;</span>).click();<br><br><span class="hljs-comment">// 第二种，会导致浏览器同名的默认行为的执行，比如链接元素点击会跳转，表单元素触发 submit 事件后会提交</span><br>$(<span class="hljs-string">&quot;form&quot;</span>).trigger(<span class="hljs-string">&quot;submit&quot;</span>);<br><br><span class="hljs-comment">// 第三种，只会触发你绑定的事件处理函数，将不会执行浏览器默认动作，也不会产生事件冒泡</span><br>$(<span class="hljs-string">&quot;form&quot;</span>).triggerHandler(<span class="hljs-string">&quot;submit&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="jQuery-事件对象"><a href="#jQuery-事件对象" class="headerlink" title="jQuery 事件对象"></a>jQuery 事件对象</h3><p>jQuery 中的事件对象和原生 DOM API 中的事件对象拥有的属性大致相同，并在此基础上做了一些兼容性处理。</p><p>和原生 DOM API 中一样，可以使用 <code>event</code> 对象阻止浏览器默认行为和事件冒泡：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 阻止超链接进行跳转</span><br>$(<span class="hljs-string">&quot;a&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;  <br>　　event.preventDefault();<br>&#125;);<br><br><span class="hljs-comment">// 阻止超链接进行跳转</span><br>$(<span class="hljs-string">&quot;a&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;  <br>　　<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;);<br><br><span class="hljs-comment">// 阻止事件冒泡</span><br>$(<span class="hljs-string">&quot;div&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;  <br>　　 event.stopPropagation();<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="jQuery-对象拷贝"><a href="#jQuery-对象拷贝" class="headerlink" title="jQuery 对象拷贝"></a>jQuery 对象拷贝</h3><ul><li>  <code>$.extend([deep], target, object1, [objectN])</code>：用一个或多个其他对象来扩展一个对象，返回被扩展的对象。该方法可以用来拷贝复制一个对象或者合并多个对象。<code>deep</code> 如果设为 <code>true</code>，则是递归合并即深拷贝，如果省略则默认为 <code>false</code> 即浅拷贝，浅拷贝只是拷贝一层，对象中更深层次的复杂属性只拷贝了引用。即浅拷贝目标中的引用类型变量和原对象中的引用类型变量指向同一个对象实例，修改目标对象会影响被拷贝对象中的对象实例。<code>target</code> 为待修改对象，<code>object1</code> 和 <code>objectN</code> 为待合并（拷贝）的一个对象或多个对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> empty = &#123;&#125;;<br><span class="hljs-keyword">var</span> defaults = &#123; <span class="hljs-attr">validate</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">limit</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span> &#125;;<br><span class="hljs-keyword">var</span> options = &#123; <span class="hljs-attr">validate</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;bar&quot;</span> &#125;;<br><span class="hljs-keyword">var</span> settings = $.extend(empty, defaults, options); <span class="hljs-comment">// settings 和 empty 最后都为 &#123; validate: true, limit: 5, name: &quot;bar&quot; &#125;</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>  <a href="https://www.bilibili.com/video/BV1a4411w7Gx">B 站：黑马程序员前端基础必备教程|jQuery网页开发案例精讲</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计网虐我千百遍，我待计网如初恋，已经不记得是几次重学计网了。这次看的<a href="https://www.bilibili.com/video/BV1c4411d7jb">视频教程</a>动画甚是精美，章节末的总结精炼实用，遂截图下来，并补充下细节，以后忘了不用再去找视频刷，翻翻笔记就好了。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="因特网组成"><a href="#因特网组成" class="headerlink" title="因特网组成"></a>因特网组成</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245103.png" alt="image-20210607174531600"></p><h3 id="3-种交换方式对比"><a href="#3-种交换方式对比" class="headerlink" title="3 种交换方式对比"></a>3 种交换方式对比</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245104.png" alt="image-20210607175932078"></p><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245105.png" alt="image-20210607180336023"></p><h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245106.png" alt="image-20210607181736288"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245107.png" alt="image-20210607182256059"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245108.png" alt="image-20210607192809203"></p><h3 id="网络体系结构划分"><a href="#网络体系结构划分" class="headerlink" title="网络体系结构划分"></a>网络体系结构划分</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245109.png" alt="image-20210607183116713"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245110.png" alt="image-20210607190354136"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245111.png" alt="image-20210607183708539"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245112.png" alt="image-20210607184028006"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245113.png" alt="image-20210607190206792"></p><h3 id="服务与协议"><a href="#服务与协议" class="headerlink" title="服务与协议"></a>服务与协议</h3><ul><li>下层协议对上层是透明的，上层实体不关心下层提供服务的具体实现。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245114.png" alt="image-20210607184751610"><br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245115.png" alt="image-20210607184908020"></p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245116.png" alt="image-20210607202252272"></p><h3 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h3><ul><li>严格来说传输媒体不属于计算机网络体系结构的任何一层，或者说在物理层之下。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245117.png" alt="image-20210607203619245"></p><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245118.png" alt="image-20200917150009806"></p><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245119.png" alt="image-20200917150133434"></p><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245120.png" alt="image-20210607210352767"></p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><ul><li>封装成帧：数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。帧头和帧尾中包含有重要的控制信息，作用之一就是帧定界。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245121.png" alt="image-20200912085546970"></li><li>但并不是所有数据链路层协议的帧都包含有帧定界标志，例如以太网 V2 的 MAC 帧就没有帧定界符。尽管 以太网 V2 链路层没有加上帧定界，但是物理层在传输 MAC 帧时会加上 8 字节的前导码，配合帧间间隔就可以区分相邻的帧。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245122.png" alt="image-20200912085707815"></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245123.png" alt="image-20200912085736428"></p><ul><li>透明传输：指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。是当上层的数据出现了和帧定界相同的字节流或者比特流时不能正确区分是数据还是帧定界帧，据链路层在发送帧之前会对帧的载荷数据部分进行扫描，每出现一个帧定界符就在前面插入特点的转义字符或者比特，当接收方从物理层交付的比特流中提取帧时，如果帧定界符在转义字符或者特定比特后面则会当成数据而不是定界符，剔除转义字符后把该帧定界符当作载荷数据提取。</li><li>面向字节的物理链路使用字节填充（或称字符填充）的方式实现透明传输，例如以太网采用 ESC 转义字符填充，ESC 是长度为一个字节一个特殊的控制字符，十进制值为 27，ASCII 表中对应 ESC 控制字符。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245124.png" alt="image-20200912091934078"></li><li>面向字节的异步链路 PPP 协议填充方式：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245125.png" alt="image-20200912105442008"></li><li>面向比特的物理链路使用比特填充的方式实现透明传输，例如面向比特的同步链路 PPP 协议采用零比特填充法：每 5 个连续的 1 后面插入一个比特 0。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245126.png" alt="image-20200912091926285"></li><li>为了提高帧的传输效率，应当使帧的数据载荷部分的长度尽可能大些。但是考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元（MTU:Maximum Transfer Unit）</li></ul><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><ul><li><p>比特差错：实际通信链路都不是理想的，比特在传输过程中可能会产生差错。</p></li><li><p>误码率 BER（Bit Error Rate）：传输错误的比特占传输总比特总数的比率。</p></li><li><p>检错码：只能检测差错，但并不能定位定位错误和纠正错误。例如奇偶校验，CRC 校验.</p><ul><li>奇偶校验：奇位检错能力，无纠错，例如服务器 ECC 内存条。</li><li>CRC：循环冗余校验，根据约定好的生成多项式来计算是否出错，漏检率很低，易于硬件实现，常用于数据链路层。</li></ul></li><li><p>纠错码：使用更多的冗余校验位可以进行前向纠错，但是纠错码开销较大，计算机网络中较少使用，而是通过检错重传的方式来纠错，或者仅仅是丢弃检测到有差错的帧。</p><ul><li>汉明码：海明校验，纠错能力很好，但是开销大。</li></ul></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245127.png" alt="image-20210607222853708"></p><h3 id="可靠传输的基本概念"><a href="#可靠传输的基本概念" class="headerlink" title="可靠传输的基本概念"></a>可靠传输的基本概念</h3><ul><li>通过帧尾的 FCS 字段 可以检测出帧在传输过程中是否产生了比特错误，不同数据链路层协议可以向上层提供不同的服务类型。<ul><li>不可靠传输服务：简单丢弃检测到差错的帧。有线链路误码率比较低，为了减少开销，即使误码也可以交由上层处理。</li><li>可靠传输服务：想办法实现。无线链路容易受到干扰，误码率较高，因此必须向上层提供可靠传输服务。</li></ul></li><li>传输差错不只数据链路层的比特差错，还包括可能发生在上层的分组丢失、分组失序以及分组重复。因此可靠传输不局限于数据链路层，其他各层均可实现可靠传输。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245128.png" alt="image-20210607233649169"></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245129.png" alt="image-20200912094547278"></p><h3 id="可靠传输的实现"><a href="#可靠传输的实现" class="headerlink" title="可靠传输的实现"></a>可靠传输的实现</h3><ul><li><p>停止等待协议 SW（Stop and Wait）<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245130.png" alt="image-20200912100439260"></p></li><li><p>回退 N 帧协议 GBN（Go Back N）</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245131.png" alt="image-20200912102524653"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245132.png" alt="image-20200912102319764"></p></li><li><p>选择重传协议 SR（Selective Request）</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245133.png" alt="image-20200912103646583"></p></li></ul><h3 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245134.png" alt="image-20210608100952588"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245135.png" alt="image-20210608100930107"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245136.png" alt="image-20210608101107336"></p><h3 id="媒体接入控制-MAC"><a href="#媒体接入控制-MAC" class="headerlink" title="媒体接入控制 MAC"></a>媒体接入控制 MAC</h3><ul><li>媒体接入控制（Medium Access Control）：协调多个发送和接收站点对一个共享传输媒体的占用问题。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245137.png" alt="image-20200912110505135"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245138.png" alt="image-20210608102921391"></p><ul><li>CSMA/CD（Carrier Sense Multiple Access with Collision Detection，载波监听多路访问/碰撞检测）：CSMA/CD 协议曾经用于早起的总线式（共享信道）的 802.3 以太网，点对点链路和链路层交换机的交换式局域网在有线领域已经完全取代了共享式局域网。现代的以太网多基于交换机和全双工连接，不会有碰撞，也没必要使用 CSMA/CD 协议。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245139.png" alt="image-20210608103347140"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245140.png" alt="image-20210608103256365"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245141.png" alt="image-20200912112412881"></p><ul><li><p>最小帧长：争用期 × 信道带宽，为了让距离最远的两台主机之间都能检测碰撞（CSMA/CD），以 10 Mbps 的以太网为例，最小帧长 = 争用期 51.2 μs × 10 Mb/s = 512 bit = 64 KByte。 </p><p>最大帧长：为了防止长时间占用信道还有接收方缓冲区溢出等问题，帧也不能太长，并且太长容易发生误码，接受后由于校验所造成延迟也更长。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245142.png" alt="image-20200912131434472"><br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245143.png" alt="image-20200912131836358"><br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245144.png" alt="image-20200912131920242">     </p></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245145.png" alt="image-20210608113802494"></p><ul><li>CSMA/CA（Carrier Sense Multiple Access with Collision Avoid，载波监听多路访问/碰撞避免）：802.11 无线局域网采用的媒体接入控制协议是 CSMA/CA（载波监听多点接入/避免碰撞），802.11局域网在使用 CSMA/CA 的同时，还使用停止-等待协议保证可靠传输。这是因为无线信道的通信质量远不如有线信道，因此无线站点每发送完一个数据帧后，要等到收到对方的确认帧后才能继续发送下一帧。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245146.png" alt="image-20200912141852488"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245148.png" alt="image-20210608115629654"></p><h3 id="MAC-地址、IP-地址-和-ARP-协议"><a href="#MAC-地址、IP-地址-和-ARP-协议" class="headerlink" title="MAC 地址、IP 地址 和 ARP 协议"></a>MAC 地址、IP 地址 和 ARP 协议</h3><ul><li>MAC 地址：是对网络上各个接口的唯一标识，网卡出厂即分配好，全球唯一，常用于目的地址和源地址的标识，由于这类地址是用于媒体接入控制（Medium Access Control），所以被称为 MAC 地址。但并不是所有 MAC  层（即数据链路层）的协议都要用到该地址，例如使用点对点信道的数据链路层协议 PPP 就不需要 MAC 地址的标识。MAC 地址一般被固化在网卡的EEPROM中，因此也被称为物理地址。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245149.png" alt="image-20210608121448929"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245150.png" alt="image-20200912145152380"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245151.png" alt="image-20200912145256790"></p><ul><li>IP 地址<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245152.png" alt="image-20210608121946112"></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245153.png" alt="image-20200912152434524"></p><ul><li>ARP 协议：地址解析协议（网络层）<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245154.png" alt="image-20200912153531522"><br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245155.png" alt="image-20200912153609468"></li></ul><h3 id="集线器和交换机"><a href="#集线器和交换机" class="headerlink" title="集线器和交换机"></a>集线器和交换机</h3><ul><li><p>集线器：<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245156.png" alt="image-20200912154028327"></p></li><li><p>交换机：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245157.png" alt="image-20200912154315513"></p></li><li><p>对比：<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245158.png" alt="image-20200912154602523"></p></li><li><p>交换机自学习<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245159.png" alt="image-20200912155231126"><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245160.png" alt="image-20200912155733718"></p></li><li><p>以太网交换机生成树协议 STP<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245161.png" alt="image-20200912161224967"></p></li></ul><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><ul><li>局域网：在一个广播域中的所有网络设备构成一个局域网，即两台主机只通过二层（物理层和数据链路层）就可达就说明这两台主机在一个局域网内。使用交换机或集线器连接的主机构成一个局域网。</li><li>使用交换机或集线器会扩大广播域，但可能会带来广播风暴或者安全问题，可以用路由器隔离广播域但是成本较高。可以利用 VLAN 技术将一个局域网中的设备划分成不同的逻辑组，同一个 VLAN 之间可以相互广播通信，不同 VLAN 之间不能通过直接通信。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245162.png" alt="image-20210608125649494"></li><li>VLAN 的实现：VLAN 是在交换机上实现的，需要交换机实现以下两大功能，能够处理带有 VLAN 标记的帧，即 IEEE 802.1Q 帧，二是交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245163.png" alt="image-20200912164006130"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245164.png" alt="image-20210608173200652"></p><h3 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h3><ul><li>IP 协议提供的是不可靠服务，并不确保传输的分组不丢失。IP 路由器对收到的 IP 分组进行差错检测，发现错误会丢弃该分组并向源主机发送 ICMP 差错报文（类型为参数错误）。</li><li>虚电路服务与数据报服务比较<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245165.png" alt="image-20200912170832551"></li></ul><h3 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245166.png" alt="image-20200912170942244"></p><ul><li>分类编址：<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245167.png" alt="image-20200912190919894"> </li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245168.png" alt="image-20210608175219518"></p><ul><li>划分子网：从原来 ABC 类地址中的主机号借用一定位数的比特来作为子网号，子网掩码左起全 1 的位数 = 网络号位数 + 子网号位数。格式：网络号 + 子网号 + 主机号。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245169.png" alt="image-20210608194529835"></li><li>无分类编址 CIDR格式：前缀号 + 主机号/n。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245170.png" alt="image-20200912194143096"></p><ul><li>路由聚合，构造超网<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245171.png" alt="image-20200912195743365"></li><li>定长子网掩码划分和变长子网掩码划分<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245172.png" alt="image-20200912200332163"></li></ul><h3 id="路由转发过程"><a href="#路由转发过程" class="headerlink" title="路由转发过程"></a>路由转发过程</h3><ol><li>源主机判断目的主机IP地址是否在同一个网络（子网）中：源主机ip地址和子网掩码相与得到源主机所在网络号，与目的ip地址和源主机子网掩码相与得到的结果比较，如果相同则说明在同一网络，不同则说明不在同一个网络，同一子网中，网络号相同，掩码相同，</li><li>如果不在同一个网络？则将 IP 数据报发送给默认网关，默认网关IP是用户操作系统配置好的或者自动分配的，再结合ARP协议查询到默认网关的MAC地址，通过链路层将 IP 数据报 发送给默认网关，通常是路由器的一个端口。</li><li>路由器接收到IP 数据报后检查是否出错，若出错则直接丢弃IP数据报并报告源主机</li><li>将目的地址与路由条目中的地址掩码相与，然后xxxxx把结果和此条目对应的目的网络号相比较，如果相等或者是目的网络的一个子网 ，则此路由条目就是匹配的路由条目</li></ol><ul><li>路由器不会转发全网络广播IP数据报（目的IP地址受限广播地址255.255.255.255），即路由器是隔离广播域的。但是可以通过配置转发直接广播地址跨网段广播。</li><li>对目的地址是私有地址的 IP数据报一律不转发</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245173.png" alt="image-20210608204939096"></p><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245174.png" alt="image-20210608205410293"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245175.png" alt="image-20200913082153860"></p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245176.png" alt="image-20200913085133174"></p><h3 id="路由信息协议-RIP"><a href="#路由信息协议-RIP" class="headerlink" title="路由信息协议 RIP"></a>路由信息协议 RIP</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245177.png" alt="image-20210608210811895"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245178.png" alt="image-20200913091250744"></p><h3 id="开放最短路径优先协议-OSPF"><a href="#开放最短路径优先协议-OSPF" class="headerlink" title="开放最短路径优先协议 OSPF"></a>开放最短路径优先协议 OSPF</h3><ul><li><p>OSPF 工作过程<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245179.png" alt="image-20200913092353796"></p></li><li><p>为了减少 AS 系统内部的泛洪，可以把 AS 再划分为多个区域，这样泛洪的范围就局限于一个每一个区域，而不是整个 AS。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245180.png" alt="image-20200913093015022"></p></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245181.png" alt="image-20200913093354260"></p><h3 id="边界网关协议-BGP"><a href="#边界网关协议-BGP" class="headerlink" title="边界网关协议 BGP"></a>边界网关协议 BGP</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245182.png" alt="image-20210608212234397"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245183.png" alt="image-20200913094650012"></p><h3 id="三种路由选择协议的封装"><a href="#三种路由选择协议的封装" class="headerlink" title="三种路由选择协议的封装"></a>三种路由选择协议的封装</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245184.png" alt="image-20210608212455298"></p><h3 id="IPv4-首部格式"><a href="#IPv4-首部格式" class="headerlink" title="IPv4 首部格式"></a>IPv4 首部格式</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245185.png" alt="image-20200913095143617"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245186.png" alt="image-20200913103749489"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245187.png" alt="image-20200913103850332"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245188.png" alt="image-20200913103929613"></p><ul><li><p>IPv4 分片：因为链路层的最大载荷可能有限制（例如以太网为 1500 字节），所以要对较长的 IP 数据报进行分片，负责 IP 分片的那台主机、路由器通过硬件、或软硬件结合、或纯粹软件方式来分片，处理分片会花费很多 CPU 资源，要尽可能避免 IP 分片。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">IP</span> = IP Header + TCP = <span class="hljs-number">20</span> + <span class="hljs-number">1480</span> = <span class="hljs-number">1500</span> Byte <br><span class="hljs-attribute">TCP</span> = TCP Header + TCP Payload = <span class="hljs-number">20</span> + <span class="hljs-number">1460</span> = <span class="hljs-number">1480</span> Byte<br></code></pre></td></tr></table></figure><p>这个 TCP Payload = 1460 Byte 对应的就是 TCP 最大传输单元，我们称之为 Maximum Segment Size 即 MSS，即 MSS = MTU - IP Header - TCP Header =  1500 - 20 -20  = 1460。<br>TCP 在三次握手的第一个 SYN 消息中有一个选项 option 4，就是为了协商通信双方的 MSS，会选择较小的一方作为这个 TCP 连接的 MSS，这样双向通信都可以避免因为 IP 包太大引起的分片。参考：<a href="https://mp.weixin.qq.com/s/RP6w69I-q5ai9Bx_SzjUfQ">TCP/IP 协议栈中，为什么选择 IP 层负责分片？</a>以及<a href="https://zhuanlan.zhihu.com/p/21276275">车小胖谈网络：IP层分片</a></p></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245189.png" alt="image-20200913104123195"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245190.png" alt="image-20200913104138634"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245191.png" alt="image-20200913104252932"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245192.png" alt="image-20200913104311529"></p><h3 id="网际控制报文-ICMP"><a href="#网际控制报文-ICMP" class="headerlink" title="网际控制报文 ICMP"></a>网际控制报文 ICMP</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245193.png" alt="image-20200913110122111"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245194.png" alt="image-20200913110052374"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245195.png" alt="image-20200913105840922"></p><h3 id="VPN-和-NAT"><a href="#VPN-和-NAT" class="headerlink" title="VPN 和 NAT"></a>VPN 和 NAT</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245196.png" alt="image-20210608221318355"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245197.png" alt="image-20210608221407260"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245198.png" alt="image-20210608221449407"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245199.png" alt="image-20210608221210918"></p><p>中继器和集线器工作在物理层，既不隔离冲突域也不隔离广播域</p><p>网桥和交换机（多端口网桥）工作在数据链路层，可以隔离冲突域，不能隔离广播域。</p><p>路由器工作在网络层，即隔离冲突域，也隔离广播域</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245200.png" alt="image-20210608223016389"></p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245201.png" alt="image-20200913121805940"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245202.png" alt="image-20210609064541512"></p><h3 id="UDP-和-TCP-的对比"><a href="#UDP-和-TCP-的对比" class="headerlink" title="UDP 和 TCP 的对比"></a>UDP 和 TCP 的对比</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245203.png" alt="image-20200913123315833"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245205.png" alt="image-20200913123200866"></p><h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245206.png" alt="image-20200913160117528"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245207.png" alt="image-20200913163208407"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245208.png" alt="image-20200913163126209"></p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245209.png" alt="image-20210609072002446"></p><ul><li>慢开始和拥塞避免（1988 TCP Tahoe 版本）</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245210.png" alt="image-20200913160946680"></p><ul><li>快重传和快恢复（1990 年 TCP Reno 版本）</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245211.png" alt="image-20200913162804123"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245212.png" alt="image-20200913162150570"></p><ul><li>TCP 超时重传时间选择<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245213.png" alt="image-20200913164756064"></li></ul><h3 id="TCP-可靠传输实现"><a href="#TCP-可靠传输实现" class="headerlink" title="TCP 可靠传输实现"></a>TCP 可靠传输实现</h3><ul><li>重传机制：采用的是累计确认，发送接收双滑动窗口传输， 选择重传还是回退N帧根据不同实现不同（TCP 扩展首部的「选项」字段里加一个 SACK <strong>方</strong> 的东西的选择确认）</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245214.png" alt="image-20200913181452069"></p><h3 id="TCP-建立连接"><a href="#TCP-建立连接" class="headerlink" title="TCP 建立连接"></a>TCP 建立连接</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245215.png" alt="image-20200913190746286"></p><h3 id="TCP-断开连接"><a href="#TCP-断开连接" class="headerlink" title="TCP 断开连接"></a>TCP 断开连接</h3><ul><li>等待 2 倍 MSL 时间的作用：可以确保TCP 服务进程可以收到最后一个 TCP 确认报文段而正确进入关闭状态，释放相关资源 ，并且使连接持续时间所产生的所有报文段都从网络中消失，这样下一个TCP 连接中不会出现旧连接中的报文段。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245216.png" alt="image-20200913192327712"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245217.png" alt="image-20210609083841769"></p><h3 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245218.png" alt="image-20200913194841680"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245219.png" alt="image-20200913194936410"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245220.png" alt="image-20200913195003453"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245221.png" alt="image-20200913195244786"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245222.png" alt="image-20200913195557210"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245223.png" alt="image-20200913195928780"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245224.png" alt="image-20200913195016090"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245225.png" alt="image-20200913200201010"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245226.png" alt="image-20200913200154677"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245227.png" alt="image-20200913200124280"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245228.png" alt="image-20200913200142360"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245229.png" alt="image-20200913195629509"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245230.png" alt="image-20200913195816410"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245231.png" alt="image-20200913200008538"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245232.png" alt="image-20200913200015548"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>C/S 架构和 P2P</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245233.png" alt="image-20200913222801512"></p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245234.png" alt="image-20200913224141124"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245236.png" alt="image-20200913224229014"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245237.png" alt="image-20200913224111960"></p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245238.png" alt="image-20200914201550904"></p><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245240.png" alt="image-20200914202751122"></p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245241.png" alt="image-20200914204248600"></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192245242.png" alt="image-20200914210810207"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.bilibili.com/video/BV1c4411d7jb">B 站视频：计算机网络微课堂</a></li><li><a href="https://www.icourse163.org/course/HDU-1002598057">计算机网络自学笔记</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 进阶学习</title>
    <link href="/2021/05/10/JavaScript%20%E8%BF%9B%E9%98%B6/"/>
    <url>/2021/05/10/JavaScript%20%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>三种定义函数的方式：</p><ol><li><p>使用 <code>function</code> 关键字 函数声明方式（命名函数）：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure></li><li><p>函数表达式（匿名函数）</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure></li><li><p>调用 <code>Function(&#39;参数1&#39;,&#39;参数2&#39;..., &#39;函数体&#39;)</code> 构造函数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;console.log(a + b)&#x27;</span>);<br>f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li></ol><p>第三种方式执行效率低，也不方便书写，因此较少使用，但是要知道所有函数本质上都是 <code>Function</code> 的实例对象，可以通过函数对象的原型 <code>__proto__</code> 属性来获取到 <code>Function</code> 原型对象。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213819.png" alt="image-20210913164629767"></p><h3 id="函数调用方式"><a href="#函数调用方式" class="headerlink" title="函数调用方式"></a>函数调用方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 1. 普通函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;人生的巅峰&#x27;</span>);<br>&#125;<br>fn(); <span class="hljs-comment">// 直接加小括号调用</span><br><span class="hljs-comment">/* 2. 对象的方法 */</span><br><span class="hljs-keyword">var</span> o = &#123;<br>    sayHi: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;人生的巅峰&#x27;</span>);<br>    &#125;<br>&#125;<br>o.sayHi();<span class="hljs-comment">// 通过对象实例调用</span><br><span class="hljs-comment">/* 3. 构造函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">new</span> Star();<span class="hljs-comment">// 使用 new 关键字调用</span><br><span class="hljs-comment">/* 4. 绑定事件函数*/</span><br>btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;   <span class="hljs-comment">// 点击了按钮就可以调用这个回调函数</span><br><span class="hljs-comment">/* 5. 定时器函数*/</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;, <span class="hljs-number">1000</span>);  这个函数是定时器自动<span class="hljs-number">1</span>秒钟调用一次<br><span class="hljs-comment">/* 6. 立即执行函数(自调用函数)*/</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;人生的巅峰&#x27;</span>);<br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="函数中的-this-指向"><a href="#函数中的-this-指向" class="headerlink" title="函数中的 this 指向"></a>函数中的 <code>this</code> 指向</h3><p>调用函数的时候确定了 <code>this</code> 的指向，调用方式的不同决定了 <code>this</code> 的指向不同<br>一般来说 <code>this</code> 指向调用者，谁调用了函数 <code>this</code> 指向谁。.</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213820.png" alt="image-20210913165516840"></p><p>JavaScript 提供了一些函数方法处理函数内部 <code>this</code> 的指向问题，常用的有 <code>bind()</code>、<code>call()</code>、<code>apply()</code> 三种方法。</p><ul><li><p><code>call(thisArg, arg1, arg2, ...)</code>：执行这个函数对象，并且使函数运行时的 <code>this</code> 指向 <code>thisArg</code>，<code>arg1</code>，<code>arg2</code> 是向函数传递的其他参数，该方法的返回值就是函数对象执行得到的返回值。<code>call()</code> 常用于组合继承中子类调用父类的构造函数。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;<br>name: <span class="hljs-string">&#x27;andy&#x27;</span><br>&#125;<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>      <span class="hljs-built_in">console</span>.log(a+b)<br>&#125;;<br>fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">// 此时的this指向的是window </span><br>fn.call(o,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">//此时的this指向的是对象o，参数使用逗号隔开</span><br></code></pre></td></tr></table></figure></li><li><p><code>apply(thisArg, [argsArray])</code>：执行这个函数对象，并且使函数运行时的 <code>this</code> 指向 <code>thisArg</code>，<code>argsArray</code> 是向函数传递的参数形成的数组。<code>apply()</code> 多用在数组相关的方法上，通过参数数组一次传入所有参数，不用再需要一个一个传参。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;<br>name: <span class="hljs-string">&#x27;andy&#x27;</span><br>&#125;<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>      <span class="hljs-built_in">console</span>.log(a+b);<br>&#125;;<br>fn()<span class="hljs-comment">// 此时的 this 指向的是 window </span><br>fn.apply(o,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]);<span class="hljs-comment">// 此时的 this 指向的是对象 o，参数使用数组传递 </span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>,arr); <span class="hljs-comment">// 等效 Math.max(1,2,3);</span><br></code></pre></td></tr></table></figure></li><li><p>  <code>bind(thisArg, arg1, arg2, ...)</code>：该方法不会立刻执行函数对象，但是能改变将来函数运行时内部 <code>this</code> 的指向，返回的是改变 <code>this</code> 指向并传递完参数产生的新函数。<code>bind()</code> 多用于改变回调函数中 <code>this</code> 的指向。</p></li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数就是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p><p>在 JavaScript 中，函数也是一种数据类型，函数对象可以作为参数传递给另外一个参数使用或者作为返回值传递回来。 最典型的就是一个函数对象作为参数传入，等待着被回调。</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>在 JavaScript 中，对象是由属性和方法组成的，具体表现为一组无序键值对的集合。</p><p>在典型的 OOP 语言中（如 Java ），都存在类的概念，类就是对象的模板，对象就是类的实例，但在 ES6 标准之前，JavaScript 中并没用引入类的概念，对象不是基于类创建的，而是用一类称为构造函数的特殊函数来定义对象们的共同特征。</p><p>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，构造函数的调用与 <code>new</code> 一起使用。可以把对象中一些公共的属性和方法抽取出来，然使用 <code>this</code> 关键字封装到这个函数里面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><p>通常构造函数的首字母要大写，以和普通函数相区别，但这是一种约定，而不是强制规定。</p><p>实际上构造函数本质上和普通函数一样，都是 <code>Function</code> 对象实例，但是 <code>this</code> 和 <code>new</code> 让它的用法与普通函数有所区别。</p><p>使用 <code>new</code> 调用函数，那么这个函数就是构造函数，就是类模板，如果直接调用就是一个普通函数，其中的 <code>this</code> 指向全局对象。</p><p>使用 <code>new</code> 调用执行构造函数时会做四件事情：</p><ol><li>  在内存中创建一个新的空对象；</li><li>  让构造函数中的 <code>this</code> 指向这个新的对象；</li><li>  执行构造函数里面的代码，给这个新对象添加属性和方法；</li><li>  函数体执行完毕，返回这个新对象（所以构造函数里面不需要 <code>return</code> 关键字手动返回生成的对象）。</li></ol><p>JavaScript 的构造函数中可以添加一些成员，可以在构造函数对象本身上添加，也可以在构造函数内部的 <code>this</code> 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。</p><ul><li>  静态成员：构造函数本身也是一个对象，所以可以为函数添加属性以及方法。在构造函数自身上添加的成员称为静态成员，也称为类成员，只能通过构造函数对象来访问，不能通过实例对象来访问，这一点和 Java 不一样。</li><li>  实例成员：在构造函数内部使用 <code>this</code> 关键字创建的对象成员称为实例成员，只能由实例化的对象来访问。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;               <span class="hljs-comment">// 实例变量</span><br>    <span class="hljs-built_in">this</span>.sing = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;       <span class="hljs-comment">// 实例方法</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;唱歌&quot;</span>);<br>    &#125;<br>&#125;<br>Star.count = <span class="hljs-number">2</span>;             <span class="hljs-comment">// 静态变量，或称类变量</span><br>Star.act = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 静态方法，或称类方法，类方法中不能访问实例成员中的变量</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;演戏&quot;</span>);<br>&#125;<br>Star.act();<br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&quot;刘德华&quot;</span>, <span class="hljs-number">33</span>);<br><span class="hljs-built_in">console</span>.log(ldh.count);     <span class="hljs-comment">// undefined，不能通过实例对象来访问静态成员</span><br><span class="hljs-built_in">console</span>.log(Star.count);    <span class="hljs-comment">// 静态成员只能通过构造函数来访问</span><br></code></pre></td></tr></table></figure><h3 id="原型对象-prototype"><a href="#原型对象-prototype" class="headerlink" title="原型对象 prototype"></a>原型对象 <code>prototype</code></h3><p>由于 JavaScript 中函数也是对象，每次使用构造函数实例化一个新对象时，实例方法也会被分配相应的内存，那么同样的方法在内存中存在多处副本，比较浪费内存。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213821.png" alt="image-20210912200401689"></p><p>JavaScript 规定，每个函数都有一个 <code>prototype</code> 属性，指向一个对象，也称为构造函数的原型对象。对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的 <code>__proto__</code> 属性。</p><p>把实例方法直接定义在构造函数的 <code>prototype</code> 属性上，这样所有对象实例就可以共享同一个方法以节省内存，通过 <code>prototype</code> 原型对象添加的方法也叫原型方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.uname = uname;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>Star.prototype.sing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会唱歌&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">var</span> zxy = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;张学友&#x27;</span>, <span class="hljs-number">19</span>);<br><span class="hljs-comment">// 共享原型对象上的同一个方法</span><br>ldh.sing();<br>zxy.sing();<br></code></pre></td></tr></table></figure><p>通过原型对象，可以对 JavaScript 的内置对象添加自定义的方法。但不要给内置对象的原型对象整体赋值，这样原型对象原有的一些属性被覆盖或者丢失，只能为原型对象添加单个属性。比如给数组增加自定义求偶数和的功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype = &#123; <span class="hljs-attr">sum</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;&#125; <span class="hljs-comment">// 这样会使 Array 类原有的功能丢失</span><br><span class="hljs-built_in">Array</span>.prototype.sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<br>        sum += <span class="hljs-built_in">this</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型 __proto__"></a>对象原型 <code>__proto__</code></h3><p>实例对象都会有一个属性 <code>__proto__</code> 指向构造函数的 <code>prototype</code> 原型对象，之所以实例对象可以使用构造函数 <code>prototype</code> 原型对象的属性和方法，就是因为对象有 <code>__proto__</code> 原型的存在。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213822.png" alt="image-20210912170021936"></p><p>对象原型 <code>__proto__</code> 和原型对象 <code>prototype</code> 是等价的，指向的是同一个对象。</p><p>对象原型 <code>__proto__</code> 的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，避免使用该属性。</p><blockquote><p>  <code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf</code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p></blockquote><h3 id="构造函数-constructor"><a href="#构造函数-constructor" class="headerlink" title="构造函数 constructor"></a>构造函数 <code>constructor</code></h3><p>对象原型 <code>__proto__ </code> 和构造函数原型对象 <code>prototype</code> 里面都有一个 <code>constructor</code> 属性指回构造函数本身，也称之为构造函数属性。<code>constructor</code> 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213824.png" alt="image-20210912170138634"></p><p>一般情况下，对象的实例方法都在构造函数的原型对象 <code>prototype</code> 中设置。如果要通过原型对象一次添加多个实例方法，可以给原型对象采取对象形式赋值。但是这样赋值后，原型对象中原来的一些属性被覆盖或者丢失，其中 <code>constructor</code> 属性就不再指向当前构造函数了。因此应该在修改后的原型对象中，添加一个 <code>constructor</code> 属性指向原来的构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>     <span class="hljs-built_in">this</span>.uname = uname;<br>     <span class="hljs-built_in">this</span>.age = age;<br> &#125;<br> <span class="hljs-comment">// 给原型对象赋值的一个对象一次添加了两个实例方法,但必须手动的利用 constructor 指回原来的构造函数</span><br> Star.prototype = &#123;<br>     <span class="hljs-title">constructor</span>: <span class="hljs-title">Star</span>, // 手动设置指回原来的构造函数<br>     <span class="hljs-title">sing</span>: <span class="hljs-title">function</span>(<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会唱歌&#x27;</span>);<br>     &#125;,<br>     movie: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会演电影&#x27;</span>);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>对象原型 <code>__proto__</code> 的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。 每一个实例对象有一个 <code>__proto__</code> 属性，指向构造函数的原型对象 <code>prototype</code>，构造函数的原型对象也是一个对象，也有  <code>__proto__ </code> 属性指向原型对象的原型，这样一层一层就形成了原型链。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213825.png" alt="image-20210912212344413"></p><p>JavaScript 的原型链查找机制（规则）：</p><ol><li>  当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</li><li>  如果没有就查找它的原型（也就是对象的  <code>__proto__</code> 属性指向的原型对象 <code>prototype</code> ）有没有该属性。</li><li>  如果还没有就查找原型对象的原型，依此类推一直找到 Object 的原型对象为止（Object 对象实例的 <code>__proto__</code> 属性值为 <code>null</code>）。</li></ol><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>大部分面向对象的编程语言，都是通过 <code>extends</code> 实现类的继承。在 ES6 之前，JavaScript 没有提供 <code>extends</code> 继承关键字，但可以通过构造函数和原型对象模拟实现继承，这种继承被称为组合继承。</p><p>借用构造函数继承父类属性的核心原理： 通过 <code>call()</code> 调用父类的构造函数，并把父类型的 <code>this</code> 指向子类型的 <code>this</code> ，这样就可以实现子类继承父类中的属性。</p><p>一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类的原型方法，需要使用到原型对象。</p><p>借用原型对象继承父类方法的核心原理： 让子类的原型指向父类的原型，这样子类对象就可以通过原型链找到父类的方法，即继承了父类的方法。</p><p>组合继承步骤：</p><ol><li>  先定义父构造函数</li><li>  再定义子构造函数 </li><li>  在子类的构造函数中通过 <code>call()</code> 调用父类的构造函数，并把父类型的 <code>this</code> 指向子类型的 <code>this</code> ，这样就可以实现子类继承父类中的属性。</li><li>  让子类的原型对象 <code>prototype</code> 指向一个父类对象实例，这样子类就可以继承父类的方法。</li><li>  将子类的 <code>constructor</code> 属性重新指向子类的构造函数。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1.先定义父构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">uname, age</span>) </span>&#123;<br>    <span class="hljs-comment">// this 指向父构造函数的对象实例</span><br>    <span class="hljs-built_in">this</span>.uname = uname;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-comment">// 父类原型方法</span><br>Father.prototype.money = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;大人要挣钱&quot;</span>);<br>&#125;;<br><span class="hljs-comment">// 2.再定义子构造函数 </span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">uname, age, score</span>) </span>&#123;<br>    <span class="hljs-comment">// 3.使用 call() 调用父类的构造函数，并且让父类的 this 指向子类的 this，同时调用这个函数</span><br>    Father.call(<span class="hljs-built_in">this</span>, uname, age);<br>    <span class="hljs-comment">// this 指向子构造函数的对象实例</span><br>    <span class="hljs-built_in">this</span>.score = score;<br>&#125;<br><span class="hljs-comment">// Son.prototype = Father.prototype 会让父原型对象会跟着子原型对象一起变化。</span><br><span class="hljs-comment">// 4.让子类的原型对象 prototype 指向一个父类对象实例</span><br>Son.prototype = <span class="hljs-keyword">new</span> Father();<br><span class="hljs-comment">// 5.将子类的 constructor 属性重新指向子类的构造函数。</span><br>Son.prototype.constructor = Son;<br><span class="hljs-comment">// 子类原型方法</span><br>Son.prototype.exam = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;孩子要考试&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">console</span>.log(son.uname);<br>son.money();<br></code></pre></td></tr></table></figure><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213826.png" alt="image-20210912232338262"></p><p>让子类的原型对象 <code>prototype</code> 指向一个新创建的父类对象实例，子类对象可以通过 <code>__proto__</code> 属性接找到父类的对象原型 <code>__proto__</code>  中的方法。</p><h2 id="ES5-新特性"><a href="#ES5-新特性" class="headerlink" title="ES5 新特性"></a>ES5 新特性</h2><h3 id="Array-新增方法"><a href="#Array-新增方法" class="headerlink" title="Array 新增方法"></a><code>Array</code> 新增方法</h3><p>下面的遍历数组的方法都接受一个函数作为参数，所有数组成员都会被依次传入该函数执行，其中 <code>currentValue</code> 是当前传入的数组成员的值，<code>index</code> 是传入成员项在数组中的索引，<code>arr</code> 是数组对象本身。</p><ul><li>  <code>map(function(currentValue, index, arr))</code>：将数组的所有成员依次传入参数函数，然后把每一次的执行返回结果组成一个新数组返回。</li><li>  <code>forEach(function(currentValue, index, arr))</code>：<code>forEach()</code>方法与<code>map()</code> 方法很相似，也是对数组的所有成员依次执行参数函数。但是，<code>forEach() </code> 方法不返回值，只用来操作数据，在函数里面 <code>return</code> 也不会终止迭代。这就是说，如果数组遍历的目的是为了得到返回值，那么使用 <code>map() </code>方法，否则使用 <code>forEach()</code> 方法。</li><li>  <code>filter(function(currentValue, index, arr))</code>：用于筛选数组用于过滤数组成员，它的参数是一个函数，所有数组成员依次执行该函数，函数返回为 <code>true</code> 的成员组成一个新数组返回。该方法不会改变原数组。</li><li>  <code>some(function(currentValue, index, arr))</code>：用于检测数组中的是否存在元素满足指定条件，只要一个数组成员的执行该函数的返回值是 <code>true</code>，则整个 <code>some</code> 方法的返回值就是 <code>true</code>，否则返回 <code>false</code>。 如果找到第一个满足条件的元素，则终止循环不在继续查找。</li><li>  <code>every(function(currentValue, index, arr))</code>：用于检测数组中的所有元素，所有成员传入函数执行的返回值都是 <code>true</code>，整个 <code>every</code>方法才返回 <code>true</code>，否则返回<code>false</code>。</li></ul><h3 id="String-新增方法"><a href="#String-新增方法" class="headerlink" title="String 新增方法"></a><code>String</code> 新增方法</h3><ul><li>  <code>trim()</code>：方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括制表符（<code>\t</code>、<code>\v</code>）、换行符（<code>\n</code>）和回车符（<code>\r</code>）。</li></ul><h3 id="Object-方法"><a href="#Object-方法" class="headerlink" title="Object 方法"></a><code>Object</code> 方法</h3><ul><li>  <code>Object.keys(obj)</code>：获取到对象中的属性名，返回值是一个数组，该数组的成员都是该对象自身的（不包括继承的）所有属性名。返回的数组配合数组 <code>foeEach()</code> 方法可以遍历原对象。</li><li>  <code>Object.defineProperty(obj, prop, descriptor)</code>：定义新属性或修改原有的属性，<code>obj</code> 是待修改的目标对象，<code>prop</code> 是需新增或修改的属性的名字，<code>descriptor</code> 描述对象用来说明目标属性所拥有的特性，描述对象有四个子属性，<code>value</code> 是要赋给目标属性的值。 <code>writable</code> 决定目标属性值是否可以重写。如果该属性值为 <code>false</code>，则不允许再修改对象中的这个属性值。 <code>enumerable</code> 决定目标属性是否可以被枚举遍历，如果值为 <code>false</code> 则不允许遍历。<code>configurable</code> 决定目标属性是否可以被删除或是否可以再次修改特性，如果为 <code>false</code> 则不允许使用 <code>delete</code> 删除这个属性。</li></ul><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES5 提供了严格模式（strict mode）即在严格的条件下运行 JavaScript 代码。严格模式在 IE 10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。严格模式对正常的 JavaScript 语义做了一些更改：</p><ol><li>消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为，例如未声明就使用变量。</li><li>消除代码运行的一些不安全之处，保证代码运行的安全。</li><li>提高编译器效率，增加运行速度。</li><li>禁用了在 ECMAScript 的未来版本中可能会重新定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：<code>class</code>、<code>enum</code>、<code>export</code>、 <code>extends</code>、<code>import</code>、<code>super</code> 不能做变量名。</li></ol><p>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先用声明，然后再使用，并且禁止使用 <code>delete</code> 删除已经声明变量。</p><p>严格模式中函数形参列表中不能有重名的参数，并且函数必须声明在顶层，不允许在非函数的代码块内声明函数。为了与新版本（ ES6 中已引入）即将引入的块级作用域。</p><p>严格模式下 <code>this</code> 指向问题：</p><ol><li>  以前在全局作用域函数中的 <code>this</code> 指向全局对象（浏览器中是 <code>window</code> 对象），严格模式下全局作用域中函数中的 <code>this</code> 是 <code>undefined</code>。</li><li>  以前构造函数时也可以当作普通函数不加 <code>new</code> 调用，其中<code>this</code> 指向全局对象。严格模式下,如果构造函数不加 <code>new</code> 调用，由于 <code>this</code> 指向的是 <code>undefined</code> 构造函数汇中给 <code>this</code> 添加属性的操作则会报错</li><li>  其他类型函数中 <code>this</code> 和普通模式一样，<code>new</code> 调用构造函数中 this 指向创建的对象实例，定时器函数 <code>this</code> 指向全局对象（浏览器中是 <code>window</code> 对象），回调函数中 <code>this</code> 指向调用者。</li></ol><p>严格模式的更多要求请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">MDN：严格模式</a>。</p><p>严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。</p><ul><li><p>为脚本开启严格模式：在脚本的第一行，所有语句之前添加一行特定语句<code>&quot;use strict&quot;;</code> 或 <code>&#39;use strict&#39;;</code>，老版本的浏览器会把该行它当作一行普通字符串表达式而忽略。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-meta">    &quot;use strict&quot;</span>;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是严格模式&quot;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>为函数开启严格模式：把特定语句<code>&quot;use strict&quot;;</code> 或 <code>&#39;use strict&#39;;</code>放在函数体所有语句之前，整个函数以 “严格模式” 运行。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-meta">    &quot;use strict&quot;</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是严格模式&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当有多个脚本文件需要合并时，可能其中有的脚本是严格模式，有的脚本是正常模式。可以将整个脚本文件中的代码放在一个立即执行的匿名函数之中，再在函数体所有语句之前添加严格模式声明，这样就不影响其他未开启严格模式的脚本文件。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-meta">        &quot;use strict&quot;</span>;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是严格模式&quot;</span>);</span><br>    &#125;)();<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h2><p>ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化规范。ES6 实际上是一个泛指，泛指 ES2015 及后续的版本。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213827.png" alt="image-20210916183052538"></p><h3 id="let-关键字"><a href="#let-关键字" class="headerlink" title="let 关键字"></a><code>let</code> 关键字</h3><p><code>let</code> 是 ES6 中新增的用于声明变量的关键字，<code>let</code> 声明的变量只在所处于的块级有效。</p><p>使用 let 关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// b is not defined</span><br></code></pre></td></tr></table></figure><p>使用 <code>let</code> 声明的变量不存在变量提升，必须先声明再使用，声明语句前访问会出现引用错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// ReferenceError: Cannot access &#x27;b&#x27; before initialization</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>使用 <code>let</code> 声明的变量可能在代码块中存在一段临时性死区，全局作用域的同名变量也不能在死区之中访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">20</span><br>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">// 10</span><br>    <span class="hljs-built_in">console</span>.log(b);<span class="hljs-comment">// ReferenceError: Cannot access &#x27;b&#x27; before initialization 尽管全局作用域的 b</span><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">200</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a><code>const</code> 关键字</h3><p><code>const</code> 关键字用来声明常量，<code>const</code> 和 <code>let</code> 一样，具有块级作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">const</span> b = <span class="hljs-number">20</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// b is not defined</span><br></code></pre></td></tr></table></figure><p>由于 <code>const</code> 常量赋值后不可再更改，因此声明常量时就必须赋值，初始化常量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PI; <span class="hljs-comment">// Missing initializer in const declaration</span><br></code></pre></td></tr></table></figure><p>常量就是值在第一次赋值初始化后不能再变化的量。具体来说，如果是基本数据类型，其存储的值不能更改，如果是复杂数据类型，由于其存储的是对象的引用地址，则不可再指向其他对象，但是对象中的值可以改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.14</span>;<br>PI = <span class="hljs-number">100</span>; <span class="hljs-comment">// Assignment to constant variable.</span><br><br><span class="hljs-keyword">const</span> ary = [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>];<br>ary[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>ary[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(ary); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;]; </span><br>ary = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]; <span class="hljs-comment">// Assignment to constant variable.</span><br></code></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6 中允许在数组、对象中按照对应位置提取值，然后对变量赋值。如果变量跟数组元素个数或者对象属性个数不匹配的时候，则部分结构不成功，未匹配变量的值为 <code>undefined</code>。</p><p>数组解构用中括号包裹，对象解构用花括号包裹，多个变量用逗号隔开。利用解构赋值能够很方便的提取对象中的属性跟方法。</p><p>数组解构赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(c) <span class="hljs-comment">// 如果解构不成功，变量的值为undefined</span><br></code></pre></td></tr></table></figure><p>对象解构赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;; <br><span class="hljs-keyword">let</span> &#123; name, age &#125; = person;<br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// &#x27;zhangsan&#x27; </span><br><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// 20</span><br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">name</span>: myName, <span class="hljs-attr">age</span>: myAge&#125; = person; <span class="hljs-comment">// myName myAge 属于别名</span><br><span class="hljs-built_in">console</span>.log(myName); <span class="hljs-comment">// &#x27;zhangsan&#x27; </span><br><span class="hljs-built_in">console</span>.log(myAge); <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数是 ES6  新增的定义匿名函数的方式，箭头函数表达式的语法比函数表达式更简洁。</p><p>小括号中是形参列表，大括号是函数体。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">() =&gt; &#123;&#125;<br><span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>如果函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">num1, num2</span>) </span>&#123; <br>    <span class="hljs-keyword">return</span> num1 + num2; <br>&#125;<br><span class="hljs-comment">// ES6 箭头函数省略写法</span><br><span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">num1, num2</span>) =&gt;</span> num1 + num2; <br></code></pre></td></tr></table></figure><p>如果形参只有一个，可以省略小括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">v</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> v;<br>&#125; <br><span class="hljs-comment">// ES6 箭头函数省略写法</span><br><span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v;<br></code></pre></td></tr></table></figure><p>箭头函数不绑定 <code>this</code> ，<code>arguments</code>，<code>super</code> 关键字，因此箭头函数只能作为普通函数不能作为类的构造函数使用。</p><p>箭头函数中的 <code>this</code>，指向的是函数定义位置的上下文中的 <code>this</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.age = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    age: <span class="hljs-number">20</span>,<br>    say: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age);<br>    &#125;<br>&#125;<br>obj1.say();<span class="hljs-comment">//100，箭头函数 this 指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是 this 指向的是全局作用域中的 this</span><br><br><span class="hljs-keyword">var</span> obj2 = &#123;<br>    name: <span class="hljs-string">&quot;张三&quot;</span>,<br>    fn: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<span class="hljs-comment">// this 指向 是 obj 对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 箭头函数中没有自己的 this，根据作用域链向上查找，即是 fn 的 this </span><br>        &#125;<br>    &#125;<br>&#125;<br>obj2.fn()();<br></code></pre></td></tr></table></figure><p>使用箭头函数可以解决匿名函数 <code>this</code> 指向的问题，例如定时器中的回调函数中的 <code>this</code> 往往默认指向全局对象，此前只能手动更改其中 <code>this</code> 的指向或者使用额外的变量来传递 <code>tihs</code>，现在可以直接使用箭头函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;<br>  that.age = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">growUp</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 回调引用的是 that 变量, 其值是预期的对象.</span><br>    that.age++;<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">// ES6 箭头函数写法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.age = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.age++; <span class="hljs-comment">// this 指向构造函数创新的新对象</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person();<br></code></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数语法允许将一些不定数量的参数表示为一个数组，这种方式很方便的去声明不知道参数情况下的一个函数，ES 6 之前要通过 <code>arguments</code> 对象来获取实参，比较麻烦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">first, ...args</span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(first); <span class="hljs-comment">// 10</span><br>     <span class="hljs-built_in">console</span>.log(args); <span class="hljs-comment">// [20, 30] </span><br> &#125;<br> sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>剩余参数还可以和解构赋值一起使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> students = [<span class="hljs-string">&#x27;wangwu&#x27;</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>];<br><span class="hljs-keyword">let</span> [s1, ...s2] = students; <br><span class="hljs-built_in">console</span>.log(s1);  <span class="hljs-comment">// &#x27;wangwu&#x27; </span><br><span class="hljs-built_in">console</span>.log(s2);  <span class="hljs-comment">// [&#x27;zhangsan&#x27;, &#x27;lisi&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串是 ES6 新增的创建字符串的方式，模板字符串使用反引号来代替普通字符串中的用双引号和单引号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">`zhangsan`</span>;<br><span class="hljs-keyword">let</span> name = <span class="hljs-string">`zhangsan`</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> name);           <span class="hljs-comment">// string</span><br><span class="hljs-built_in">console</span>.log(name === <span class="hljs-string">&quot;zhangsan&quot;</span>);   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>模板字符串中可以直接换行，不需要转义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`string text line 1</span><br><span class="hljs-string">string text line 2`</span>);<br><span class="hljs-comment">// &quot;string text line 1</span><br><span class="hljs-comment">// string text line 2&quot;</span><br></code></pre></td></tr></table></figure><p>模板字符串中可以使用 <code>$&#123; &#125;</code> 占位符嵌入表达式，表达式可以是一个简单的变量、运算操作、函数调用，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;张三&#x27;</span>; <br><span class="hljs-keyword">let</span> sayHello = <span class="hljs-string">`my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>; <span class="hljs-comment">// my name is zhangsan</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`a + b = <span class="hljs-subst">$&#123;a + b&#125;</span>`</span>); <span class="hljs-comment">// a + b = 15</span><br><br><span class="hljs-keyword">const</span> sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;sayHello()&#125;</span>`</span>); <span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列，又称为展开语法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> ...ary  <span class="hljs-comment">// 1, 2, 3</span><br> <span class="hljs-built_in">console</span>.log(...ary);    <span class="hljs-comment">// 1 2 3,相当于下面的代码</span><br> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">x, y, z</span>) </span>&#123; &#125;<br><span class="hljs-keyword">var</span> args = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>myFunction(...args);<br></code></pre></td></tr></table></figure><p>使用展开语法合并两个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ary1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> ary2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-comment">// 方法一 </span><br>ary1 = [...ary1, ...ary2];<br><span class="hljs-comment">// 方法二 </span><br>ary1.push(...ary2);<br><span class="hljs-comment">// 方法三  apply() 方法</span><br>ary1.push.apply(ary1, ary2)<br></code></pre></td></tr></table></figure><p>将伪数组或者可迭代对象转换为真正的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> oDivs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>); <br>oDivs = [...oDivs];<br></code></pre></td></tr></table></figure><h3 id="Array-新增方法-1"><a href="#Array-新增方法-1" class="headerlink" title="Array 新增方法"></a><code>Array</code> 新增方法</h3><ul><li><p><code>Array.isArray()</code> ：可以判断一个对象是不是真正的数组，真正的数组对象在生成对象的时候就必须是一个数组。将一个伪数组的 <code>__proto__</code> 直接或间接指向 <code>Array.prototye</code>，就可以调用数组相关方法，但严格来说并不是一个真正的数组。<code>obj instanceof Array</code> 为 <code>ture</code> 不能保证就是真正的数组。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个伪数组对象</span><br><span class="hljs-keyword">let</span> arrayLike = &#123;<br>    <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>    <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>    <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>,<br>    length: <span class="hljs-number">3</span><br>&#125;;<br>arrayLike.__proto__ = <span class="hljs-built_in">Array</span>.prototype;<br><span class="hljs-built_in">console</span>.log(arrayLike <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);    <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(arrayLike));      <span class="hljs-comment">// false</span><br>arrayLike.push(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">console</span>.log(arrayLike);                     <span class="hljs-comment">// Array &#123; &#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#x27;b&#x27;, &#x27;2&#x27;: &#x27;c&#x27;, &#x27;3&#x27;: 5, length: 4 &#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>Array.from()</code>：将伪数组对象或可迭代对象转换为真正的数组，伪数组对象的属性名必须是对应的索引值，并且必须要有 <code>length</code> 属性。将伪数组转换为真正数组之后就可以调用数组专属方法例如 <code>push()</code>、<code>pop()</code> 等。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个伪数组对象</span><br><span class="hljs-keyword">let</span> arrayLike = &#123;<br>    <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>    <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-string">&#x27;d&#x27;</span>,<br>    length: <span class="hljs-number">5</span><br>&#125;;<br><span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.from(arrayLike);            <span class="hljs-comment">//  将伪数组转成数组</span><br><span class="hljs-built_in">console</span>.log(arrayLike <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);    <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(arrayLike));      <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);          <span class="hljs-comment">// ture</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(arr));            <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(arr);                           <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, undefined, &#x27;d&#x27;, undefined ]</span><br></code></pre></td></tr></table></figure><p>  该方法还可以接受第二个参数，作用类似于数组的 <code>map()</code> 方法，用来对伪数组中每个元素进行处理，将处理后的值放入返回的数组。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arrayLike = &#123; <br>    <span class="hljs-string">&quot;0&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;length&quot;</span>: <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">let</span> newAry = <span class="hljs-built_in">Array</span>.from(arrayLike, <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item *<span class="hljs-number">2</span>)<span class="hljs-comment">// [2,4]</span><br></code></pre></td></tr></table></figure></li><li><p><code>find()</code>：用于找出第一个符合条件的数组成员，如果没有找到返回 <code>undefined</code>。通过传入函数对象对数组元素进行遍历，如果找到第一个满足条件的元素，则终止循环不在继续查找，类似数组对象的 <code>some() </code> 方法，区别是 <code>some()</code> 返回布尔值，<code>find()</code> 返回查找到的元素。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ary = [&#123;<br>    id: <span class="hljs-number">1</span>,<br>    name: <span class="hljs-string">&#x27;张三&#x27;</span><br>&#125;, &#123; <br>    id: <span class="hljs-number">2</span>,<br>    name: <span class="hljs-string">&#x27;李四&#x27;</span><br>&#125;]; <br> <span class="hljs-keyword">let</span> target = ary.find(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> item.id == <span class="hljs-number">2</span>); <span class="hljs-comment">// 找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个</span><br></code></pre></td></tr></table></figure></li><li><p><code>findIndex()</code>：用于找出第一个符合条件的数组成员的位置，如果没有找到返回 -1。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];<br><span class="hljs-keyword">let</span> index = ary.findIndex(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> value &gt; <span class="hljs-number">9</span>); <br><span class="hljs-built_in">console</span>.log(index); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li><li><p><code>includes()</code>：表示某个数组是否包含给定的值，返回布尔值。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">2</span>) <span class="hljs-comment">// true </span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">4</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="String-新增方法-1"><a href="#String-新增方法-1" class="headerlink" title="String 新增方法"></a>String 新增方法</h3><ul><li><p><code>startsWith(searchString[, position])</code>：用来判断当前字符串是否以另外一个给定的子字符串开头，返回布尔值。第一个参数是要搜索的子字符串。第二个参数搜索的开始位置，默认值为 0。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;To be, or not to be, that is the question.&quot;</span>;<br>alert(str.startsWith(<span class="hljs-string">&quot;To be&quot;</span>));         <span class="hljs-comment">// true</span><br>alert(str.startsWith(<span class="hljs-string">&quot;not to be&quot;</span>));     <span class="hljs-comment">// false</span><br>alert(str.startsWith(<span class="hljs-string">&quot;not to be&quot;</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><code>endsWith(searchString[, length])</code>：用来判断当前字符串是否以另外一个给定的子字符串结尾，返回布尔值。第一个参数是要搜索的子字符串。第二个参数作为字符串的长度以判断字符串是否在结尾，默认值为被搜索字符串的长度。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;To be, or not to be, that is the question.&quot;</span>;<br>alert( str.endsWith(<span class="hljs-string">&quot;question.&quot;</span>) );  <span class="hljs-comment">// true</span><br>alert( str.endsWith(<span class="hljs-string">&quot;to be&quot;</span>) );      <span class="hljs-comment">// false</span><br>alert( str.endsWith(<span class="hljs-string">&quot;to be&quot;</span>, <span class="hljs-number">19</span>) );  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><code>repeat(n)</code>：方法表示将原字符串重复 n 次，返回一个新字符串。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x&#x27;</span>.repeat(<span class="hljs-number">3</span>))      <span class="hljs-comment">// &quot;xxx&quot; </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>.repeat(<span class="hljs-number">2</span>))  <span class="hljs-comment">// &quot;hellohello&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a><code>Set</code> 集合</h3><p>ES6 提供了新的数据结构 <code>Set</code> 集合。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>使用 <code>Set</code> 构造函数用来生成  <code>Set</code>  对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br></code></pre></td></tr></table></figure><p><code>Set()</code> 构造函数可以接受一个数组作为参数，用来初始化集合，并且自动去掉数组汇总重复的元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-built_in">console</span>.log(set);   <span class="hljs-comment">// Set(4) &#123; 1, 2, 3, 4 &#125;</span><br></code></pre></td></tr></table></figure><ul><li>  <code>add(value)</code>：在 <code>Set  </code> 对象尾部添加一个元素。返回该 <code>Set</code> 对象。</li><li>  <code>delete(value)</code>：移除 <code>Set </code> 中与这个值相等的元素，返回一个布尔值，表示删除是否成功。根据值相等删除而不是索引。</li><li>  <code>has(value)</code>：返回一个布尔值，表示该元素是否为 Set 对象的成员。</li><li>  <code>clear()</code>：清除所有成员，没有返回值。</li><li>  <code>forEach(callback[, thisArg])</code>：根据集合中元素的插入顺序，对所有元素依次执行提供的回调函数，用来遍历集合元素。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">3</span>);     <span class="hljs-comment">// 向 Set 集合中添加元素，可以使用链式编程 </span><br>s.delete(<span class="hljs-number">2</span>);                <span class="hljs-comment">// 删除 Set 集合中值为 2 的元素，根据值来删除  </span><br>s.has(<span class="hljs-number">1</span>);                   <span class="hljs-comment">// 判断 Set 集合中是否有值为 1 的元素</span><br>s.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(value)); <span class="hljs-comment">// 遍历输出 Set 集合中所有的元素</span><br>s.clear();                  <span class="hljs-comment">// 清除 Set 集合中的所有元素</span><br></code></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。</p><p>前端中的正则表达式主要用来：</p><ul><li>  对表单中用户输入的内容进行合法性验证；</li><li>  提取大段文本中特定的字符串；</li><li>  对文本内容的敏感内容进行查找替换。</li></ul><p>在 JavaScript 中，正则表达式也是一种对象，可以通过两种方式创建一个正则表达式。</p><ul><li><p>直接通过用斜杠 <code>/</code> 包裹起来的的字面量创建正则表达式：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/123/</span>;<br></code></pre></td></tr></table></figure></li><li><p>通过调用 RegExp 对象的构造函数创建：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> rg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/123/</span>);<br><span class="hljs-keyword">var</span> rg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;123&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>正则表达式对象的 <code>test()</code> 方法用来检测字符串是否符合该正则表达式规范，该方法会返回 <code>true</code> 或 <code>false</code>，其参数是测试字符串，如果是其他类型会自动转换为字符串类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/123/</span>;<br><span class="hljs-built_in">console</span>.log(re.test(<span class="hljs-number">123</span>));<span class="hljs-comment">// 自动转换为字符串类型，true</span><br><span class="hljs-built_in">console</span>.log(re.test(<span class="hljs-string">&#x27;abc&#x27;</span>));<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，更多特殊字符请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">MDN：正则表达式</a>。</p><ul><li><p>边界符（位置符）：用来提示字符所处的位置，主要有两个字符：</p><ul><li><p>  <code>^</code>：表示匹配行首的文本（以谁开始）</p></li><li><p><code>$</code>：表示匹配行尾的文本（以谁结束）</p><p>如果 <code>^</code> 和 <code>$</code> 在一起使用，表示必须是精确匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/abc/</span>; <span class="hljs-comment">// 正则表达式里面不需要加引号 不管是数字型还是字符串型</span><br><span class="hljs-comment">// /abc/ 只要包含有abc这个字符串返回的都是true</span><br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;abc&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;abcd&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;aabcd&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------------------------&#x27;</span>);<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^abc/</span>;<br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;abcd&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;aabcd&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------------------------&#x27;</span>);<br><span class="hljs-keyword">var</span> reg1 = <span class="hljs-regexp">/^abc$/</span>; <span class="hljs-comment">// 精确匹配 要求必须是 abc字符串才符合规范</span><br><span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;abc&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;abcd&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;aabcd&#x27;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(reg1.test(<span class="hljs-string">&#x27;abcabc&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>[]</code>：字符组合，所有可供选择的字符都放在方括号内，包括方括号中的任意一个字符即匹配成功。方括号内部加上 <code>-</code> 表示范围，例如，<code>/[abcd]/</code> 和 <code>/[a-d]/</code> 是一样的，方括号内部头上的 <code>^</code> 表示取反，只要包含方括号内的任一字符，都匹配失败。特殊符号在字符组合中没有特殊的意义，不需要再转义，<code>/[a|b]/</code> 相当于 <code>/a|\||b/</code>。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/[abc]/</span>; <span class="hljs-comment">// 只要包含有a 或者 包含有b 或者包含有c 都返回为true</span><br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;andy&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;baby&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;color&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg.test(<span class="hljs-string">&#x27;red&#x27;</span>));<span class="hljs-comment">//false</span><br><br><span class="hljs-keyword">var</span> rg1 = <span class="hljs-regexp">/^[abc]$/</span>; <span class="hljs-comment">// 三选一 只有是a 或者是 b  或者是c 这三个字母才返回 true</span><br><span class="hljs-built_in">console</span>.log(rg1.test(<span class="hljs-string">&#x27;aa&#x27;</span>));<span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(rg1.test(<span class="hljs-string">&#x27;a&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg1.test(<span class="hljs-string">&#x27;b&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg1.test(<span class="hljs-string">&#x27;c&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(rg1.test(<span class="hljs-string">&#x27;abc&#x27;</span>));<span class="hljs-comment">//true</span><br><br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^[a-z]$/</span> <span class="hljs-comment">//26个英文字母任何一个字母返回 true  - 表示的是a 到z 的范围  </span><br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;a&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;z&#x27;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(reg.test(<span class="hljs-string">&#x27;A&#x27;</span>));<span class="hljs-comment">//false</span><br><br><span class="hljs-comment">//字符组合</span><br><span class="hljs-keyword">var</span> reg1 = <span class="hljs-regexp">/^[a-zA-Z0-9]$/</span>; <span class="hljs-comment">// 26个英文字母(大写和小写都可以)任何一个字母返回 true  </span><br><span class="hljs-comment">//取反 方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。</span><br><span class="hljs-keyword">var</span> reg2 = <span class="hljs-regexp">/^[^a-zA-Z0-9]$/</span>;<br><span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;a&#x27;</span>));<span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;B&#x27;</span>));<span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-number">8</span>));<span class="hljs-comment">//false</span><br><span class="hljs-built_in">console</span>.log(reg2.test(<span class="hljs-string">&#x27;!&#x27;</span>));<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure></li><li><p>量词符：量词符用来设定某个模式出现的次数，<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213828.png" alt="image-20210916175110033"></p></li><li><p>预定义类：预定义类指的是某些常见模式的简写方式。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213829.png" alt="image-20210916175427867"></p></li><li><p>  <code>()</code>：分组括号，提升了优先级，并且在之后可以提取括号内容所匹配的字符串。</p></li><li><p>  <code>|</code>：选择符号，在几项之选择匹配一项，<code>/[ab]/</code> 等价于 <code>/a|b/</code> 。<code>/(a|b|c)/</code> 和 <code>/[abc]/</code> 在匹配效果上是等价的，但是前者中的小括号具有捕获引用功能，可以提取子匹配，而后者没有。<code>/(?:a|b|c)/</code> 和 <code>/[abc]/</code> 则是完全等价，参考<a href="https://stackoverflow.com/questions/9801630/what-is-the-difference-between-square-brackets-and-parentheses-in-a-regex">正则表达式中方括号和小括号的区别</a>。</p></li></ul><p>在正则表达式结尾可以通过修饰符来指定按照什么样的模式来匹配，常用的有以下三种修饰符组合：</p><ul><li>  g：全局匹配</li><li>  i：忽略大小写</li><li>  gi：全局匹配 + 忽略大小写</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/abc/g</span>;<br><span class="hljs-keyword">var</span> re = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>);<br></code></pre></td></tr></table></figure><p>正则表达式配合字符串的 <code>replace(regexp/substr, replacement)</code> 方法可以实现替换字符串操作，该方法传入的第一个参数可以是一个字符串或是一个正则表达式，第二个参数是要替代的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;andy和red&#x27;</span>;<br><span class="hljs-keyword">var</span> newStr = str.replace(<span class="hljs-string">&#x27;andy&#x27;</span>, <span class="hljs-string">&#x27;baby&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(newStr)<span class="hljs-comment">//baby和red</span><br><span class="hljs-comment">//等同于 此处的andy可以写在正则表达式内</span><br><span class="hljs-keyword">var</span> newStr2 = str.replace(<span class="hljs-regexp">/andy/</span>, <span class="hljs-string">&#x27;baby&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(newStr2)<span class="hljs-comment">//baby和red</span><br><span class="hljs-comment">//全部替换</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abcabc&#x27;</span><br><span class="hljs-keyword">var</span> nStr = str.replace(<span class="hljs-regexp">/a/</span>,<span class="hljs-string">&#x27;哈哈&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(nStr) <span class="hljs-comment">//哈哈bcabc</span><br><span class="hljs-comment">//全部替换g</span><br><span class="hljs-keyword">var</span> nStr = str.replace(<span class="hljs-regexp">/a/</span>a,<span class="hljs-string">&#x27;哈哈&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(nStr) <span class="hljs-comment">//哈哈bc哈哈bc</span><br><span class="hljs-comment">//忽略大小写i</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;aAbcAba&#x27;</span>;<br><span class="hljs-keyword">var</span> newStr = str.replace(<span class="hljs-regexp">/a/gi</span>,<span class="hljs-string">&#x27;哈哈&#x27;</span>)<span class="hljs-comment">//&quot;哈哈哈哈bc哈哈b哈哈&quot;</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>  <a href="https://www.bilibili.com/video/BV1Kt411w7MP">JavaScript 进阶面向对象ES6</a></li><li>  <a href="https://wangdoc.com/javascript/">阮一峰：JavaScript 教程</a></li><li>  <a href="https://zhuanlan.zhihu.com/p/23987456">方应杭：JS 的 new 到底是干什么的? </a></li><li>  <a href="https://zhuanlan.zhihu.com/p/23090041">方应杭：「每日一题」什么是 JS 原型链？</a></li><li>  <a href="https://zhuanlan.zhihu.com/p/23804247">方应杭：this 的值到底是什么？一次说清楚</a></li><li>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN：箭头函数</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript Web API 学习笔记</title>
    <link href="/2021/03/10/JavaScript%20Web%20API/"/>
    <url>/2021/03/10/JavaScript%20Web%20API/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Web-API-简介"><a href="#Web-API-简介" class="headerlink" title="Web API 简介"></a>Web API 简介</h2><p>API（Application Programming Interface，应用程序编程接口）指的是一些函数，这些函数对一些常用功能进行了封装，专门用来方便程序员在此基础上做开发，而不用重复造轮子。</p><p>例如 C 语言中有一个函数 <code>fopen()</code>，通过此函数接口可以打开硬盘上的文件，Java 中的 JDK 中各种函数，这些函数库可能由编程语言提供，也可能由一些第三方软件厂商提供，我们无需访问源码了解内部实现细节，只需要阅读 API 手册引用了对应的库文件就可以直接调用函数使用特定的功能。</p><p>Web API 特指的是浏览器厂商提供的一套用来操作浏览器和 HTML 页面中的元素的 API，以方便程序员在此基础上开发 Web 应用程序或网站。</p><p>Web  API 根据操作对象不同又可以分为 DOM 和 BOM 两大类，Web API 主要用于 JavaScript，但也可能有例外。所有的 API 列表可以查阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API">MDN：Web  API 列表</a>。</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML 或者 XML）的标准编程接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。</p><p>把 HTML 或 XML 文档解析映射成树形结构，这棵树称为 DOM 树，又称为文档树模型，这样可以更加方便对各个节点对象处理。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212932.png" alt="1550731974575"></p><ul><li>文档：一整个 HTML 页面就是一个文档，DOM 中使用 document 表示。</li><li>节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用 node 表示。</li><li>标签节点：又称为元素节点，简称为“元素”，文档中的所有 HTML 标签括包裹起来的内容，使用 element 表示。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212934.png" alt="img"></p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>如果我们想要操作网页上的某部分内容，需要先获取到该部分对应的元素，才能对其进行操作。</p><ul><li><p>根据 ID 获取：使用 <code>getElementById()</code> 方法可以根据元素 ID 属性值获取元素对象，因为 ID 属性值在整个文档中应该是唯一或者不存在的，这个方法返回的一个 HTML 对象 或 null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div id=<span class="hljs-string">&quot;year&quot;</span>&gt;<span class="hljs-number">2021</span>&lt;/div&gt;<br>    &lt;!-- 因为我们文档页面从上往下加载，所以所以我们 script 写到元素的下面,否则将获取不到元素 --&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> time = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;year&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(time);<br>        <span class="hljs-comment">// 使用 console.dir() 可以打印对象里面的属性和方法详细信息</span><br>        <span class="hljs-built_in">console</span>.dir(time);<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure></li><li><p>根据标签名获取：使用 <code>getElementsByTagName()</code> 方法可以返回带有指定标签名的对象的集合，以伪数组的形式存储,想要操作里面的元素常常需要遍历伪数组。即使整个文档只有一个该标签节点，返回的仍是伪数组而不是直接返回唯一的元素对象，如果整个文档没有这个标签节点，返回的是空的伪数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div&gt;<br>        &lt;ul&gt;<br>            &lt;li&gt;&lt;/li&gt;<br>            &lt;li&gt;&lt;/li&gt;<br>            &lt;li&gt;&lt;/li&gt;<br>        &lt;/ul&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> divs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(divs);<br>        <span class="hljs-built_in">console</span>.log(divs[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 获取某个元素（父元素）内部所有指定标签名的子元素.</span><br>        <span class="hljs-keyword">var</span> lis = divs[<span class="hljs-number">0</span>].getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(lis);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.length; i++) &#123;<br>            <span class="hljs-built_in">console</span>.log(lis[i]);<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure></li><li><p>根据类名获取：使用 <code>getElementsByClassName()</code> 方法根据元素的 class 属性值返回元素对象的伪数组集合，此方法是 HTML5 新增的方法，可能存在兼容性问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;box&quot;</span>&gt;盒子<span class="hljs-number">1</span>&lt;/div&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;box&quot;</span>&gt;盒子<span class="hljs-number">2</span>&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> boxs = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;box&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(boxs);<br>&lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure></li><li><p>根据选择器获取：使用 <code>querySelector()</code> 方法返回指定选择器的第一个元素对象，使用  <code>querySelectorAll()</code> 方法返回指定选择器的所有元素对象的伪数组集合。传入的选择器字符串不要忘了带上符号，例如 .box  #nav，这两个方法也是 HTML5 新增的方法，可能存在兼容性问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div id=<span class="hljs-string">&quot;nav&quot;</span>&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;box&quot;</span>&gt;盒子<span class="hljs-number">1</span>&lt;/div&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;box&quot;</span>&gt;盒子<span class="hljs-number">2</span>&lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> nav = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#nav&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(nav);<br>        <span class="hljs-keyword">var</span> boxs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.box&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(boxs);<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure></li><li><p>获取特殊元素：可以根据 document 对象的某些属性直接获取特殊元素对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">doucumnet.body <span class="hljs-comment">// 返回body元素对象</span><br><span class="hljs-built_in">document</span>.documentElement <span class="hljs-comment">// 返回html元素对象</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="JavaScript-事件"><a href="#JavaScript-事件" class="headerlink" title="JavaScript 事件"></a>JavaScript 事件</h3><p>事件是可以被 JavaScript 侦测到的行为。</p><p>网页中的每个元素都可以触发某些 JavaScript 事件，例如，用户鼠标点击某元素，鼠标滑过某元素，当事件发生时，然后去执行某些操作。</p><p>常见的鼠标事件：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212935.png" alt="1550734506084"></p><p>事件三要素：</p><ul><li>事件源（谁）：触发事件的 HTML 元素对象。</li><li>事件类型（什么事件）： 如何触发事件，比如鼠标点击元素，鼠标经过元素，键盘某个键按下。</li><li>事件处理程序（做啥）：事件触发后要执行的函数代码，即事件处理函数，可以通过给元素的事件属性赋函数值的来注册事件。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div&gt;<span class="hljs-number">123</span>&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-comment">// 1. 获取事件源</span><br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        <span class="hljs-comment">// 2.绑定事件处理程序 </span><br>        div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我被选中了&#x27;</span>);<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="操作元素属性"><a href="#操作元素属性" class="headerlink" title="操作元素属性"></a>操作元素属性</h3><p>使用 DOM API 可以获得页面中 HTML 元素对象的属性，通过修改这些属性可以动态改变网页内容、结构和样式。</p><p>常见的元素属性有 innerText、innerHTML、src、href、id、alt、title、type、value、checked、selected、disabled、style、className 等。</p><p>innerText、innerHTML 两个属性用来改变元素的内容，两者的区别是 innerText 不会识别 HTML 标签，而 innerHTML 会识别 HTML 标签。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div id=<span class="hljs-string">&quot;box1&quot;</span>&gt;box&lt;strong&gt;<span class="hljs-number">1</span>&lt;<span class="hljs-regexp">/strong&gt;&lt;/</span>div&gt;<br>    &lt;div id=<span class="hljs-string">&quot;box2&quot;</span>&gt;box&lt;strong&gt;<span class="hljs-number">2</span>&lt;<span class="hljs-regexp">/strong&gt;&lt;/</span>div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.body);<br>        <span class="hljs-keyword">var</span> box1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;box1&#x27;</span>);<br>        <span class="hljs-keyword">var</span> box2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;box2&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(box1.innerText);<span class="hljs-comment">// box1</span><br>        <span class="hljs-built_in">console</span>.log(box2.innerHTML);<span class="hljs-comment">// box&lt;strong&gt;2&lt;/strong&gt;</span><br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>通过 style 属性及其中的子属性可以直接修改元素的的行内样式表，优先级很高。注意 style 属性的子属性名遵循驼峰命名法，比如 fontSize  对应 CSS 中的 font-size 、backgroundColor 对应 CSS 中的 background-color。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;img src=<span class="hljs-string">&quot;images/tao.png&quot;</span> alt=<span class="hljs-string">&quot;&quot;</span>&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;img&#x27;</span>);<br>        img.style.width = <span class="hljs-string">&quot;300px&quot;</span>;<br>        <span class="hljs-comment">// img.style = &#x27;width:300px&#x27;; 与上面等效</span><br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>在 JavaScript 中 class 是个保留字，因此使用元素对象的 className 属性来操作 HTML 元素的 class 属性值。修改元素的类名从而匹配 CSS 文件中预先写好不同类选择器样式表是更为常见的修改样式做法。注意 className 会直接更改元素的类名，会覆盖原先的类名，如果想要添加新的样式，应该在原来的类名字符串后面拼接新的样式类名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.className += <span class="hljs-string">&#x27;newclass&#x27;</span>;<br></code></pre></td></tr></table></figure><p>classList 属性是 HTML 5 新增的一个属性，返回元素对象的类名列表，IE 10 以上的版本才支持。通过该属性的方法可以方便地在元素中添加，移除及切换 CSS 类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.classList.add(<span class="hljs-string">&#x27;current&#x27;</span>);<span class="hljs-comment">// 添加类</span><br>element.classList.remove(<span class="hljs-string">&#x27;current&#x27;</span>);<span class="hljs-comment">// 移除类</span><br>focus.classList.toggle(<span class="hljs-string">&#x27;current&#x27;</span>);<span class="hljs-comment">// 切换类</span><br></code></pre></td></tr></table></figure><h3 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h3><p>如果有同一组元素，我们想要其中某一个元素实现某种样式， 需要用到循环的排他思想算法：</p><ol><li>所有元素全部清除样式（干掉其他人）</li><li>给当前元素设置样式 （留下我自己）</li><li>注意顺序不能颠倒，首先干掉其他人，再设置自己</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;button&gt;按钮<span class="hljs-number">1</span>&lt;/button&gt;<br>    &lt;button&gt;按钮<span class="hljs-number">2</span>&lt;/button&gt;<br>    &lt;button&gt;按钮<span class="hljs-number">3</span>&lt;/button&gt;<br>    &lt;button&gt;按钮<span class="hljs-number">4</span>&lt;/button&gt;<br>    &lt;button&gt;按钮<span class="hljs-number">5</span>&lt;/button&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> btns = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;button&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;<br>            btns[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-comment">// 先把所有的按钮背景颜色去掉，即干掉所有人</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;<br>                    btns[i].style.backgroundColor = <span class="hljs-string">&#x27;&#x27;</span>;<br>                &#125;<br>                <span class="hljs-comment">// 然后让当前的元素背景颜色为 pink，即留下我自己</span><br>                <span class="hljs-built_in">this</span>.style.backgroundColor = <span class="hljs-string">&#x27;pink&#x27;</span>;<br><br>            &#125;<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>有时候为了给 HTML 元素做一些特殊标记或者保存一小段数据，我们会用给元素添加一些自定义的属性。元素的自定义属性只能通过 <code>getAttribute(attrName)</code> 和 <code>setAttribute(name, value)) </code>方法读写，必要时使用 <code>removeAttribute(attrName)</code> 移除属性值。</p><p><strong>注意：class 属性在通过这几个方法访问时不需要转换为 className，若要彻底移除一个属性的效果，应当使用 <code>removeAttribute()</code>，而不是使用 <code>setAttribute()</code> 将属性值设置为 <code>null</code>。对于许多属性，如果仅将其值设为 <code>null</code>，这不会造达成和预期一样的效果。。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div id=<span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> </span>= <span class="hljs-string">&#x27;test&#x27;</span>&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(div.id);<br>        <span class="hljs-built_in">console</span>.log(div.className);<br>        <span class="hljs-built_in">console</span>.log(div[<span class="hljs-string">&#x27;id&#x27;</span>]);<br>        <span class="hljs-built_in">console</span>.log(div[<span class="hljs-string">&#x27;className&#x27;</span>]);<br>        <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;id&#x27;</span>));<br>        <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;class&#x27;</span>));<br>        div.setAttribute(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;demo&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(div.id);<br>div.removeAttribute(<span class="hljs-string">&#x27;id&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;id&#x27;</span>));<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>通过 JS 对象 <code>.</code> 和 <code>[]</code> 操作符只能设置 Element 对象预先定义的内置属性，并不能访问到 HTML 元素的自定义属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div index=<span class="hljs-string">&#x27;1&#x27;</span>&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        div.index = <span class="hljs-number">2</span>; <span class="hljs-comment">// index 为自定义属性，实际是为 JS 中 div 对象本身新增了一个属性 index，并没有和 HTML 文档中的 div 元素的 index 属性关联起来，两个 index 属性是相互独立的。</span><br>        <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;index&#x27;</span>));<span class="hljs-comment">// 1</span><br>        <span class="hljs-built_in">console</span>.log(div.index);<span class="hljs-comment">// 2</span><br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>为了防止自定义属性和 Element 对象预先定义的内置属性混淆，H5 规定自定义属性应该以 data- 开头，遵循这个规定的自定义属性可以通过元素对象的 dataset 属性读写并自动映射到 HTML 元素的自定义属性上面（IE 11才开始支持）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div  data-index=<span class="hljs-string">&#x27;1&#x27;</span>&gt;&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        div.dataset.index = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;data-index&#x27;</span>));<br>        <span class="hljs-built_in">console</span>.log(div.dataset.index);<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h3 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h3><p>网页中的所有内容都是节点，包括标签、属性、文本、注释等，在 DOM 中，节点使用 node 来表示。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212936.png" alt="1550970944363"></p><p>任意一个节点至少拥有 nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p><ul><li>元素节点 nodeType 为 1。</li><li>属性节点 nodeType 为 2。</li><li>文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等）。</li></ul><p>除了利用 DOM 提供的获取元素对象的方法，还可以利用节点层级关系来获取元素对象，这种方式逻辑性强， 但是兼容性稍差。DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。</p><ul><li><p>父级节点：parentNode 属性可返回离该节点最近的父节点， 如果指定的节点没有父节点则返回 <code>null</code>。</p></li><li><p>子节点：childNodes 属性返回该节点的子节点的集合，该集合为即时更新的集合。返回值里面包含了所有的子节点，包括元素节点，文本节点等。如果只想要获得里面的元素节点，则需要通过节点的 nodeType 值做筛选处理。所以我们一般不提倡使用 childNodes 属性，而是使用 children 属性，children 是一个只读属性，返回该节点的子元素节点（伪数组）集合。它只返回子元素节点，其余节点不返回。</p></li><li><p>首尾子节点：firstChild 属性返回第一个子节点，lastChild 属性返回最后一个子节点，找不到则返回 null，包括元素节点，文本节点等所有类型节点。firstElementChild 返回第一个子元素节点，lastElementChild 返回最后一个子元素节点，找不到则返回null。但是这两个属性存在兼容性问题，IE9 以上才支持。使用节点的 children 属性加上数组下标访问首尾子元素节点，既可以避开非元素节点，也可以完美兼容 IE 低版本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ol&gt;<br>&lt;li&gt;我是li1&lt;/li&gt;<br>&lt;li&gt;我是li2&lt;/li&gt;<br>&lt;li&gt;我是li3&lt;/li&gt;<br>&lt;li&gt;我是li4&lt;/li&gt;<br>&lt;li&gt;我是li5&lt;/li&gt;<br>&lt;/ol&gt;<br>&lt;script&gt;<br>    <span class="hljs-keyword">var</span> ol = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ol&#x27;</span>);<br>    <span class="hljs-comment">// 1. firstChild 第一个子节点 不管是文本节点还是元素节点</span><br>    <span class="hljs-built_in">console</span>.log(ol.firstChild);<br>    <span class="hljs-built_in">console</span>.log(ol.lastChild);<br>    <span class="hljs-comment">// 2. firstElementChild 返回第一个子元素节点 ie9才支持</span><br>    <span class="hljs-built_in">console</span>.log(ol.firstElementChild);<br>    <span class="hljs-built_in">console</span>.log(ol.lastElementChild);<br>    <span class="hljs-comment">// 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素</span><br>    <span class="hljs-built_in">console</span>.log(ol.children[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">console</span>.log(ol.children[ol.children.length - <span class="hljs-number">1</span>]);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>兄弟节点：nextSibling 属性返回当前元素的下一个兄弟元素节点，previousSibling 属性返回当前元素上一个兄弟元素节点找不到则返回null。和首尾子节点一样，也是包含所有的节点。nextElementSibling 属性返回当前元素下一个兄弟元素节点，previousElementSibling 属性返回当前元素上一个兄弟节点，找不到则返回null。同样这两个属性存在兼容性问题，IE9 以上才支持。可以通过判断 nodeType 自己封装一个的函数来解决兼容性问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextElementSibling</span>(<span class="hljs-params">element</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> el = element;<br>    <span class="hljs-keyword">while</span> (el = el.nextSibling) &#123;<br>        <span class="hljs-keyword">if</span> (el.nodeType === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> el;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;  <br></code></pre></td></tr></table></figure></li></ul><h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><p><code>document.createElement(&#39;tagName&#39;)</code> 方法创建由 tagName 指定的 HTML 元素。</p><p><code>node.appendChild(child)</code> 方法将一个节点添加到指定父节点的子节点列表末尾。类似于 CSS 里面的 after 伪元素。</p><p><code>node.insertBefore(child, 指定元素)</code> 方法将一个节点添加到父节点的指定子节点前面。类似于 CSS 里面的 before 伪元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    &lt;li&gt;<span class="hljs-number">123</span>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;script&gt;<br>    <span class="hljs-comment">// 1. 创建节点元素节点</span><br>    <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);<br><span class="hljs-comment">// 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素</span><br>    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);<br>    ul.appendChild(li);<br>    <span class="hljs-comment">// 3. 添加节点 node.insertBefore(child, 指定元素);</span><br>    <span class="hljs-keyword">var</span> lili = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);<br>    ul.insertBefore(lili, ul.children[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>node.removeChild(child)</code> 方法从 DOM 中删除一个子节点，返回删除的节点。</p><p><code>node.cloneNode(deep)</code> 方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点。deep 参数是可选的，如果括号参数为空或者为 <code>false</code> ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点（包括文本节点）。如果括号参数为 <code>true</code> ，则是深度拷贝，会复制节点本身以及里面所有的子节点。注意：克隆一个元素节点会拷贝它所有的属性以及属性值,也包括属性上绑定的事件。如果原始节点设置了 ID，并且克隆节点会被插入到相同的文档中，为了防止一个文档中出现两个 ID 重复的元素，那么应该更新克隆节点的 ID 以保证唯一性。</p><p>三种动态创建元素区别：</p><ul><li><code>document.write()</code>：直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘。</li><li><code>element.innerHTML</code>：是将内容写入某个 DOM 节点，不会导致页面全部重绘， 创建多个元素节点的效率更高（采取数组形式拼接字符串而不是使用 <code>+</code> 来拼接字符串），但是使用数组拼接起来稍微复杂。</li><li><code>document.createElement()</code>：创建多个元素效率稍低一点点，但是结构更清晰。·</li></ul><h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><p>除了通过给元素对象的事件属性（<code>onclick</code>、<code>onmouseover</code> 等）赋值一个函数对象这种传统的方式来给元素注册事件，还可以使用事件监听方式给元素绑定事件。</p><p>传统方式同一个元素的同一个事件属性只能注册一个事件处理函数，最后注册的处理函数将会覆盖前面注册的处理函数。事件监听方式可以给同一个元素同一个事件注册多个监听器。</p><p><code>eventTarget.addEventListener(type, listener[, useCapture])</code> 方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。该方法接收三个参数：</p><ul><li>type：事件类型字符串，比如 ‘click’ 、’mouseover’，注意这里不要带 on。</li><li>listener：事件处理函数，事件发生时，会调用该监听函数。</li><li>useCapture：可选参数，是一个布尔值，默认是 <code>false</code>，指定该事件在捕获阶段还是冒泡阶段触发。。</li></ul><p>IE 9 之前的版本使用 <code>eventTarget.attachEvent(eventNameWithOn, callback)</code> 来添加事件监听器。该方法接收两个参数：</p><ul><li>eventNameWithOn：事件类型字符串，比如 ‘onclick’、’onmouseover ‘，这里要带 on。</li><li>callback： 事件处理函数，当目标触发事件时回调函数被调用</li></ul><p>可以封装如下的函数解决兼容性问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventListener</span>(<span class="hljs-params">element, eventName, fn</span>) </span>&#123;<br><span class="hljs-comment">// 判断当前浏览器是否支持 addEventListener 方法</span><br>    <span class="hljs-keyword">if</span> (element.addEventListener) &#123;<br>        element.addEventListener(eventName, fn); <span class="hljs-comment">// 第三个参数 默认是false</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.attachEvent) &#123;<br>    element.attachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + eventName, fn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 相当于 element.onclick = fn;</span><br>    element[<span class="hljs-string">&#x27;on&#x27;</span> + eventName] = fn;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="事件删除"><a href="#事件删除" class="headerlink" title="事件删除"></a>事件删除</h3><p>根据注册事件方法的不同，有下面三种的删除（解绑）事件的方式：</p><ul><li><code>eventTarget.onclick = null;</code></li><li><code>eventTarget.removeEventListener(type, listener[, useCapture]);</code></li><li><code>eventTarget.detachEvent(eventNameWithOn, callback);</code></li></ul><p>也可以封装以下的删除事件函数来解决兼容性问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEventListener</span>(<span class="hljs-params">element, eventName, fn</span>) </span>&#123;<br><span class="hljs-comment">// 判断当前浏览器是否支持 removeEventListener 方法</span><br>    <span class="hljs-keyword">if</span> (element.removeEventListener) &#123;<br>    element.removeEventListener(eventName, fn); <span class="hljs-comment">// 第三个参数 默认是false</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.detachEvent) &#123;<br>   element.detachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + eventName, fn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    element[<span class="hljs-string">&#x27;on&#x27;</span> + eventName] = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212937.png" alt="1551169007768"></p><p>事件可能处于三个阶段：</p><ol><li>捕获阶段（capturing phase）</li><li>目标阶段（target phase）</li><li>冒泡阶段（bubbling phase）</li></ol><p>对于事件目标元素注册的事件来说，事件会处于目标阶段。</p><p>事件目标元素的父元素对象如果注册了事件也会触发，但是只能在捕获或者冒泡其中的一个阶段被调用。通过 <code>onclick</code> 和 <code>attachEvent()</code> 注册的事件在冒泡阶段触发。<code>addEventListener(type, listener[, useCapture])</code>第三个参数如果是 <code>true</code>，表示在事件捕获阶段调用事件处理程序；如果是 <code>false</code>（不写默认就是 <code>false</code>），表示在事件冒泡阶段调用事件处理程序。 有些事件是没有冒泡的，比如 <code>onblur</code>、<code>onfocus</code>、<code>onmouseenter</code>、<code>onmouseleave</code>。</p><p>实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</p><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>事件对象代表事件的状态，事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。比如就鼠标事件而言，谁绑定了这个鼠标事件、鼠标的位置、鼠标按钮的状态这些信息都可以由事件对象得到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">eventTarget.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;&#125;<br>eventTarget.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;&#125;）<br></code></pre></td></tr></table></figure><p>给元素注册事件处理函数的时候可以为事件对象指定形参 event，或者写成 e 或者 evt。当事件发生时事件对象就会被浏览器自动创建，并传递给事件监听器（事件处理函数）。</p><p>在 IE 6 ~ 8 中，浏览器不会给监听器传递事件对象，如果需要的话，需要到<code>window.event</code> 中获取。可以使用以下的方法做兼容性处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">e = e || <span class="hljs-built_in">window</span>.event;<br></code></pre></td></tr></table></figure><p>事件对象的常见属性和方法：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212938.png" alt="1551169931778"></p><p><code>e.target</code> 和 <code>this</code> 的区别：</p><ul><li><code>this</code> 是事件绑定的元素对象， 这个函数的调用者（绑定这个事件的元素），而这个函数可能是在冒泡阶段或者捕获阶段执行。</li><li><code>e.target</code> 是真正触发事件的具体元素对象。</li><li>当事件在目标阶段被调用执行时，<code>e.target</code> 和 <code>this</code> 指向同一个元素对象。</li></ul><p>利用事件对象的 <code>preventDefault()</code> 方法可以阻止对象的默认行为，例如 a 标签点击后默认会跳转到新地址，表单提交按钮点击后默认会提交整个表单。IE 6 ~ 8 设置事件对象 <code>returnValue</code> 为 <code>false</code> 也可以阻止默认行为，直接在事件处理函数中 <code>return false;</code> 也可以阻止默认行为，不存在兼容性问题。</p><p>利用事件对象的 <code>stopPropagation()</code> 方法可以阻止事件冒泡，IE 6 ~ 8 设置事件对象 <code>cancelBubble</code> 属性可以阻止冒泡。阻止事件冒泡的兼容性写法：</p><p>利用事件对象的 <code>stopPropagation()</code> 方法可以阻止事件冒泡，IE 6 ~ 8 设置事件对象 <code>cancelBubble</code> 属性可以阻止冒泡。阻止事件冒泡的兼容性写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(e &amp;&amp; e.stopPropagation)&#123;<br>e.stopPropagation();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托也称为事件代理， 在 jQuery 里面称为事件委派。</p><p>事件委托即当多个子元素需要注册相同或者接近的事件时，不直接给子元素注册事件，而是给它们的父元素注册事件，利用事件冒泡，当子元素的事件冒泡到父元素，执行父元素绑定的事件处理函数。</p><p>这样只操作了一次 DOM 就给所有子元素注册了事件，提高了程序的性能，并且以后新创建的子元素，也自动拥有了这个事件。</p><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212939.png" alt="1551172699854"></p><p>mouseenter 事件和 mouseover 很相似，当鼠标移动到元素上时就会触发它们。两者之间的差别：mouseover 事件会在冒泡阶段触发，鼠标经过元素自身会触发，经过子元素也会触发。 mouseenter 事件不冒泡，只会经过元素自身触发。mouseenter 行为方式与 CSS 中的 <code>:hover</code> 伪类非常相似。</p><p>mouseout 鼠标离开事件也有对应的 mouseleave 事件不会冒泡。</p><p>禁止鼠标右键菜单：<code>contextmenu</code> 主要控制应该何时显示上下文菜单，主要用于取消默认的上下文（鼠标右键）菜单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;contextmenu&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>e.preventDefault();<br>&#125;)<br></code></pre></td></tr></table></figure><p>禁止鼠标选中：<code>selectstart</code> 控制开始选中文字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;selectstart&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>e.preventDefault();<br>&#125;)<br></code></pre></td></tr></table></figure><p>鼠标事件对象常用属性：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212940.png" alt="image-20210322222524116"></p><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>常用键盘事件：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212941.png" alt="1551318122855"></p><ol><li>如果使用 <code>addEventListener()</code> 注册事件需要去掉 on。</li><li><code>onkeypress</code> 和其他两个键盘事件的区别是，它不识别功能键，比如左右箭头，<code>shift</code> 等。</li><li>三个事件的执行顺序是： keydown –&gt; keypress –&gt; keyup。</li></ol><p>键盘事件对象的 <code>keyCode</code> 属性返回该键的 ASCII 码的数值。</p><p><strong>注意：<code>onkeydown</code> 和 <code>onkeyup</code> 不区分字母大小写，<code>onkeypress</code> 区分字母大小写。</strong><br>在实际开发中，我们更多的使用 keydown 和 keyup， 它能识别所有的键（包括功能键），Keypress 不识别功能键，但是它的 keyCode 属性能区分大小写，返回不同的 ASCII 值。</p><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>BOM（Browser Object Model）即浏览器对象模型，它提供了与浏览器窗口进行交互的对象，BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性，其核心对象是 <code>window</code>。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212942.png" alt="1551319344183"></p><p>DOM 就是把整个 HTML 文档当做一个对象来看待，DOM 的顶级对象 <code>document</code>。BOM 把整个浏览器标签页当做一个对象来看待，BOM 的顶级对象是 <code>window</code>。<code>document</code> 是 <code>window</code> 对象的一个属性。</p><p><code>window</code> 是一个全局对象（global object），定义在全局作用域中的变量、函数都会变成 <code>window</code> 对象的属性和方法。但是使用 <code>var</code> 声明的全局变量，<code>var</code> 声明的函数表达式，<code>function</code> 声明的函数，不能被 <code>delete</code> 删除。详见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete">MDN：delete 操作符</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a1 = <span class="hljs-number">1</span>;<br>a2 = <span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;in f1()&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;in f2()&#x27;</span>);<br>&#125;<br>f3 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;in f3()&#x27;</span>);<br>&#125;<br>f4 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f4</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;in f4()&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> a1); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> a2); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> f1); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> f2); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> f3); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> f4); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="window-事件"><a href="#window-事件" class="headerlink" title="window 事件"></a>window 事件</h3><ul><li><p>窗口加载事件：当文档内容(包括图像、脚本文件、CSS文件等)完全加载完成会触发该事件, 调用处理函数。可以把 JS 代码放到回调函数里，这样 <code>script</code> 标签就可以放在文档的任意位置，等页面内容全部加载完毕，再去执行处理函数，避免了获取元素失败的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;load&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);<br></code></pre></td></tr></table></figure><p>IE 9 以上支持 <code>DOMContentLoaded</code> 事件，仅当 DOM 加载完成就触发时间，不包括样式表，图片，flash 等等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><p>如果页面的要加载的资源很多或者网络情况不好的话, 从用户访问到 <code>onload</code> 事件触发可能需要较长的时间，很多 JS 效果就不能生效，影响用户的体验，此时用 <code>DOMContentLoaded</code> 事件比较合适。</p></li><li><p>调整窗口大小事件：当浏览器窗口大小发生变化，就会触发这个事件。利用这个事件配合 <code>window.innerWidth</code>（当前屏幕的宽度）属性可以完成响应式布局。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);<br></code></pre></td></tr></table></figure></li><li><p>页面滚动事件：常结合 <code>window.pageYOffset</code> 和 <code>window.pageXOffset</code> 这两个属性使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onscroll = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="window-属性"><a href="#window-属性" class="headerlink" title="window 属性"></a>window 属性</h3><ul><li><p><code>location</code>：用于获取或设置窗体的 URL，并且可以用于解析 URL 。 因为<br>这个属性返回的是一个对象，所以我们将这个属性也称为 <code>location</code> 对象。URL (Uniform Resource Locator, URL) 的格式为：<code>protocol://host[:port]/path/[?query]#fragment</code><br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212943.png" alt="1551322387201"><br> <code>location</code> 对象的属性：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212944.png" alt="1551322416716"></p><p>利用 <code>location.search</code> 可以在页面跳转中传递少量参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 1.先去掉？  substr(&#x27;起始的位置&#x27;，截取几个字符);</span><br>    <span class="hljs-keyword">var</span> params = location.search.substr(<span class="hljs-number">1</span>); <span class="hljs-comment">// uname=andy</span><br>    <span class="hljs-built_in">console</span>.log(params);<br>    <span class="hljs-comment">// 2. 利用=把字符串分割为数组 split(&#x27;=&#x27;);</span><br>    <span class="hljs-keyword">var</span> arr = params.split(<span class="hljs-string">&#x27;=&#x27;</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>location</code> 对象的方法：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212945.png" alt="1551322750241"></p></li><li><p><code>navigator</code>：该对象包含有关浏览器的信息，我们最常用的是 <code>userAgent</code> 属性，该属性是一个只读的字符串，返回浏览器用于 HTTP 请求的用户代理头的值。利用该值可以对用户的终端信息进行判断，实现跳转不同的页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>((navigator.userAgent.match(<span class="hljs-regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;<br>    <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 跳转到手机页面</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 跳转到电脑页面</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>history</code>：使用该对象与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的 URL。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212946.png" alt="1551322885216"></p></li><li><p><code>sessionStorage</code>、<code>localStorage</code>：这两个对象可以将少量数据以键值对的形式存储在用户本地浏览器中，<code>sessionStorage</code> 的容量约 5 MB、<code>localStorage</code> 约 20 MB，不同浏览器的大小不统一。键和值都只能是字符串形式，如果要存储对象可以先使用 <code>JSON.stringify()</code> 编码后再存储。 <code>sessionStorage</code> 的生命周期为关闭浏览器窗口，在同一个窗口（页面）下的数据可以共享，<code>localStorage</code> 存储的数据永久生效，关闭了浏览器也会依旧存在，除非手动删除数据，同一浏览器的多个窗口（页面）之间可以共享 <code>localStorage</code> 存储的数据，前提是这些页面访问的域名相同（同源策略）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">sessionStorage.setItem(key, value);<span class="hljs-comment">// 存储数据</span><br>sessionStorage.getItem(key);<span class="hljs-comment">// 获取数据</span><br>sessionStorage.removeItem(key);<span class="hljs-comment">// 删除数据</span><br>sessionStorage.clear();<span class="hljs-comment">// 删除所有数据</span><br><span class="hljs-built_in">localStorage</span>.setItem(key, value);<span class="hljs-comment">// 存储数据</span><br><span class="hljs-built_in">localStorage</span>.getItem(key);<span class="hljs-comment">// 获取数据</span><br><span class="hljs-built_in">localStorage</span>.removeItem(key);<span class="hljs-comment">// 删除数据</span><br><span class="hljs-built_in">localStorage</span>.clear();<span class="hljs-comment">// 删除所有数据</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p><code>window</code> 对象提供了 2 个设定定时器方法：<code>setTimeout()</code> 和 <code>setInterval()</code>。</p><p><code>window.setTimeout(调用函数, [延迟的毫秒数])</code>方法用于设置一个定时器，该定时器在定时器到期后执行调用函数，<code>window</code> 可以省略。 这个调用函数也称为回调函数（callback），可以直接写匿名函数表达式，或者写函数名或者字符串形式的‘函数名()’三种形式，第三种不推荐。 延迟时间单位只能是毫秒，只需写数值不用写单位，默认值是 0。该方法返回值 <code>timeoutID</code> 是一个正整数，表示定时器的编号。这个值可以传递给 <code>window.clearTimeout(timeoutID)</code> 来取消该定时器。</p><p>回调函数原理：函数可以作为一个参数。将这个函数作为实参传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。</p><p><code>window.setInterval(回调函数, [间隔的毫秒数])</code>方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。其他两个参数的用法和 <code>setTimeout()</code> 一样，但是如果这个时间参数值小于 10，则默认使用值为 10 ms，真正延迟的时间或许更长。该方法返回值 <code>intervalID</code> 是一个正整数，表示计时器的编号。这个值可以传递给 <code>window.clearTimeout(intervalID)</code> 来取消该计时器。</p><p>对于同一个 <code>window</code> 对象，<code>setTimeout()</code> 或者 <code>setInterval()</code> 在后续的调用不会重用同一个定时器编号，不同的 <code>window</code> 对象使用独立的编号池。</p><p><strong>注意：<code>setTimeout()</code> 和 <code>setInterval()</code> 共用一个编号池，技术上，<code>clearTimeout()</code> 和 <code>clearInterval()</code> 可以互换。但是，为了避免混淆，不要混用取消定时函数。</strong></p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JavaScript 是单线程的非阻塞的脚本语言。这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。HTML 5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p><p>单线程意味着，对于一个 JS 程序而言，都只有一个主线程来处理所有的任务。</p><p>非阻塞则是当 JS 需要进行一项无法立刻返回结果异步任务的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p><p>一般而言，异步任务有以下三种类型:<br>1、普通事件，如 click、resize 等。<br>2、资源请求加载，如 load、error 等。<br>3、定时器，包括 setInterval、setTimeout 等。</p><p>尽管 JS 是单线程执行的，但是（宿主环境）浏览器是多线程的，浏览器中的其他线程去协助 JS 引擎的运行实现了 JS 在浏览器运行环境的非阻塞。</p><p>浏览器中的线程举例：</p><ol><li>GUI 渲染线程</li><li>JS 引擎线程</li><li>定时触发器线程（setTimeout和setInteval）</li><li>浏览器事件触发线程（onclick）</li><li>异步 HTTP 请求线程（ajax）</li><li>事件轮询处理线程（event loop）</li></ol><p>JS 执行步骤</p><ol><li>执行主线程执行栈中的同步任务。</li><li>遇到异步任务交给异步线程（定时器触发线程 (setTimeout)、http 异步线程（ajax ）、浏览器事件线程（onclick））执行。</li><li>异步成功后，异步任务的回调函数放入任务队列（也叫消息队列）中。</li><li>当执行栈中的所有同步任务执行完毕，事件循环（event loop）线程，就会按入队次序读取（消息队列）中的回调函数进入执行栈，开始执行。</li></ol><p>JS 主线程从任务队列中读取任务，执行任务，这个过程是循环不断的，所以这种运行机制又称为事件循环（event loop）。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212947.jpg" alt="img"></p><h2 id="网页特效相关"><a href="#网页特效相关" class="headerlink" title="网页特效相关"></a>网页特效相关</h2><h3 id="元素偏移量-offset-系列"><a href="#元素偏移量-offset-系列" class="headerlink" title="元素偏移量 offset 系列"></a>元素偏移量 offset 系列</h3><p>使用 offset 系列相关属性可以动态的得到该元素距离带有定位的父元素的偏移量、元素自身的大小（宽度高度）等。<strong>注意： 返回的都是数字型不带单位。</strong></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212948.png" alt="图片2"></p><p>offset 系列常用属性：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212949.png" alt="图片1"></p><p>offset 系列属性 与 <code>style</code> 属性区别 ：</p><ul><li>offset 系列可以得到任意样式表中的样式值，<code>style</code> 只能得到行内样式表中的样式值。</li><li>offset 系列获得的数值是没有单位的，<code>style.width</code> 获得的是带有单位的字符串。</li><li>offsetWidth 包含padding+border+width，<code>style.width</code> 获得不包 padding 和 border 的值。</li></ul><ul><li>offset 系列等属性是只读属性，只能获取不能赋值，<code>style.width</code> 是可读写属性，可以获取也可以赋值。</li></ul><p>想要获取元素大小位置，用 offset 系列属性更合适，想要给更改元素样式，则需要用 <code>style</code> 属性。<strong>注意：通过 style 属性赋值时一定要记得补上单位字符串。</strong></p><h3 id="元素可视区-client-系列"><a href="#元素可视区-client-系列" class="headerlink" title="元素可视区 client 系列"></a>元素可视区 client 系列</h3><p>使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列的相关属性可以动态的得到该元素的边框大小、元素自身的大小（不包含边框）。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212950.png" alt="图片4"></p><p>client 系列常用属性：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212951.png" alt="图片3"></p><h3 id="元素滚动-scroll-系列"><a href="#元素滚动-scroll-系列" class="headerlink" title="元素滚动 scroll 系列"></a>元素滚动 scroll 系列</h3><p>使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212952.png" alt="图片6"></p><p>scroll 系列常用属性：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212953.png" alt="图片5"></p><p>如果元素的高（或宽）度不足以显示整个元素内容时，会自动出现滚动条。当滚动条向下滚动时，内容上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 <code>onscroll</code> 事件。如果是整个页面滚动，事件源是 <code>document</code> 对象，如果是某个元素的内容滚动则事件源是该元素对象。</p><p><strong>注意：给元素添加 <code>overflow:auto</code> 样式才会在内容溢出时显示滚动条。</strong></p><p>页面被卷去的头部：可以通过 <code>window.pageYOffset</code> 获得 如果是被卷去的左侧 <code>window.pageXOffset</code>。元素被卷去的头部是 <code>element.scrollTop</code>，如果是被卷去的左侧是 <code>element.scrollLeft</code>。 </p><p><code>window.pageYOffset</code> 和 <code>window.pageXOffset</code> 这两个属性 IE 9 开始支持，如果文档开头声明了 DOCTYPE，IE 9 以下可以使用<code>document.documentElement.scrollTop</code>，没声明 DTD 可以使用 <code>document.body.scrollTop</code>。封装如下的兼容性函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScroll</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      left: <span class="hljs-built_in">window</span>.pageXOffset || <span class="hljs-built_in">document</span>.documentElement.scrollLeft || <span class="hljs-built_in">document</span>.body.scrollLeft||<span class="hljs-number">0</span>,<br>      top: <span class="hljs-built_in">window</span>.pageYOffset || <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-number">0</span><br>    &#125;;<br> &#125; <br><span class="hljs-comment">// 通过 getScroll().left 和 `getScroll().top 使用</span><br></code></pre></td></tr></table></figure><p>三个系列对比：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212954.png" alt="图片7"></p><p>client 系列不仅不包括边框，如果有滚动条也不包括滚动条。scroll 系列则计算元素完整内容的大小，尽管这些内容可能发生了溢出。</p><ol><li>offset 系列主要使用 <code>offsetLeft</code>、<code>offsetTop</code> 获取元素位置 。</li><li>client 系列主要使用 <code>clientWidth</code> 、<code>clientHeight</code> 获取元素大小 。</li><li>scroll 系列主要使用 <code>scrollTop</code> 、<code>scrollLeft</code> 获取滚动距离。</li><li>整个页面滚动的距离通过 <code>window.pageXOffset</code> 获得。</li></ol><h3 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h3><p>动画实现原理：通过定时器 <code>setInterval()</code> 不断移动元素位置。</p><p>缓动动画：让元素运动速度有所变化，最常见的是让移动速度慢慢停下来，既让每步的步长慢慢变小，步长公式：（目标值 - 现在的位置） / 10，但是在接近终点时步长会无线趋近于 0 而始终无法准确到达终点，所以要对步长往数轴两端取整。如果步长是正值，利用 <code>Math.ceil()</code> 往上取整，如果是负值，则利用 <code>Math.floor()</code> 向下取整。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">obj, target, callback</span>) </span>&#123;<br>    <span class="hljs-comment">// 先清除以前的定时器，只保留当前的一个定时器执行,</span><br>    <span class="hljs-comment">// 让每一个元素至始至终只有一个定时器，防止多次调用会使动画加速</span><br>    <span class="hljs-built_in">clearInterval</span>(obj.timer);<br>    obj.timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 步长公式</span><br>        <span class="hljs-keyword">var</span> step = (target - obj.offsetLeft) / <span class="hljs-number">10</span>;<br>        step = step &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.ceil(step) : <span class="hljs-built_in">Math</span>.floor(step);<br>        <span class="hljs-comment">// 到达目标则停止动画 本质是停止定时器</span><br>        <span class="hljs-keyword">if</span> (obj.offsetLeft == target) &#123;<br>            <span class="hljs-built_in">clearInterval</span>(obj.timer);<br>            <span class="hljs-comment">// 回调函数写到定时器结束里面 </span><br>            callback &amp;&amp; callback(); <span class="hljs-comment">// 等价为 if (callback) &#123;callback();&#125;</span><br>        &#125;             <br>        obj.style.left = obj.offsetLeft + step + <span class="hljs-string">&#x27;px&#x27;</span>;<br>    &#125;, <span class="hljs-number">15</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用封装号的动画函数需要传递 3 个参数，动画对象（obj）、移动到的距离（target）和回调函数（callback）。</p><p><code>callback &amp;&amp; callback ()</code></p><h3 id="移动端触屏事件"><a href="#移动端触屏事件" class="headerlink" title="移动端触屏事件"></a>移动端触屏事件</h3><p>移动端没有鼠标点击的概念，取而代之的是手指触屏事件 touch（也称触摸事件），触屏事件可响应用户手指（或触控笔）对屏幕或者触控板的操作。</p><p>常见的触屏事件如下：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212955.png" alt="image-20210515130450548"></p><p>触摸事件对象（TouchEvent）保存触屏事件有关的状态信息，通过该对象的属性和方法可以检测触点的移动，触点的增加和减少等等。</p><p>touchstart、touchmove、touchend 三个事件都有各自的事件对象，但都有以下属性：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192212956.png" alt="image-20210515132352287"></p><p>大多数情况使用 <code>targetTouches</code> 属性，该属性本质是一个伪数组，当只有一个手指触摸时使用 <code>e.targetTouches[0].pageX</code> 和 <code>e.targetTouches[0].pageY</code> 来获取触点在页面上的坐标。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="http://www.quirksmode.org/js/events_order.html">JavaScript Event order</a></p></li><li><p><a href="https://www.jeffjade.com/2016/01/10/2016-01-10-javacript-setTimeout/">你所不知道的 setTimeout</a></p></li><li><p><a href="https://www.jeffjade.com/2016/01/10/2016-01-10-javaScript-setInterval/">你所不知道的 setInterval</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/33058983">详解 JavaScript中 的 Event Loop（事件循环）机制</a></p></li><li><p><a href="https://juejin.cn/post/6844903752621637645">JS 线程、Event Loop、事件循环、任务队列、宏任务</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用阿里云 OSS 服务搭建博客图床</title>
    <link href="/2021/02/26/%E9%98%BF%E9%87%8C%E4%BA%91%20OSS%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/"/>
    <url>/2021/02/26/%E9%98%BF%E9%87%8C%E4%BA%91%20OSS%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此前使用单独的 GitHub 仓库作为博客的图床，配合 jsDelivr 的免费 CDN 服务，访问起来没感到什么卡顿，并且还免费，存储空间暂时也不用担心。</p><p>但是使用 Typora 配合 PicGo 一键批量上传本地图片到 GitHub 仓库的成功率实在太低了。上传速度慢不说，经常连着上传好多次都失败，而 Typora 又不支持断点续传，下次又要重复上传已经成功上传的图片，使 GitHub 仓库中出现大量重复的图片。刚开始以为是 PicGo 的问题，并且每次 PicGo 报错日志都不一样。去 PicGo 的 issue 搜索了一下报错信息，作者的回复大都是网络原因导致，能顺利访问 GitHub 主站，不代表能顺利访问 GItHub API 地址。</p><p>但是更换几次网络环境还是问题依旧，终于，在经历一次连续几天的上传失败后终于忍无可忍，遂想着购买 OSS 服务来存储图片，之前尝试过七牛的 OSS 服务，虽然有免费空间，但是要自己的域名经过备案才让使用，否则只能使用七牛的子域名，最要命的是这个域名是临时的，一个月更换一次，意味着每个月得去替换博客中图片地址。因为自己的域名没备案，也懒得去备案，遂放弃七牛云。看了看腾讯和阿里的 OSS 产品，阿里的更加便宜，并且支付宝登录付款也安全方便。最后选择了阿里云 OSS 产品。</p><p>登录<a href="https://www.aliyun.com/">阿里云</a>，在产品 -&gt; 存储 -&gt; 中选择对象存储 OSS，开通服务。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192235216.png" alt="image-20210226165835593"></p><p>右上角进入阿里云控制台，左边列表中选择对象存储 OSS。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192235218.png" alt="image-20210226174816254"></p><p>点击左侧菜单的 Bucket 列表，创建一个新的 Bucket，一个 Bucket 可以理解为一个单独存储仓库，这个仓库可以用来存放任何文件，不只是图片。<strong>注意：Bucket 名称要全网唯一，读写权限改为公共读。</strong></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192235219.png" alt="image-20210226175332347"></p><p>接下来需要获取阿里云账户 AccessKey ID 和 AccessKey Secret，这样就可以使用 PicGo 来管理仓库了。建议在当前账户创建一个 RAM 子账号，使用子账号的 AccessKey 更加安全。具体操作可以看阿里云的官方帮助：<a href="https://help.aliyun.com/knowledge_detail/38738.html">阿里云：如何获取AccessKey ID和AccessKey Secret</a>，<a href="https://help.aliyun.com/document_detail/28637.html">阿里云：创建RAM用户</a>。</p><p>打开 PicGo 的图床设置，填入上面提到的相关信息。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192235220.png" alt="image-20210226181918717"></p><p>存储空间名称即 Bucket 名称，存储区域和当初创建 Bucket 时选择的地域有关，可以进入自己刚才创建的 Bucket 概览页面查看。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192235221.png" alt="image-20210226182251848"></p><p>然后在 PicGo 上传区中选择阿里云 OSS 作为默认上传图床。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192235222.png" alt="image-20210226182534736"></p><p>至此 PicGo 设置完毕，使用 Typora 一键上传文章中所有本地图片，20 张图片几乎秒传，再也没碰到过各种上传失败了，看来之前真是错怪 PicGo 了。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192235223.png" alt="image-20210226183058424"></p><p><strong>注意：不要同时打开多个 Typora 窗口批量上传图片，否则可能在 PicGo 重命名图片上出现两张同名的图片发生覆盖的情况。</strong></p><p>有一个无伤大雅的小问题是，如果直接在新标签页中打开图片会被强制下载，绑定自定义域名可以解决这个问题，但是绑定的域名需要经过备案。详见：<a href="https://help.aliyun.com/document_detail/39545.html">阿里云：访问OSS资源后资源被强制下载</a></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192235224.png" alt="image-20210226185319437"></p><p>使用几天后发现，如果博客只是搭给自己看的，没什么访问量的话，选择按量付费，经过抹零后甚至一分钱都不用花。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192235225.png" alt="image-20210226184555215"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192235227.png" alt="image-20210226184734486"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/63557477">知乎：阿里云oss搭建图床以及使用PicGO上传图片到图床</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
      <tag>PicGo</tag>
      
      <tag>阿里云</tag>
      
      <tag>OSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 基础</title>
    <link href="/2021/01/16/JavaScript%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/01/16/JavaScript%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="初识-JavaScript"><a href="#初识-JavaScript" class="headerlink" title="初识 JavaScript"></a>初识 JavaScript</h2><h3 id="JS-的作用"><a href="#JS-的作用" class="headerlink" title="JS 的作用"></a>JS 的作用</h3><p>1995年，网景公司（Netscape）的员工布兰登·艾奇（Brendan Eich）用 10 天时间就把 Javascript 设计出来了，最初命名为 LiveScript，后来在与 Sun 合作之后将其改名为 JavaScript。</p><p>JavaScript 是世界上最流行的语言之一，是一种运行在客户端浏览器的脚本语言（Script 是脚本的意思），常常把 JavaScript 简称为 JS。</p><p>JS 编写出来的程序不需要编译就可以直接运行，运行过程中由 JS 解释器（JS 引擎）逐行进行解释并执行。</p><p>如今 JavaScript 的使用场景越来越广泛，除了用在浏览器中来和用户进行交互，在其他领域也有广泛的应用。</p><ul><li>表单动态校验（密码强度检测） （JS 最初产生的目的）</li><li>网页特效</li><li>服务端开发（Node.js）</li><li>桌面程序（Electron）</li><li>移动 App（Cordova）</li><li>控制硬件-物联网（Ruff）</li><li>游戏开发（cocos2d-js）</li></ul><h3 id="浏览器中的-JS"><a href="#浏览器中的-JS" class="headerlink" title="浏览器中的 JS"></a>浏览器中的 JS</h3><p>浏览器分成两部分：渲染引擎和 JS 引擎。</p><ul><li>渲染引擎：用来解析 HTML 与 CSS，俗称内核，比如新版 Chrome 浏览器的 Blink 内核，Safari 浏览器和早期 Chrome 浏览器所使用的 Webkit 内核。</li><li>JS 引擎：也称为 JS 解释器，用来读取网页中的JavaScript代码，对其处理后运行，比如 Chrome 浏览器的 V8 引擎。</li></ul><p>浏览器内核本身并不会执行 JS 代码，而是通过内置 JavaScript 引擎（解释器）来执行 JS 代码。JS 引擎执行代码时逐行解释每一句源码，将其转换为机器语言，然后交由计算机去执行。因为是因为 JS 是逐行解释执行的，类似于演戏时用到的脚本——演员看了指令就知道自己该表演什么，说什么台词；计算机看了指令就知道自己该做什么事情，所以我们把 JS 归为脚本语言。</p><h3 id="JS-的组成"><a href="#JS-的组成" class="headerlink" title="JS 的组成"></a>JS 的组成</h3><p>广义上的 JS 的组成：</p><ul><li>ECMAScript：ECMAScript 规定了 JS 的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套 JS 语法工业标准。JavaScript（网景公司）和 JScript（微软公司）是 ECMAScript 语言的具体实现，并在此基础做了各自特有的扩展。</li><li>DOM：文档对象模型（Document Object Model，简称DOM），是 W3C 组织推荐的用来处理可扩展标记语言（XML）的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。</li><li>BOM：浏览器对象模型（Browser Object Model，简称 BOM），它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过 BOM 可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</li></ul><h3 id="JS-的位置"><a href="#JS-的位置" class="headerlink" title="JS 的位置"></a>JS 的位置</h3><p>JS 有 3 种书写位置，分别为行内、内嵌和外部。</p><ul><li><p>行内式 JS：可以将单行或少量 JS 代码写在 HTML 标签的事件属性值中（大多以 on 开头的属性，如：<code>onclick</code>）。在 HTML 中编写大量 JS 代码时，不方便阅读，并且单双引号多层嵌套匹配时，非常容易弄混，一般只在特殊情况下使用行内式 JS。注意单双引号的使用：在 HTML 中推荐使用双引号将键的值括起来，JS 中推荐使用单引号将字符串括起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;点我试试&quot;</span> onclick=<span class="hljs-string">&quot;alert(&#x27;Hello World&#x27;);&quot;</span> /&gt;<br></code></pre></td></tr></table></figure></li><li><p>内嵌 JS：可以将多行 JS 代码写到 <code>&lt;script&gt;</code> 标签中，内嵌 JS 是学习 JS 时常用的书写位置，比较方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>alert(<span class="hljs-string">&#x27;Hello World~!&#x27;</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>外部 JS文件：通过 <code>&lt;script&gt;</code> 标签直接引用外部的 JS 文件，适合于 JS 代码量比较大的情况。注意：引用外部 JS 文件的 <code>&lt;script&gt;</code> 开闭标签中间不可以再写任何 JS 代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;my.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="JS-的输入输出语句"><a href="#JS-的输入输出语句" class="headerlink" title="JS 的输入输出语句"></a>JS 的输入输出语句</h3><p>为了方便信息的输入输出，JS 提供了一些输入输出语句与浏览器用户或者开发者进行交互。</p><ul><li><code>alert(msg)</code>：浏览器弹出警示框，主要用来显示消息给浏览页面的用户。</li><li><code>console.log(msg)</code>：浏览器控制台打印输出信息，主要用来给程序员自己查看 JS 运行时的消息或者中间结果来更好的调试程序。</li><li><code>prompt(info)</code>：浏览器弹出输入框，用户可以通过输入框键入一些信息。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><p>变量在使用时分为两步： </p><ol><li><p>声明变量：<code>var</code>（variable，变量的意思）是一个 JS 关键字，用来声明变量。使用该关键字声明变量后，计算机会自动为变量分配内存空间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age; <span class="hljs-comment">// 声明一个 名称为 age 的变量</span><br></code></pre></td></tr></table></figure></li><li><p>赋值：把右边的值赋给左边的变量空间中 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">age = <span class="hljs-number">10</span>; <span class="hljs-comment">// 给 age 这个变量赋值为 10</span><br></code></pre></td></tr></table></figure></li></ol><p>也可以在声明一个变量的同时并赋值，我们称之为变量的初始化。JS 引擎在预解析到初始化语句时，会将其拆成声明和赋值两部分，声明置顶，赋值保留在原来位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>; <span class="hljs-comment">// 声明变量同时赋值为 18</span><br></code></pre></td></tr></table></figure><p>同时声明多个变量时，只需要写一个 <code>var</code>， 多个变量名之间使用英文逗号隔开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<span class="hljs-comment">// 等同于 var a = 10; var b = 20;</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>b = <span class="hljs-number">20</span>;   <span class="hljs-comment">// 逗号不能省略，也不能用换行来代替逗号也是不行的，因为 JS 会自动在行末添加分号，等同于 var a = 10; b = 20; b 的作用域可能和上一句有区别。</span><br></code></pre></td></tr></table></figure><p>不要使用 <code>=</code> 号给多个变量同时赋值，可能会造成意料之外的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = b = c = <span class="hljs-number">10</span> <span class="hljs-comment">// 等同于 c = 10;b = c;var a = b; c 和 b 会被当做全局对象的属性。</span><br></code></pre></td></tr></table></figure><h3 id="声明变量特殊情况"><a href="#声明变量特殊情况" class="headerlink" title="声明变量特殊情况"></a>声明变量特殊情况</h3><p>只声明一个变量，不赋值就直接使用，变量的值默认为的 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age; <br><span class="hljs-built_in">console</span>.log (age);<span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>没有声明变量，也没有赋值就直接使用，浏览器控制台会报错 xxx is not defined，并且后面的 JS 代码得不到执行，因为 JS 是逐行解释执行的，某一行报错就无法接着执行后面的语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log (age);<br></code></pre></td></tr></table></figure><p>不声明变量，直接就给变量赋值，可以正常使用变量，不会报错，但这个变量会被当做隐式全局变量（implicit globals），拥有全局作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">age = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log (age); <br></code></pre></td></tr></table></figure><p>JS 允许重复声明同一个变量，并且不会导致之前声明的变量的值的丢失，但是如果后一次声明的同时赋值会导致值被覆盖。参考：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#Description">MDN：Statement - Var</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> age;<br><span class="hljs-built_in">console</span>.log (age); <span class="hljs-comment">// 重新声明变量，该变量的值不会丢失,仍然输出 10 而不是 undefined</span><br><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>；<br><span class="hljs-built_in">console</span>.log (age); <span class="hljs-comment">// 重新声明并赋值变量，值被覆盖,输出 20</span><br></code></pre></td></tr></table></figure><h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><p>标识符：就是指开发人员为变量、属性、函数、参数取的名字。标识符不能是关键字或保留字。</p><p>关键字：是指编程语言已经规定好某些特殊用途的单词，不能再用它们充当变量名、方法名。 JS 中的关键字包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。</p><p>保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、goto、implements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。<br><strong>注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。</strong></p><p>了解上面三个概念后，变量名规范实际上就是标识符规范。</p><ul><li>变量名由字母(A-Z、a-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，但是不能以数字开头。如：usrAge，num01， _name，$name，是正确的变量名。可以使用在线工具 <a href="https://mothereff.in/js-variables">JS 变量名验证器</a>判断一个变量名是否合法。</li><li>虽然 ECMAScript 规定所有 Unicode letter 均可以作为变量名标识符，但是尽量不要使用中文做标识符。参考：<a href="https://stackoverflow.com/questions/7451524/why-arent-%dc%ab-and-valid-javascript-variable-names">Why aren’t ◎ܫ◎ and ☺ valid JavaScript variable names?</a></li><li>变量名严格区分大小写。<code>var app;</code> 和 <code>var App;</code> 声明了两个不同的变量。</li><li>变量名不能是关键字、保留字。例如：var、for、while。</li><li>不要使用 name、location、self 作为全局变量名（global variable），这些变量名已经被浏览器的 <code>windows</code> 对象的属性所使用，更多浏览器的属性参考这个<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window">链接</a>。</li><li>变量名建议遵守驼峰命名法。首字母小写，后面单词的首字母需要大写，例如 myFirstName。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript 是一种动态类型语言，不需要提前声明变量的类型，在程序运行过程中，类型会被自动确定，意味着同一个变量在不同时刻还类型可能不一样。参考：<a href="https://www.zhihu.com/question/19918532">弱类型、强类型、动态类型、静态类型语言的区别是什么？</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">6</span>; <span class="hljs-comment">// x 为数字</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;Bill&quot;</span>; <span class="hljs-comment">// x 为字符串</span><br></code></pre></td></tr></table></figure><p>JS 把数据类型分为两类：</p><ul><li>简单数据类型（number，string，boolean，undefined，null），又叫做基本数据类型（primitive data type）或者值类型，在存储时数据的值直接存放在栈空间中，因此叫做值类型。</li><li> 复杂数据类型（object），又叫做引用类型，引用类型变量在存储时栈空间中存储的仅仅是引用地址，用来指向一个对象实例，真正的对象实例存放在堆空间中，因此叫做引用数据类型。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213446.png" alt="image-20210101152940197"></p><h3 id="数字型-number"><a href="#数字型-number" class="headerlink" title="数字型 number"></a>数字型 number</h3><p>JavaScript 数字类型既可以用来保存整数值，也可以保存小数(浮点数）。在 JS 中数值字面量前面加 0 表示八进制，字面量前面加 0x 表示十六进制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">21</span>; <span class="hljs-comment">// 整数</span><br><span class="hljs-keyword">var</span> Age = <span class="hljs-number">21.3747</span>; <span class="hljs-comment">// 小数</span><br><span class="hljs-keyword">var</span> num3 = <span class="hljs-number">012</span>; <span class="hljs-comment">//八进制字面量， 对应十进制的 10</span><br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">019</span>; <span class="hljs-comment">// 虽然以 0 开头，但是八进制中不存在数字 9，所以还是会当成十进制，对应十进制的 19</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">0xA</span>; <span class="hljs-comment">//十六进制字面量，对应十进制的 15</span><br></code></pre></td></tr></table></figure><p>JavaScript 中数值的一些特殊值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">alert(<span class="hljs-built_in">Number</span>.MAX_VALUE); <span class="hljs-comment">// 最大值，1.7976931348623157e+308</span><br>alert(<span class="hljs-built_in">Number</span>.MIN_VALUE); <span class="hljs-comment">// 最小值，5e-324</span><br>alert(<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// 无穷大，大于任何数值，Infinity</span><br>alert(-<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// 无穷小，小于任何数值，-Infinity</span><br>alert(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// NaN，Not a number，代表一个非数值</span><br></code></pre></td></tr></table></figure><p>可以使用 <code>isNaN()</code> 方法来判断一个变量是否为非数字类型。<code>isNaN(x)</code> 返回 <code>false</code> 说明 x 为数字，返回 <code>true</code> 说明 x 不是数字。</p><h3 id="字符串型-string"><a href="#字符串型-string" class="headerlink" title="字符串型 string"></a>字符串型 string</h3><p>字符串型的字面量可以是 双引号 <code>&quot;&quot;</code> 和 单引号 <code>&#39;&#39;</code> 的括起来的任意文本，因为 HTML 标签里面的属性使用的是双引号，JS 里我们更推荐使用单引号。当文本中也有引号出现时注意引号的匹配，可以用单引号嵌套双引号 ，或者用双引号嵌套单引号，或者使用下面的转义符号。</p><p>类似 HTML 里面的特殊字符，字符串的文本中也有特殊字符，我们称之为转义符。转义符都是反斜杠 <code>\</code> 开头的，常用的转义符及其说明如下：</p><table><thead><tr><th><strong>转义符</strong></th><th><strong>解释说明</strong></th></tr></thead><tbody><tr><td>\n</td><td>换行符，n  是  newline  的意思</td></tr><tr><td>\ \</td><td>反斜杠  \</td></tr><tr><td>&#39;</td><td>‘  单引号</td></tr><tr><td>&quot;</td><td>” 双引号</td></tr><tr><td>\t</td><td>tab 缩进</td></tr><tr><td>\b</td><td>空格 ，b  是  blank 的意思</td></tr></tbody></table><p>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 <code>length</code> 属性可以获取整个字符串的长度。</p><p>多个字符串之间可以使用二元操作符 <code>+</code> 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串， 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1.1 字符串 &quot;相加&quot;</span><br>alert(<span class="hljs-string">&#x27;hello&#x27;</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-string">&#x27;world&#x27;</span>); <span class="hljs-comment">// hello world</span><br><br><span class="hljs-comment">//1.2 数值字符串 &quot;相加&quot;</span><br>alert(<span class="hljs-string">&#x27;100&#x27;</span> + <span class="hljs-string">&#x27;100&#x27;</span>); <span class="hljs-comment">// 100100</span><br><br><span class="hljs-comment">//1.3 数值字符串 + 数值</span><br>alert(<span class="hljs-string">&#x27;11&#x27;</span> + <span class="hljs-number">12</span>); <span class="hljs-comment">// 1112</span><br><br><span class="hljs-comment">//1.4 字符串和变量来拼接</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;<br>alert(<span class="hljs-string">&#x27;我今年&#x27;</span> + age + <span class="hljs-string">&#x27;岁啦&#x27;</span>); <br></code></pre></td></tr></table></figure><h3 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型 boolean"></a>布尔型 boolean</h3><p>布尔类型只有两个值：<code>true</code> 和 <code>false</code>。布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">alert(<span class="hljs-literal">true</span> + <span class="hljs-literal">true</span>  + <span class="hljs-literal">true</span>); <span class="hljs-comment">// 3</span><br>alert(<span class="hljs-literal">false</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h3><p>一个变量声明后没有被赋值会有一个默认值 <code>undefined</code>，如果和字符串相连拼接，这个变量被视为 ‘undefined’ 字符串，和数字或者布尔型进行数学运算结果会是 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> variable;<br><span class="hljs-built_in">console</span>.log(variable);  <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你好&#x27;</span> + variable);    <span class="hljs-comment">// 你好undefined</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">11</span> + variable); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + variable); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>一个变量赋值 <code>null</code> ，即里面存的值为空，表示一个空对象引用，常用来主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。如果和字符串相连拼接，被视为 ‘null’ 字符串，和数字或者布尔型进行数学运算被当作数值 0 参加运算。</p><h3 id="获取变量类型"><a href="#获取变量类型" class="headerlink" title="获取变量类型"></a>获取变量类型</h3><p>可以使用 <code>typeof</code> 操作符来检测变量的数据类型，返回一个字符串。</p><p><code>undefined</code> 和 <code>null</code> 都是只有一个值的特殊类型。<code>typeof</code> 一个没有赋值的变量会返回 <code>undefined</code>，由于某些历史遗留原因，用 <code>typeof</code> 检测 <code>null</code> 返回是 ‘object’，参考<a href="https://stackoverflow.com/questions/18808226/why-is-typeof-null-object">Why is typeof null “object”?</a>。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213447.png" alt="image-20210101162608237"></p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>编程中经常要把一种数据类型的变量转换成另外一种数据类型。例如通过 form 表单、<code>prompt()</code> 获取过来的数据默认是字符串类型的，需要转换成数字型，才能进行数学运算。</p><p>在浏览器控制台中黑色的输出代表是一串字符，蓝色的代表非字符串。</p><p>通常会出现 3 种类型的转换：</p><ul><li><p>转换为字符串类型<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213448.png" alt="image-20210101164238794"></p></li><li><p>转换为数字型<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213449.png" alt="image-20210101164301861"></p></li><li><p>转换为布尔型<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213450.png" alt="image-20210101164809133"><br>只有代表空、否定的值会被转换为 <code>false</code> ，例如 <code>&#39;&#39;</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code>， 其余值都会被转换为 <code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>));  <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>));  <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;false&#x27;</span>));  <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">12</span>));  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>和其他大多数编程语言一样，也是加减乘除取模五种基本的算术运算符。注意：和 Java 不同，JS 的整数除法结果可以是浮点数，可以使用 <code>parseInt()</code> 给商取整。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213451.png" alt="image-20210102102731653"></p><p>和大多数计算机语言一样，浮点数的存储和计算存在精度丢失问题。不要直接判断两个浮点数是否相等 !</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == <span class="hljs-number">0.3</span>); <span class="hljs-comment">// 结果是 false，0.1 + 0.2 结果为 0.30000000000000004</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0.07</span> * <span class="hljs-number">100</span>); <span class="hljs-comment">// 结果不是 7， 而是：7.000000000000001</span><br></code></pre></td></tr></table></figure><h3 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h3><p>和其他语言一样，也存在前置递增递减和后置递增递减的区别，不再赘述。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（<code>true</code> / <code>false</code>）作为比较运算的结果。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213452.png" alt="image-20210102103411290"></p><p>需要注意的是，如果将字符串与数字进行比较，除了 <code>===</code> 运算符 ，JavaScript 会把字符串隐式转换为数值型再进行比较。空字符串将被转换为 0。非数值字符串将被转换 <code>NaN</code>，比较结果始终为 <code>false</code>。</p><p>比较两个字符串时，从第一个字符往后按字母顺序进行比较。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">18</span> == <span class="hljs-string">&#x27;18&#x27;</span>);<span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">18</span> === <span class="hljs-string">&#x27;18&#x27;</span>);<span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> &gt; <span class="hljs-string">&quot;John&quot;</span>);<span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> &lt; <span class="hljs-string">&quot;John&quot;</span>);<span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> &lt; <span class="hljs-string">&quot;12&quot;</span>);<span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> &gt; <span class="hljs-string">&quot;12&quot;</span>); <span class="hljs-comment">// true，当比较两个字符串时，&quot;2&quot; 大于 &quot;12&quot;，因为（按照字母排序）1 小于 2。</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>);<span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> === <span class="hljs-literal">null</span>);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213453.png" alt="image-20210102115819197"></p><p><code>&amp;&amp;</code> 和 <code>||</code> 都是短路的。短路：左边的表达式值可以确定逻辑运算的结果时，就不再继续运算右边的表达式。</p><p>短路与：表达式1 &amp;&amp; 表达式2，如果第一个表达式的值为真，则返回表达式 2，如果第一个表达式的值为假，则返回表达式 1。</p><p>短路或：表达式1 || 表达式2，如果第一个表达式的值为真，则返回表达式 1，如果第一个表达式的值为假，则返回表达式 2。</p><p>如果表达值式的值不是布尔量会隐式转换为布尔量进行逻辑运算，但是最终返回的是表达式的值本身，而不是表达式所转换得到的布尔量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span> ); <span class="hljs-comment">// 456，而不是 true</span><br><span class="hljs-built_in">console</span>.log( <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">456</span> ); <span class="hljs-comment">// 0，而不是 false</span><br><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> || <span class="hljs-number">456</span> ); <span class="hljs-comment">// 123，而不是 true</span><br><span class="hljs-built_in">console</span>.log( <span class="hljs-number">0</span> || <span class="hljs-number">456</span> ); <span class="hljs-comment">// 456，而不是 true</span><br></code></pre></td></tr></table></figure><h3 id="赋值运算法"><a href="#赋值运算法" class="headerlink" title="赋值运算法"></a>赋值运算法</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213454.png" alt="image-20210102122945155"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213455.png" alt="image-20210102122958713"></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>JS 也有 <code>if-else</code>，<code>switch-case</code> 两种分支控制语句，<code>for</code>，<code>while-do</code>，<code>do-while</code> 三种循环控制语句，语法和 C 语言和 Java 一致，不作介绍。唯一需要注意的是 <code>switch</code> 后面跟的表达式可以是字符串或者数值型，与 <code>case</code> 后面的表达式进行的是全等匹配（<code>===</code>）。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>JS 中创建数组有两种方式：</p><ul><li><p>利用关键字 <code>new</code> 创建数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(); <span class="hljs-comment">// 创建一个新的空数组</span><br></code></pre></td></tr></table></figure></li><li><p>利用 [] 括起来的数组字面量来创建数组，声明数组的同时并给数组元素赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = []; <span class="hljs-comment">//使用数组字面量方式创建空的数组</span><br><span class="hljs-keyword">var</span> strs = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]; <span class="hljs-comment">//使用数组字面量方式创建带初始值的数组</span><br></code></pre></td></tr></table></figure></li></ul><p>和 Java 和 C 语言显著不同的是，由于 JS 是动态类型语言，同一个数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;小白&#x27;</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">28.9</span>];<br></code></pre></td></tr></table></figure><h3 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h3><p>可以通过数组索引（下标）来访问数组元素的序号，数组下标从 0 开始。</p><p>使用数组的 <code>length</code> 属性可以访问数组元素的数量（数组长度）。配合 <code>for</code> 循环可以索引遍历数组中的每一项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]; <span class="hljs-comment">//arr.length 为3</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br><span class="hljs-built_in">console</span>.log(arrStus[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>length</code> 属性是可读写的，当我们数组里面的元素个数发生了变化，这个 <code>length</code> 属性自动跟着一起变化。</p><p>可以通过修改 length 长度来给数组扩容，扩容产生的新增元素默认值是 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>arr.length = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">console</span>.log(arr);  <span class="hljs-comment">//  [ 0, 1, 2, &lt;2 empty items&gt; ]</span><br><span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">4</span>]); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(arr);<span class="hljs-comment">// [ 0, 1, 2, &lt;2 empty items&gt; ]</span><br></code></pre></td></tr></table></figure><p>也可以通过索引范围外的数组元素赋值来扩容数组，JS 中不存在索引越界错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><span class="hljs-built_in">console</span>.log(arr);  <span class="hljs-comment">//[ 0, 1, 2 ]</span><br><span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">4</span>]); <span class="hljs-comment">//undefined</span><br><span class="hljs-built_in">console</span>.log(arr);  <span class="hljs-comment">//[ 0, 1, 2 ]，直接越界访问不报错，但是不会扩容数组</span><br>arr[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//[ 0, 1, 2, &lt;1 empty item&gt;, 4 ]</span><br></code></pre></td></tr></table></figure><p>使用 <code>length</code> 属性作数组索引给元素数组元素赋值，可以实现数组动态增长。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i ++) &#123;<br>    arr[arr.length] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h3><p>函数的两种声明方式：</p><ul><li><p>自定义函数方式（命名函数）：利用函数关键字 <code>function</code> 声明函数。因为预解析的存在，调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面。由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum，同样函数名也属于标识符，要遵循前面提到的标识符规范。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    ...   <span class="hljs-comment">//函数体代码</span><br>&#125;<br>fn(); <span class="hljs-comment">//通过函数名调用，调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</span><br></code></pre></td></tr></table></figure></li><li><p>函数表达式方式（匿名函数）：声明一个变量，变量里面存储的是一个函数对象，函数本身是没有名字的（匿名），只能通过变量名来调用函数，函数调用的代码必须写到函数体后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    ...<br>&#125;; <span class="hljs-comment">// 这是函数表达式写法，匿名函数后面跟分号结束</span><br>fn(); <span class="hljs-comment">// 通过变量名调用函数，函数调用必须写到函数体下面 </span><br></code></pre></td></tr></table></figure></li></ul><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。</p><p>JS 中不会根据实参和形参列表的匹配情况进行函数重载，可能存在函数形参和实参个数不匹配的问题。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213456.png" alt="image-20210103142023058"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(num1 + num2);<br>&#125;<br>sum(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);             <span class="hljs-comment">// 形参和实参个数相等，输出正确结果</span><br>sum(<span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>, <span class="hljs-number">700</span>);   <span class="hljs-comment">// 实参个数多于形参，只取到形参的个数</span><br>sum(<span class="hljs-number">200</span>);                  <span class="hljs-comment">// 实参个数少于形参，形参的默认值是 undefined，结果为 NaN</span><br></code></pre></td></tr></table></figure><p>执行到函数体中的 <code>return</code> 语句时，函数会停止执行，并返回指定的值。如果函数没有 <code>return</code> 语句，执行完整个函数体后，返回的值是 <code>undefined</code>。<code>return</code> 只能返回一个值。如果用逗号隔开多个返回值，则实际上一个逗号表达式，整个逗号表达式的值是最后一个表达式的值。但在函数调用时，各个实参之间是用逗号隔开的，参数列表中的逗号就不是逗号运算符。</p><p>当我们不确定有多少个参数传递的时候，可以用 <code>arguments</code> 对象来获取。在 JavaScript 中，<code>arguments</code> 是当前函数的一个内置对象。所有函数都内置了一个 <code>arguments</code> 对象，<code>arguments</code> 对象中存储了传递的所有实参。<code>arguments</code> 展示形式是一个伪数组，可以通过数组索引获取第几个参数，也可以配合 <code>length</code> 属性来遍历所有实参，但是不能使用普通数组中的 <code>push()</code> , <code>pop()</code> 等方法。</p><p>函数的形参也可以看做是一个变量，当把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。当把引用类型变量传给形参时，其实是把变量在栈空间里保存的引用地址复制给了形参，形参和实参指向的是同一个堆地址，所以操作的是同一个对象实例。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>JavaScript 在 ES 6 标准前只有以下两种作用域，没有块级作用域：</p><ul><li>全局作用域：作用于所有代码执行的环境（整个 <code>&lt;script&gt;</code> 标签内部）或者一个独立的 JS 文件。</li><li>局部作用域：作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。</li></ul><p>在 JavaScript 中，根据作用域的不同，变量可以分为两种：</p><ul><li>全局变量：在函数外部通过 <code>var</code> 声明的变量或者任意位置不用 <code>var</code> 声明就直接使用的变量，后一种是隐式全局变量（implicit globals），实际上是 <code>window</code> 对象的一个属性，可以使用 <code>delete</code> 操作符删除这些属性，虽然也全局作用域可见，但是和真正的全局变量有一点差异，一般不建议使用。全局变量拥有全局作用域，在任何一个地方都可以使用，只有在浏览器标签页面关闭时才会被销毁，因此比较占内存。</li><li>局部变量：在函数内部通过 <code>var</code> 声明的变量，函数的形参实际上也是局部变量。局部变量拥有局部作用域，只能在该函数内部使用，当函数运行结束后，就会被销毁，因此更节省内存空间。</li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>如果函数声明中还有另外的函数声明，那么在这个局部作用域中就又诞生一个局部作用域，根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，这种机制就称为作用域链。<br>示例 1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">2</span>;<span class="hljs-comment">// 在函数 f1() 局部作用域声明一个新的局部变量 i 并初始化，不影响全局变量 i</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>        i = <span class="hljs-number">3</span>;<span class="hljs-comment">// f2() 函数内部可以访问外部函数的局部变量</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i=&#x27;</span> + i); <span class="hljs-comment">//i=3</span><br>    &#125;<br>    f2();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i=&#x27;</span> + i);<span class="hljs-comment">// i=3</span><br>&#125;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br>f1();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i=&#x27;</span> + i);<span class="hljs-comment">//i=1</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    i = <span class="hljs-number">2</span>;<span class="hljs-comment">// f1() 可以访问修改全局变量 i </span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> i = <span class="hljs-number">3</span>;<span class="hljs-comment">// f2() 函数内部声明一个新的局部变量 i 并初始化</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i=&#x27;</span> + i); <span class="hljs-comment">//i=3</span><br>    &#125;<br>    f2();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i=&#x27;</span> + i);<span class="hljs-comment">// i=2</span><br>&#125;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br>f1();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i=&#x27;</span> + i);<span class="hljs-comment">//i=2</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> a = b = c = <span class="hljs-number">9</span>;<span class="hljs-comment">// 等同于 c = 9;b = c;var a = b; c 和 b 会被当做全局变量</span><br>    <span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">// 9</span><br><span class="hljs-built_in">console</span>.log(b);<span class="hljs-comment">// 9</span><br><span class="hljs-built_in">console</span>.log(c);<span class="hljs-comment">// 9</span><br>&#125;<br>f1();<br><span class="hljs-built_in">console</span>.log(c);<span class="hljs-comment">// 9</span><br><span class="hljs-built_in">console</span>.log(b);<span class="hljs-comment">// 9</span><br><span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">// ReferenceError: a is not defined</span><br></code></pre></td></tr></table></figure><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。</p><ul><li>预解析：在当前作用域下，JS 代码执行之前，浏览器会默认把通过 <code>var</code> 声明的变量和通过 <code>function</code> 声明的函数在内存中进行提前声明。</li><li>代码执行： 从上到下顺序解释执行 JS 语句。</li></ul><p>建议始终在作用域顶部声明变量（全局代码的顶部和函数体代码的顶部），这可以清楚知道哪些变量是全局作用域，哪些变量是局部作用域。</p><h3 id="变量预解析"><a href="#变量预解析" class="headerlink" title="变量预解析"></a>变量预解析</h3><p>变量提升（Hoisting）： 变量的 <code>var</code> 声明语句会被提升到当前作用域的最上面，变量的赋值语句不会提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(num);<br><span class="hljs-keyword">var</span> num = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">console</span>.log(num);<br>&#125;<br><span class="hljs-built_in">console</span>.log(num);<br><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log(num);<br>fn();<br></code></pre></td></tr></table></figure><p>经过预解析后等效为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> num;<br><span class="hljs-built_in">console</span>.log(num);<span class="hljs-comment">// undefined</span><br>num = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">console</span>.log(num);<span class="hljs-comment">// 20</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(num);<span class="hljs-comment">// undefined</span><br>num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log(num);<span class="hljs-comment">// 10</span><br>fn();<br></code></pre></td></tr></table></figure><h3 id="函数预解析"><a href="#函数预解析" class="headerlink" title="函数预解析"></a>函数预解析</h3><p>函数提升： 命名函数的 <code>function</code> 声明语句会被提升到当前作用域的最上面，因此在函数声明之前就可以调用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fn();<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;halo&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>经过预解析后等效为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;halo&#x27;</span>);<br>&#125;<br>fn();<br></code></pre></td></tr></table></figure><p>匿名函数的声明是通过声明变量实现的，进行的实际上是变量提升，因此在没有让变量真正地引用一个函数对象之前，不能调用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fn();<br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;halo&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>经过预解析后等效为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fn;<br>fn();<span class="hljs-comment">// TypeError: fn is not a function</span><br>fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;halo&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>在 JavaScript 中，现阶段我们可以采用三种方式创建对象（object）：</p><ul><li><p>利用字面量创建对象，可以用花括号 <code>&#123;&#125;</code> 括起来的键值对的形式表示对象，冒号前面的键是对象的属性名或者方法名，冒号后面的值是属性值或者方法体。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> star = &#123;<br>    name : <span class="hljs-string">&#x27;pink&#x27;</span>,<br>    age : <span class="hljs-number">18</span>,<br>    sex : <span class="hljs-string">&#x27;男&#x27;</span>,<br>    sayHi : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    alert(<span class="hljs-string">&#x27;大家好啊~&#x27;</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>利用 <code>new Object()</code> 创建对象，然后给对象不存在的属性赋值，就相当于给对象动态地添加属性或者方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> andy = <span class="hljs-keyword">new</span> Obect();<br>andy.name = <span class="hljs-string">&#x27;pink&#x27;</span>;<br>andy.age = <span class="hljs-number">18</span>;<br>andy.sex = <span class="hljs-string">&#x27;男&#x27;</span>;<br>andy.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    alert(<span class="hljs-string">&#x27;大家好啊~&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用构造函数创建对象：构造函数是一种特殊的函数，主要用来创建某一类对象并初始化，即为对象成员变量赋初始值，它总与 <code>new</code> 操作符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。构造函数的首字母通常要大写，函数内的属性和方法前面需要添加 <code>this</code> 关键字，<code>this</code> 指向正在创建的对象，构造函数里面的代码可以给这个新对象添加属性和方法。使用 <code>new</code> 调用构造函数会自动返回所创建的新对象，不需要使用 <code>return</code> 语句返回。构造函数抽象了对象的公共部分，封装到了函数里面，可以用来泛指某一大类（class），通过 <code>new</code> 关键字创建对象的过程我们也称为对象实例化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.sex = sex;<br>    <span class="hljs-built_in">this</span>.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-string">&#x27;我的名字叫：&#x27;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;，年?：&#x27;</span> + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&#x27;，性?：&#x27;</span> + <span class="hljs-built_in">this</span>.sex);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> bigbai = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;大白&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-keyword">var</span> smallbai = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;小白&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;男&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(bigbai.name);<br><span class="hljs-built_in">console</span>.log(smallbai.name);<br></code></pre></td></tr></table></figure></li></ul><h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><p>可以通过 <code>.</code> 或者 <code>[]</code> 来访问对象里面的属性，方括号里面只能是字符串，属性名必须先用引号括起来成字符串常量。可以通过 <code>对象.方法名()</code> 来调用对象的方法，方法名字后面一定加括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(star.name) <br><span class="hljs-built_in">console</span>.log(star[<span class="hljs-string">&#x27;name&#x27;</span>]) <br>star.sayHi();<br></code></pre></td></tr></table></figure><p><code>for-in</code> 语句用于对对象的所有属性进行操作，语法中的变量名可以是任何符合命名规范的标识符  ，通常我们会将这个变量写为 k 或者 key。<code>for-in</code> 语句也可以用来遍历数组中的所有元素，这时候 k 代表数组索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> obj) &#123;<br><span class="hljs-built_in">console</span>.log(k); <span class="hljs-comment">// 这里的 k 是属性名</span><br><span class="hljs-built_in">console</span>.log(obj[k]); <span class="hljs-comment">// 这里的 obj[k] 是属性值</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JS-内置对象"><a href="#JS-内置对象" class="headerlink" title="JS 内置对象"></a>JS 内置对象</h2><p>JavaScript 中的对象分为 3 种：自定义对象、内置对象、浏览器对象，前面两种对象属于 ECMAScript 规范，浏览器对象属于 JS 独有。内置对象就是指 JS 语言自带的一些对象，这些对象提供了一些常用的功能（属性和方法），帮助开发者快速开发。</p><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.PI <span class="hljs-comment">// 圆周率</span><br><span class="hljs-built_in">Math</span>.floor()  <span class="hljs-comment">// 向下取整</span><br><span class="hljs-built_in">Math</span>.ceil()            <span class="hljs-comment">// 向上取整</span><br><span class="hljs-built_in">Math</span>.round()          <span class="hljs-comment">// 四舍五入版 就近取整   注意 -3.5   结果是  -3 </span><br><span class="hljs-built_in">Math</span>.abs() <span class="hljs-comment">// 绝对值</span><br><span class="hljs-built_in">Math</span>.max()/<span class="hljs-built_in">Math</span>.min()<span class="hljs-comment">// 求最大和最小值 </span><br><span class="hljs-built_in">Math</span>.random() <span class="hljs-comment">// 方法可以随机返回一个小数，其取值范围是 [0，1)</span><br><span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (max - min + <span class="hljs-number">1</span>)) + min  <span class="hljs-comment">// 得到一个两个数(max,min)之间的随机整数，包括两个数在内</span><br></code></pre></td></tr></table></figure><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213457.png" alt="image-20210107192415227"></p><p><strong>注意：<code>getMonth()</code> 和 <code>getDay()</code> 返回的值是以 0 开始计数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-keyword">var</span> year = time.getFullYear();<br><span class="hljs-keyword">var</span> month = time.getMonth() + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> dates = time.getDate();<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;星期日&#x27;</span>, <span class="hljs-string">&#x27;星期一&#x27;</span>, <span class="hljs-string">&#x27;星期二&#x27;</span>, <span class="hljs-string">&#x27;星期三&#x27;</span>, <span class="hljs-string">&#x27;星期四&#x27;</span>, <span class="hljs-string">&#x27;星期五&#x27;</span>, <span class="hljs-string">&#x27;星期六&#x27;</span>];<br><span class="hljs-keyword">var</span> day = time.getDay();<br><span class="hljs-keyword">var</span> h = time.getHours();<br>h = h &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + h : h;<span class="hljs-comment">// 给时分秒补 0</span><br><span class="hljs-keyword">var</span> m = time.getMinutes();<br>m = m &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + m : m;<span class="hljs-comment">// 给时分秒补 0</span><br><span class="hljs-keyword">var</span> s = time.getSeconds();<br>s = s &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + s : s;<span class="hljs-comment">// 给时分秒补 0</span><br><span class="hljs-keyword">var</span> date = year + <span class="hljs-string">&#x27;年&#x27;</span> + month + <span class="hljs-string">&#x27;月&#x27;</span> + dates + <span class="hljs-string">&#x27;日&#x27;</span> + arr[day] + h + <span class="hljs-string">&#x27;:&#x27;</span> + m + <span class="hljs-string">&#x27;:&#x27;</span> + s;<br></code></pre></td></tr></table></figure><p>Date 对象需要实例化后才能使用，如果调用构造函数 <code>Date()</code> 不写参数，就返回执行到 <code>new</code> 语句时的当前的系统时间，如果 <code>Date()</code> 里面写参数，就返回参数里面的时间。例如日期格式字符串为 <code>‘2019-5-1’</code>，可以写成 <code>new Date(&#39;2019-5-1&#39;)</code>  或者 <code>new Date(&#39;2019/5/1&#39;)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-built_in">console</span>.log(now.getFullYear());<br></code></pre></td></tr></table></figure><p>Date 对象中存储了某一时刻距离 1970年1月1日（世界标准时间）起的毫秒数，经常利用这个数值来进行天、时、分、秒的换算。可以利用 <code>valueOf()</code> 和 <code>getTime()</code> 方法来得到这个数值，也可以使用一元操作符 <code>+</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-built_in">console</span>.log(now.valueOf())<br><span class="hljs-built_in">console</span>.log(now.getTime())<br><span class="hljs-keyword">var</span> now = + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-keyword">var</span> now = <span class="hljs-built_in">Date</span>.now();   <span class="hljs-comment">// HTML5 中提供的方法，有兼容性问题</span><br></code></pre></td></tr></table></figure><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">23</span>];<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true ，instanceof 运算符，可以判断一个对象是否属于某种类型</span><br><span class="hljs-built_in">console</span>.log(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(arr)); <span class="hljs-comment">// true，Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(obj)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>下面四个方法用来添加删除数组元素。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213458.png" alt="image-20210107193544194"></p><p><code>reverse()</code>，<code>sort()</code> 对整个数组元素反转和排序。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213459.png" alt="image-20210107193902874"></p><p><code>sort()</code> 需要传入一个比较策略，根据传入的函数对象来排序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">64</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>];<br>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br><span class="hljs-keyword">return</span> b - a; <span class="hljs-comment">// 降序</span><br><span class="hljs-comment">// return a - b; // 升序</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><code>indexOf()</code>，<code>lastIndexOf()</code> 用来查找某一个元素元素在数组中的位置。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213460.png" alt="image-20210107193732756"></p><p><code>toString()</code>， <code>join()</code> 用来把数组转换为字符串。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213461.png" alt="image-20210107194359554"></p><p><code>concat()</code>，<code>slice()</code>，<code>splice()</code> 用来连接数组和删除数组。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213462.png" alt="image-20210107194417328"></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>不可变性：字符串对象的值不可变，虽然看上去可以给字符串对象重新赋值，但其实是引用对象指向了内存中新开辟的空间，这个空间中存放了新的字符串对象。由于字符串的不可变，字符串所有的方法，都不会修改字符串本身，而是返回一个新的字符串，因此在大量拼接字符串的时候会有效率问题。可以先将需要拼接的字符串依次传入一个数组，然后使用 <code>array.join(&#39;&#39;)</code> 把整个数组的字符串拼接，可以大大提高效率。</p><p><code>indexOf()</code>，<code>lastIndexOf()</code> 方法用于查找字符串中的字符出现位置。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213463.png" alt="image-20210107200320304"></p><p><code>charAt()</code>，<code>charCodeAt()</code>，<code>str[]</code> 根据索引返回字符。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213464.png" alt="image-20210107200723031"></p><p><code>concat()</code>，<code>substr()</code>，<code>slice()</code>，<code>substring()</code> 方法用于字符串连接和截取。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192213465.png" alt="image-20210107200932002"></p><p><code>replace()</code> 方法可以进行简单的字符串替换，支持使用正则表达式进行匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-string">&#x27;Apples are round, and apples are juicy&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(p.replace(<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>));  <span class="hljs-comment">//在字符串中用一些字符替换另一些字符，Apples are round, and oranges are juicy</span><br></code></pre></td></tr></table></figure><p><code>split()</code> 方法用于切分字符串，它可以将字符串切分为字符串数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;a-b-cc-dd-bbb&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.split(<span class="hljs-string">&#x27;,&#x27;</span>)); <span class="hljs-comment">// 返回的是一个数组 [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;cc&#x27;, &#x27;dd&#x27;, &#x27;bbb&#x27; ]</span><br></code></pre></td></tr></table></figure><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>为了方便操作基本数据类型，JS 提供了基本类型的包装类型，用来把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。除了 <code>null</code> 和 <code>undefined</code> ，其他的基本类型都有对应的包装类型。例如 string，number，boolean，对应了<code>String</code>、<code>Number</code>和 <code>Boolean</code>三种基本包装类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-keyword">var</span> len = str.length;<br><span class="hljs-built_in">console</span>.log(len);<br></code></pre></td></tr></table></figure><p>按道理基本数据类型是没有属性和方法的，对象才有属性和方法，但上面的代码却不会报错，这是因为 JS 会把基本数据类型变量自动包装成复杂数据类型：先创建临时的包装类型对象，然后再访问属性或者方法，其执行过程如下 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<span class="hljs-comment">// typeof str === &#x27;string&#x27;, str instanceof String == flase </span><br><span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(str); <span class="hljs-comment">// 1.创建 String 类型的一个临时对象,typeof temp === &#x27;object&#x27;,temp instanceof String == true </span><br>len = temp.length; <span class="hljs-comment">// 2 在实例上访问方法或者属性</span><br>temp = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 3.销毁这个临时实例</span><br><span class="hljs-built_in">console</span>.log(len);<br></code></pre></td></tr></table></figure><p>访问完属性或者方法之后，就立即销毁该对象，这就意味着在运行时为基本类型值添加属性和方法是没有意义的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>str.sex = <span class="hljs-string">&#x27;male&#x27;</span>;<span class="hljs-comment">// 创建了一个基本包装类型的临时对象，然后给这个对象的 sex 属性赋值为 male，这条语句结束，刚才创建的临时对象被销毁</span><br><span class="hljs-built_in">console</span>.log(str.sex);  <span class="hljs-comment">// undefined，试图获取 str.sex 的值时，又会创建一个基本包装类型的对象，但是新创建的对象没有 sex 属性</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.bilibili.com/video/BV1Sy4y1C7ha">B 站视频：JavaScript 基础语法</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html">阮一峰：Javascript 诞生记</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML 和 CSS 学习笔记</title>
    <link href="/2021/01/09/HTML+CSS/"/>
    <url>/2021/01/09/HTML+CSS/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML-简介"><a href="#HTML-简介" class="headerlink" title="HTML 简介"></a>HTML 简介</h2><h3 id="什么是-HTML"><a href="#什么是-HTML" class="headerlink" title="什么是 HTML"></a>什么是 HTML</h3><p>HTML 指的是超文本标记语言（Hyper Text Markup Language），它是一种用来描述网页的语言。</p><p>超文本（hypertext）中有很多超链接（hyperlink）指向到其他资源，通过这些链接可以访问其他（网页）资源。此外相比普通文本它还可以插入图片、声音、动画、多媒体等内容（超越了文本限制 ）。</p><p>标记语言（markup language）是指使用一套标记标签（markup tag）将文本、图片、声音、视频等元素包 裹起来，在浏览器中以某种样式把这些内容展现出来。因此 HTML 严格来说不能算一种计算机编程语言，而是一种标记语言。</p><p>访问网页的本质就是访问通过网络将服务器上的使用 HTML 编写好的网页文件（常见以 .htm 或 .html 后缀结尾）下载到本地并使用浏览器打开渲染它们。</p><h3 id="常用浏览器"><a href="#常用浏览器" class="headerlink" title="常用浏览器"></a>常用浏览器</h3><p>浏览器是网页显示、运行的平台。常用的浏览器五大浏览器有 IE、火狐（Firefox）、谷歌（Chrome）、Safari 和 Opera 等。</p><p>浏览器内核（渲染引擎）： 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157022.png" alt="image-20210405180541245"></p><h3 id="Web-标准"><a href="#Web-标准" class="headerlink" title="Web 标准"></a>Web 标准</h3><p>Web 标准是由 W3C（万维网联盟）组织和其他标准化组织（例如 ECMA）制定的一系列标准的集合。</p><p>同一个 HTML 文件，如果不同厂家的浏览器的实现不一样,渲染出来的效果可能有很大的差异，以往的 Web 开发者要为网页的兼容性做大量的工作。Web 标准化之后，不同厂家的浏览器针只需对 Web 标准做实现，就能达到一个比较统一的效果。</p><p>Web 标准主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面，具体来说就是 <a href="https://html.spec.whatwg.org/multipage/">HTML</a>、<a href="https://www.w3.org/Style/CSS/">CSS</a> 和 <a href="https://262.ecma-international.org/11.0/">JavaScript</a> 这三项规范。最好将网页的结构、样式、行为相分离：结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157023.png" alt="image-20210405181122887"></p><h2 id="HTML-语法规范"><a href="#HTML-语法规范" class="headerlink" title="HTML 语法规范"></a>HTML 语法规范</h2><h3 id="基本语法概述"><a href="#基本语法概述" class="headerlink" title="基本语法概述"></a>基本语法概述</h3><ol><li>HTML 标签是由尖括号包围的关键词，例如 <code>&lt;html&gt;</code>，标签中包裹的内容称为 HTML 元素。</li><li>HTML 标签通常是成对出现的，例如 <code>&lt;html&gt;</code> 和 <code>&lt;/html&gt;</code> ，我们称为双标签。标签对中的第一个标签是开始标签，第二个标签是结束标签。</li><li>有些特殊的标签只能单个标签出现，例如 <code>&lt;br/&gt;</code>，我们称为单标签或者自闭合标签，单标签中的斜杠可以省略。</li></ol><h3 id="标签关系"><a href="#标签关系" class="headerlink" title="标签关系"></a>标签关系</h3><p>双标签关系可以分为两类：包含关系和并列关系。</p><p>包含关系 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>并列关系</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="骨架标签"><a href="#骨架标签" class="headerlink" title="骨架标签"></a>骨架标签</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157024.png" alt="image-20210405210504386"></p><p>每个网页都会有一套基本的结构标签（也称为骨架标签），页面内容就在这些骨架标签内书写。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157025.png" alt="image-20210405210319881"></p><h3 id="文档类型声明"><a href="#文档类型声明" class="headerlink" title="文档类型声明"></a>文档类型声明</h3><p><code>&lt;!DOCTYPE&gt; </code>文档类型声明（DTD，Document Type Definition），作用是指示浏览器使用哪种 HTML 版本来解析网页。<code>&lt;!DOCTYPE&gt;</code>  声明位于文档中的最前面的位置，处于 <code>&lt;html&gt;</code> 标签之前。</p><p><code>&lt;!DOCTYPE html&gt;</code> 的意思是：当前页面采取的是 HTML 5 版本来解析该文档.，在更老的文档中（例如 HTML 4 或 XHTML）声明更加复杂：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- HTML <span class="hljs-number">4.01</span> Strict --&gt;<br>&lt;!DOCTYPE HTML PUBLIC <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;<br>&lt;!-- HTML <span class="hljs-number">4.01</span> Transitional --&gt;<br>&lt;!DOCTYPE html PUBLIC <span class="hljs-string">&quot;-//W3C//DTD XHTML 1.1//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;</span>&gt;   <br>&lt;!-- XHTML <span class="hljs-number">1.1</span>  --&gt;<br>&lt;!DOCTYPE HTML PUBLIC <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>注意：<code>&lt;!DOCTYPE&gt;</code> 文档类型声明不算作 HTML 标签，它是一条声明，确保浏览器按照最佳的相关规范进行渲染。</strong></p><h3 id="页面语言"><a href="#页面语言" class="headerlink" title="页面语言"></a>页面语言</h3><p><code>&lt;html&gt;</code> 标签中有一个 <code>lang</code> 属性用来指定当前文档对应的人类语言。</p><ol><li>值为 <code>en</code> 定义语言为英语。</li><li>值为 <code>zh-CN</code> 定义语言为中文。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个属性主要用来提示浏览器和搜索引擎当前网页所采用的语言，例如浏览器可以通过这个属性自动翻译网页，搜索引擎可以根据页面语言过滤搜索结果。</p><p><strong>注意：<code>lang=en</code> 的文档并不是只能显示英文，也可以显示其他语言，同样 <code>lang=zh-CN</code> 的文档也可以显示英文。</strong></p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>在 <code>&lt;head&gt;</code> 标签内，可以通过 <code>&lt;meta&gt;</code> 标签的 <code>charset</code> 属性来规定当前 HTML 文档应该使用哪种字符编码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot; UTF-8&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>中文环境下 <code>charset</code> 常用的值有：GB2312 、BIG5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符。</p><p><strong>注意：必须指定正确的 <code>charset</code>，否则可能引起乱码。一般情况下，统一使用“UTF-8”编码，注意不要写成 “utf8 或 “UTF8”。</strong></p><h2 id="HTML-常用标签"><a href="#HTML-常用标签" class="headerlink" title="HTML 常用标签"></a>HTML 常用标签</h2><p>为了使网页更具有语义化，经常会在页面中用到各种不同的标签。根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰，这也称为 HTML 语义化。</p><h3 id="标题标签-lt-h1-gt-lt-h6-gt"><a href="#标题标签-lt-h1-gt-lt-h6-gt" class="headerlink" title="标题标签 &lt;h1&gt; - &lt;h6&gt;"></a>标题标签 <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code></h3><p>HTML 提供了 6 个等级的网页标题，即 <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>。作为网页或者段落的标题使用，并且依据重要性递减。</p><p>标签语义：单词 head 的缩写，意为头部、标题。</p><ol><li>加了标题样式的文字样式默认会加粗，字号也会依次变大。</li><li>一个标题独占一行。</li></ol><h3 id="段落-lt-p-gt"><a href="#段落-lt-p-gt" class="headerlink" title="段落 &lt;p&gt;"></a>段落 <code>&lt;p&gt;</code></h3><p>段落标签 <code>&lt;p&gt;</code> 标签用于定义段落，它可以把 HTML 文档分割为若干段落。</p><p>标签语义：单词 paragraph 的缩写，意为段落。</p><ol><li>在一个段落中的文本会根据浏览器窗口的大小自动换行。</li><li>段落和段落之间会自动留有空白间隙（垂直间距）隔开。</li></ol><h3 id="换行-lt-br-gt"><a href="#换行-lt-br-gt" class="headerlink" title="换行 &lt;br&gt;"></a>换行 <code>&lt;br&gt;</code></h3><p>换行标签 <code>&lt;br&gt;</code> 用于插入换行符，换行标签后面的文本在下一行显示。在 HTML 中，一个段落中的文字会从左到右排满才会自动换行，如果希望在某处强制换行，就需要使用换行标签 <code>&lt;br/&gt;</code> 。</p><p>标签语义：单词 break 的缩写，意为打断、换行。</p><ol><li><code>&lt;br&gt;</code> 是个单标签。</li><li><code>&lt;br&gt;</code> 标签只是简单地开始新的一行，跟开始新段落不一样，段落之间往往会插入一些垂直的间距。</li></ol><h3 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h3><p>在网页中，有时需要为文字设置<strong>粗体</strong>、<em>斜体</em>或<u>下划线</u>等效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的样式显示。</p><p>标签语义：突出该部分文字的重要性。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157026.png" alt="image-20210405221520124"></p><p><strong>注意：<code>&lt;strong&gt;</code> 和 <code>&lt;b&gt;</code>的区别：<code>&lt;b&gt;</code> 标签是一个实体标签，它所包围的字符将被设为 bold（粗体），单纯指的是视觉层面上的“加粗”。而 <code>&lt;strong&gt;</code> 标签是一个逻辑标签，它的作用是加强字符的语气，“强调”可以用字体加粗来强调，也可以定义成其他样式的强调效果，比如字体加下划线，比如字体变色等等。只是在绝大数浏览器中，加强字符的语气默认是通过字符变为 bold（粗体）来实现的，恰巧跟 <code>&lt;b&gt;</code> 标签的效果一致。因此如果想做语义逻辑上的强调推荐使用 <code>&lt;strong&gt; </code> 而不是 <code>&lt;b&gt;</code>。</strong></p><h3 id="块标签-lt-div-gt-和行内标签-lt-span-gt"><a href="#块标签-lt-div-gt-和行内标签-lt-span-gt" class="headerlink" title="块标签 &lt;div&gt; 和行内标签 &lt;span&gt;"></a>块标签 <code>&lt;div&gt;</code> 和行内标签 <code>&lt;span&gt;</code></h3><p><code>&lt;div&gt; </code>和<code> &lt;span&gt;</code> 是没有特殊语义的，它们就是一个用来装内容的普通盒子。</p><p>标签语义：div 是 division 的缩写，表示分割、分区。span 意为跨度、跨距。</p><ol><li><code>&lt;div&gt;</code> 标签用来布局，但是在一行只能放一个 <code>&lt;div&gt;</code>。 </li><li><code>&lt;span&gt;</code> 标签用来布局，一行上可以放多个 <code> &lt;span&gt;</code>。</li></ol><h3 id="图像标签-lt-img-gt"><a href="#图像标签-lt-img-gt" class="headerlink" title="图像标签 &lt;img&gt;"></a>图像标签 <code>&lt;img&gt;</code></h3><p><code>&lt;img&gt;</code> 标签用于定义 HTML 页面中的图像。</p><p>标签语义：img 是单词 image 的缩写，意为图像。 </p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157028.png" alt="image-20210406093620272"></p><ol><li>图像标签可以拥有多个属性，必须写在标签名的后面。<code>src</code> 是 <code>&lt;img&gt; </code> 标签的必须属性，它用于指定图像文件的访问路径，可以是相对路径，也可以是绝对路径。<br>相对路径：从当前文档所在的这个位置出发，去寻找目标图片，即图片对于当前 HTML 页面的相对位置。<br>绝对路径：是指目录下的绝对位置，通过该路径可以直接到达目标位置，通常从盘符开始的路径，例如，<code>C:\users\lons\desktop\logo.gif</code> 或完整的网络地址：<code>https://www.baidu.com/image/logo.gif</code>。 </li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li><li>属性采取键值对的格式，即 key=”value” 的格式，属性 =”属性值”。属性值最好用英文引号括起来，否则当属性值中出现空格时将不能正确解析键值对，英文的单双引号都可以，推荐使用双引号。</li></ol><h3 id="超链接标签-lt-a-gt"><a href="#超链接标签-lt-a-gt" class="headerlink" title="超链接标签 &lt;a&gt;"></a>超链接标签 <code>&lt;a&gt;</code></h3><p>在 HTML 标签中，<code>&lt;a&gt;</code> 标签用于定义超链接，作用是从一个页面链接到另一个页面。</p><p>标签语义：单词 anchor 的缩写，意为：锚。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157029.png" alt="image-20210406093948185"></p><p>链接分类：</p><ol><li>外部链接：例如 <code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;</code>。</li><li>内部链接：同一个网站内部页面之间的相互链接. 直接链接内部页面名称即可，例如 <code>&lt;a href=&quot;index.html&quot;&gt;首页&lt;/a &gt;</code>。</li><li>下载链接：如果 <code>href</code> 的属性值地址指向一个文件或者压缩包，会下载这个文件。</li><li>网页元素链接：在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接，即使用 <code>&lt;a&gt;</code> 标签将这些元素包裹起来。</li><li>锚点链接:：点击链接时可以快速定位到页面中的某个位置，例如点击 <code>&lt;a href=&quot;#target&quot;&gt;超链接&lt;/a&gt;</code> 这个链接吗，页面将滚动到 <code>id</code> 属性值为 <code>target</code> 的标签所在位置。</li><li>空链接：如果暂时无法确定链接目标时，可以使用空链接，<ul><li><code>&lt;a&gt;首页&lt;/a&gt;</code>：没有 href 属性，将失去超链接的意义，不会添加链接的样式，也无法被点击，因此 <code>&lt;a&gt;</code> 标签的 <code>href</code> 属性是必须的。</li><li><code>&lt;a href=&quot;&quot;&gt;超链接&lt;/a&gt;</code> ： <code>href</code> 值为空时默认跳转到本页面，即重新刷新一次页面。</li><li><code>&lt;a href=&quot;#&quot;&gt;超链接&lt;/a&gt;</code>：属于锚点链接，这样写等价于 <code>&lt;a href=&quot;#top&quot;&gt;&lt;/a&gt;</code>，即滚动到页面顶部。</li><li><code>&lt;a href=&quot;###&quot;&gt;超链接&lt;/a&gt;</code>：Chrome 和 IE 11 以上支持，不再滚动到页面顶部，但是还是会修改地址栏。</li><li><code>&lt;a href=&quot;javascript:void(0);&quot;&gt;超链接&lt;/a&gt;</code>：当 <code>href</code> 值为 Javascript 伪协议，点击该链接后会执行其中的代码，并把最后一条 JavaScript 语句的字符串值作为新文档的内容显示出来。而 <code>void(0);</code> 把返回值指定为 <code>underfined</code>，由于没有返回值来作为新文档来显示的值，因此并不改变当前显示的文档，从而较好的实现了空链接效果，也不会产生什么副作用。</li><li> <code>&lt;a href=&quot;javascript:;&quot;&gt;超链接&lt;/a&gt;</code>：同上，<code>href</code> 值为代码为空的 JavaScript 伪协议。</li></ul></li></ol><h3 id="注释标签-lt-gt"><a href="#注释标签-lt-gt" class="headerlink" title="注释标签 &lt;!----&gt;"></a>注释标签 <code>&lt;!----&gt;</code></h3><p>HTML 中的注释以 <code>&lt;!-- </code>开头，以 <code>--&gt; </code>结束。 </p><p>使用注释标签可以在 HTML 源代码中添加一些注释说明文字，方便开发者阅读和理解 HTML 文档，这些说明文字最终不会在浏览器中渲染出来。 </p><h3 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h3><p>在 HTML 中，某些字符是预留的。在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。例如显示小于号，我们必须这样写：<code>&amp;lt; </code> 或者 <code>&amp;#60;</code>，使用实体名称 <code>&amp;lt;  </code>而不是实体编号 <code>&amp;#60;</code> 的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称，但对实体编号的支持却很好。</p><p>此外浏览器在显示时会合并相连的多个空格为一个空格，有时需使用字符实体 <code>&amp;nbsp</code> 不间断空格（non-breaking space）来避免空格被截短。 </p><p>HTML 中常用的字符实体：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157030.png" alt="image-20210406141355197"></p><h3 id="表格标签-lt-table-gt"><a href="#表格标签-lt-table-gt" class="headerlink" title="表格标签 &lt;table&gt;"></a>表格标签 <code>&lt;table&gt;</code></h3><p>表格标签<code>&lt;table&gt;</code>主要用于规整的显示、展示数据，而不是用来布局页面的。</p><ol><li><code>&lt;table&gt;&lt;/table&gt;</code> 用于定义整个表格的标签，在表格的最外层。</li><li><code>&lt;tr&gt;&lt;/tr&gt;</code> 用于定义表格中的行，必须嵌套在 <code>&lt;table&gt;&lt;/table&gt;</code>标签中。字母 tr 指表格行（table row）。</li><li><code>&lt;td&gt;&lt;/td&gt;</code> 用于定义表格中的单元格，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code> 标签中。字母 td 指表格数据（table data），即数据单元格的内容。</li><li><code>&lt;th&gt; </code> 用于定义表头部分（table head）的单元格，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中。一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容会自动加粗居中显示。</li><li>表格结构标签：因为表格可能很长，为了更好地显示表格的语义，可以将表格分割成表格头部和表格主体两大部分。分别用：<code>&lt;thead&gt;</code>标签表示表格的头部区域，<code>&lt;tbody&gt;</code>标签表示表格的主体区域。这样可以更好地分清表格结构。</li></ol><p><code>&lt;table&gt;</code> 标签常见属性（后面多通过 CSS 来设置）：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157031.png" alt="image-20210406143703594"></p><p>合并单元格的本质是是扩展单元格所占的行或者列，合并单元格思路：</p><ol><li>先确定是跨行还是跨列合并。</li><li>找到目标单元格：跨行：最上侧单元格为目标单元格，写合并代码，跨列：最左侧单元格为目标单元格。</li><li>写合并代码 ：写上合并方式 = 合并的单元格数量。跨行合并：rowspan=“合并单元格的个数”、跨列合并：colspan=”合并单元格的个数。比如：<code>&lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt;</code>。</li><li>删除多余的单元格，否则会有一部分单元格凸出原来的表格。</li></ol><h3 id="列表标签-lt-ul-gt-lt-ol-gt-lt-dl-gt"><a href="#列表标签-lt-ul-gt-lt-ol-gt-lt-dl-gt" class="headerlink" title="列表标签 &lt;ul&gt;&lt;ol&gt;&lt;dl&gt;"></a>列表标签 <code>&lt;ul&gt;&lt;ol&gt;&lt;dl&gt;</code></h3><p>无序列表（unordered list）<code>&lt;ul&gt;</code>和有序列表（ordered list）<code>&lt;ol&gt;</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>&lt;ul&gt;</code> 标签表示HTML页面中项目的无序列表，默认以小圆点符号呈现列表项，而列表项使用<code>&lt;li&gt;</code>标签定义。<code>&lt;ol&gt;</code> 标签用于定义有序列表，列表排序以数字来显示，也使用 <code>&lt;li&gt;</code> 标签来定义列表项。</p></li><li><p>无序列表的各个列表项之间没有顺序级别之分，是并列的。有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。</p></li><li><p><code>&lt;ul&gt;&lt;/ul&gt;</code>和<code>&lt;ol&gt;&lt;/ol&gt;</code>中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ul&gt;&lt;/ul&gt;</code>和<code>&lt;ol&gt;&lt;/ol&gt;</code>中标签中输入其他标签或者文字的做法都是不被允许的。</p></li><li><p><code>&lt;li&gt;</code> 与 <code>&lt;/li&gt;</code>之间相当于一个容器，可以在其中插入任何其他的标签。</p></li><li><p>无序列表会带有自己的列表样式，但在实际使用无序列表时，往往会使用 CSS 语句 <code>list-style: none;</code>去掉默认的列表样式再添加自定义的样式。</p></li></ul><p>自定义列表（definition list）<code>&lt;dl&gt;</code>：</p><ul><li><p>自定义列表常用于对术语或名词进行解释和描述，自定义列表的列表项前没有任何项目符号。</p></li><li><p><code>&lt;dl&gt;</code> 标签用于定义描述列表（或定义列表），该标签会与 <code>&lt;dt&gt;</code>（definition title，定义项目名词）和 <code>&lt;dd&gt;</code>（definition description，项目描述和解释）两种标签一起使用。</p></li><li><p><code>&lt;dl&gt;&lt;/dl&gt; </code>里面只能包含 <code>&lt;dt&gt;</code> 和 <code>&lt;dd&gt;</code> 这两种标签。</p></li><li><p><code>&lt;dt&gt;&lt;/dt&gt;</code>和<code>&lt;dd&gt;&lt;/dd&gt;</code>个数没有限制，经常是一个<code>&lt;dt&gt;</code>对应多个<code>&lt;dd&gt;</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词项目1<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>项目1解释1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>项目1解释2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>名词项目2<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>项目2解释1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>项目2解释2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>三种列表对比：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157032.png" alt="image-20210406145405695"></p><h3 id="表单标签-lt-form-gt"><a href="#表单标签-lt-form-gt" class="headerlink" title="表单标签 &lt;form&gt;"></a>表单标签 <code>&lt;form&gt;</code></h3><p><code>&lt;form&gt;</code> 标签用于定义表单域，表单域是一个包含表单控件（也称为表单元素）的区域。表单控件是指允许用户在浏览器中输入有关信息的控件（比如：文本域、下拉列表、单选框、复选框等等）。只有在 <code>&lt;form&gt;</code> 标签范围内的表单控件里面的信息才会被提交给服务器。</p><p><code>&lt;form&gt;</code> 标签常用属性：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157033.png" alt="image-20210406150136647"></p><p><code>&lt;input&gt;</code> 标签时是用的最多的表单控件，根据不同的 type 属性值，<code>&lt;input&gt;</code> 表单控件有各种不同的形式，可以是单行文本框、密码框、各种按钮和选框等。</p><p>不同 type 属性值及对应的控件形式：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157034.png" alt="image-20210406150921350"></p><p>除了 type 属性外，<code>&lt;input&gt; </code> 标签还有其他很多属性，其常用属性如下：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157035.png" alt="image-20210406151052539"></p><ul><li>name 属性表示表单控件的名字，要求同一组单选按钮或者复选框要有相同的 name 值，例如<code>&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt;女</code></li><li>value 属性可以给表单控件设置默认值，例如让文本框默认显示一行文字，例如 <code>&lt;input type=&quot;text&quot; value=“请输入用户名”&gt;</code>。</li><li>name 和 value 是每个表单元素都应该有的属性值，后台可以通过这个 name 属性找到这个表单控件，并取得该控件的 value 值进行相关操作。</li><li>checked 属性主要用于单选按钮（radio）和复选框（checkbox），用于默认选中某个表单元素。例如<code>&lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot; /&gt;男</code></li><li>maxlength 可以限制表单控件输入的最大字符，一般较少使用。</li></ul><p><code>&lt;label&gt;</code> 标签可以为 <code>&lt;input&gt;</code> 表单控件定义标注信息，<code>&lt;input&gt;</code> 标签为单标签，和标签前后的文字没有关系，要利用 <code>&lt;label&gt;</code> 标签才能和文本关联。用户只需点击 <code>&lt;lable&gt;</code> 标签中的文本，就会激活绑定的表单控件，自动将焦点转到相关的表单元素上，从而增加了用户体验。把 <code>&lt;label&gt;</code> 标签 for 属性的值设置为相关元素的 id 属性的值，即可把该 <code>&lt;label&gt;</code> 元素绑定到另外一个元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;select&gt;</code> 标签用于定义下拉列表表单控件，<code>&lt;select&gt;  </code>中至少包含一对 <code>&lt;option&gt;</code>，在 <code>&lt;option&gt;</code> 中定义属性 selected=”selected” 时，当前项即为默认选中项。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;下拉列表&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>选项3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span>默认选项<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;textarea&gt;</code> 标签是用于文本域的表单控件。当用户输入内容较多的情况下，就不能使用 <code>&lt;input type=&quot;text&quot;&gt;</code> 文本框表单了，而要使用多行文本输入控件 <code>&lt;textarea&gt;</code>，该控件常见于留言板，评论区。使用 cols 和 rows 两个属性可以修改文本框的每行中的字符数以及显示的行数，但在实际开发中更多使用 CSS 来改变文本域的大小。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span>文本内容<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h2><h3 id="HTML-的局限性"><a href="#HTML-的局限性" class="headerlink" title="HTML 的局限性"></a>HTML 的局限性</h3><p>HTML 只关注内容的语义和结构，显示元素内容。虽然 HTML 可以做简单的样式，但是带来的是无尽的臃肿和繁琐。</p><p>CSS 是层叠样式表（Cascading Style Sheets）的简称，有时我们也会称之为 CSS 样式表或级联样式表。CSS 和 HTML 一样也是一种标记性语言。</p><p>CSS 主要用于设置 HTML 页面中的文本的显示样式（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局。</p><p>简单理解：CSS 可以美化 HTML，让 HTML 更漂亮，让页面布局更简单。:这样就可以由 HTML 专注于内容和结构呈现，样式交给 CSS，即 结构（HTML）与样式（CSS）相分离。</p><h3 id="选择器定义"><a href="#选择器定义" class="headerlink" title="选择器定义"></a>选择器定义</h3><p>CSS 选择器定义由两个主要的部分构成：选择符以及一条或多条属性声明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">selector</span> &#123;<br>    <span class="hljs-attribute">property</span>:value<br>&#125; <br></code></pre></td></tr></table></figure><p>selector：选择符，可以根据不同需求把特定的 HTML 标签选出来，然后将括号中设置的样式的应用到这些标签上。</p><p>property:value：属性声明，属性名和属性值以键值对的形式出现，属性名和属性值之间用英文冒号隔开。属性定义之间用英文分号隔开。</p><p>建议样式选择符，属性名，属性值关键字全部使用小写字母，特殊情况除外。</p><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><p>选择器分为基础选择器和复合选择器两个大类，先了解一下基础选择器。</p><p>基础选择器是由单个选择器组成的，又包括：标签选择器、类选择器、id 选择器和通配符选择器：</p><ul><li>标签选择器（元素选择器）是指用 HTML 标签名称作为选择符，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。标签选择器可以把某一类标签全部选择出来，比如所有的 <code>&lt;div&gt;</code> 标签和所有的 <code>&lt;span&gt;</code> 标签。</li><li>类选择器可以选择 class 属性为特定值的标签，可以单独选一个或者某几个标签。类选择器使用 <code>.</code>（英文点号）加上类名作为选择符。可以给 HTML 标签的 class 属性指定一个或者多个类名来，多个类名中间必须用空格分开。</li><li>id 选择器可以选择特定 id 的 HTML 标签。 id 选择器以 <code>#</code> 加上 id 属性值作为选择符。id 属性值原则上在每个 HTML 文档中只能出现一次，不要使用纯数字 id 或者 数字开头的 id 属性值。</li><li>通配符选择器使用 <code>*</code> 定义，它表示选取页面中所有元素（标签），给所有元素使用括号中所定义的样式。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157036.png" alt="image-20200727231001565"></p><h3 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h3><p>复合选择器就是基础选择器组合而成的，包括组选择器，关系选择器，伪选择器等。</p><ul><li><p>组选择器也叫并集选择器，可以选择多组标签为他们定义相同的样式。用英文 <code>,</code> 隔开多个选择符，任何选择符都可以作为并集选择器的一部分，但是在选择符列表中如果有一个选择符匹配失败，那么整条规则都会失效。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">选择符1,选择符2 &#123;样式声明&#125;<br></code></pre></td></tr></table></figure></li><li><p>关系选择器常用的有后代选择器和子选择器：</p><ul><li>子选择器：当使用 <code>&gt;</code> 符号分隔两个选择符时，第二选择符只会匹配那些由第一个选择符匹配到的元素作为父亲的子元素（直接后代元素）。</li><li>后代选择器：又称为包含选择器，当使用空格连接两个选择符时，使得第二个选择符可以只区匹配那些由第一个选择符匹配到的元素作为祖先元素的子元素（后代元素）， 后代选择器与子选择器很相似, 但是后代选择器不需要有严格的父子关系。</li></ul></li><li><p>伪选择器：</p><ul><li>伪类是添加到选择器的关键字，指定要选择的元素的特殊状态，这样就能够根据元素状态自动改变元素样式。可以在一个选择器中同时一起写多个伪类。使用单冒号（<code>:</code>）连接伪元素关键字。为了确保生效，要按照 link -&gt; visited -&gt; hover -&gt; active 的顺序添加链接伪类。</li><li>伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。一个选择器中只能使用一个伪元素。伪元素必须紧跟在语句中的简单选择器/基础选择器之后。使用双冒号（<code>::</code>）连接伪元素关键字。</li></ul></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157037.png" alt="image-20210406183536567"></p><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><ul><li>优先级就是分配给指定的 CSS 声明的一个权重，它由 匹配的选择器中的 每一种选择器类型的 数值 决定。而当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候，CSS 中最后的那个声明将会被应用到元素上。当同一个元素有多个声明的时候，优先级才会有意义。</li><li>权重排序递增：继承或* -&gt; 元素选择器，伪元素选择器 -&gt; 类选择器，伪类选择器，属性选择器 -&gt; ID选择器 -&gt; 行内样式style=”” -&gt; !important重要的</li></ul><table><thead><tr><th>参数值</th><th>权重</th></tr></thead><tbody><tr><td>继承或*</td><td>0,0,0,0</td></tr><tr><td>元素选择器，伪元素选择器</td><td>0,0,0,1</td></tr><tr><td>类选择器，伪类选择器，属性选择器</td><td>0,0,1,0</td></tr><tr><td>ID选择器</td><td>0,1,0,0</td></tr><tr><td>行内样式style=””</td><td>1,0,0,0</td></tr><tr><td>!important重要的</td><td>无穷大</td></tr></tbody></table><ul><li><p>复合选择器会出现权重叠加的情况，权重不会进位。详见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity">MDN：优先级</a> <a href="https://specificity.keegan.st/">优先级可视化</a></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157038.png" alt="CSS specifishity"></p></li></ul><h2 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h2><p>Emmet插件的前身是Zen coding,它使用缩写,来提高html/css的编写速度, Vscode内部已经集成该插件。它提供了一种非常简练的语法规则，然后立刻生成对应的 HTML 结构或者 CSS 代码，同时还有多种实用的功能帮助进行前端开发。除了{}[]，Emmet语法中中不可存在空格</p><ul><li><p>生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成 <code>&lt;div&gt;&lt;/div&gt;</code></p></li><li><p>如果想要生成多个相同标签 加上 * 就可以了 比如 div*3 就可以快速生成3个div</p></li><li><p>生成有父子（包含）关系的标签，可以用 &gt; ，大于号表示后面要生成的内容是当前标签的后代比如 ul &gt; li：<code>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></p></li><li><p>生成有兄弟（并列）关系的标签，用 + ，加号表示后面的元素和前面的元素是兄弟元素， 比如 div+p：<code>&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;</code></p></li><li><p>生成上级元素的标签,用<code>^</code>表示后面的元素与<code>^前面的元素的父元素是平级。一个^表示提升一个层级，两个提升两级。多和&gt;配合使用。比如div&gt;p+span^table：</code><div><p></p><span></span></div><table></table>`</p></li><li><p>生成带类名或者id的标签 ，Emmet 默认的标签为 div ，如果我们不给出标签名称的话，默认就生成 div 标签。比如p#container：<code>&lt;p id=&quot;container&quot;&gt;&lt;/p&gt;</code>。如果想生成多个类名可连续写.container.wrapper.more：<code>&lt;div class=&quot;container wrapper more&quot;&gt;&lt;/div&gt;</code></p></li><li><p>生成带数字编号的标签，支持class，id，属性，内容，用$就表示一位数字，只出现一个的话，就从1开始。如果出现多个，就从0开始。如果我想生成三位数的序号，那么要写三个$。需要配合<code>*</code>使用，比如li.item$*5</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">li</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item1&quot;</span>&gt;&lt;/<span class="hljs-keyword">li</span>&gt;<br>&lt;<span class="hljs-keyword">li</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item2&quot;</span>&gt;&lt;/<span class="hljs-keyword">li</span>&gt;<br>&lt;<span class="hljs-keyword">li</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item3&quot;</span>&gt;&lt;/<span class="hljs-keyword">li</span>&gt;<br>&lt;<span class="hljs-keyword">li</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item4&quot;</span>&gt;&lt;/<span class="hljs-keyword">li</span>&gt;<br>&lt;<span class="hljs-keyword">li</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item5&quot;</span>&gt;&lt;/<span class="hljs-keyword">li</span>&gt;<br></code></pre></td></tr></table></figure><p> $ 后面增加@N 指定开始的序号，例如ul&gt;li.item$@3*5 </p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">li</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item3&quot;</span>&gt;&lt;/<span class="hljs-keyword">li</span>&gt;<br>&lt;<span class="hljs-keyword">li</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item4&quot;</span>&gt;&lt;/<span class="hljs-keyword">li</span>&gt;<br>&lt;<span class="hljs-keyword">li</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item5&quot;</span>&gt;&lt;/<span class="hljs-keyword">li</span>&gt;<br>&lt;<span class="hljs-keyword">li</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item6&quot;</span>&gt;&lt;/<span class="hljs-keyword">li</span>&gt;<br>&lt;<span class="hljs-keyword">li</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item7&quot;</span>&gt;&lt;/<span class="hljs-keyword">li</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>生成指定属性的标签，[attr]  中括号里面的内容是想添加的属性和值，例如table[align width=10px]：<code>&lt;table align=&quot;&quot; width=&quot;10px&quot;&gt;&lt;/table&gt;</code></p></li><li><p>生成指定内容的标签，{}大括号里面是你想添加的文本内容，例<code>p&gt;&#123;Click &#125;+a&#123;here&#125;+&#123; to continue&#125;</code>：<code>&lt;p&gt;Click &lt;a href=&quot;&quot;&gt;here&lt;/a&gt;to continue&lt;/p&gt;</code></p></li><li><p>长度缩写：默认单位px，p 表示%，e 表示 em，r表示 rem</p><ul><li>w100：width:100px</li><li>w100p  ：width:100%</li><li>lh100e：line-height: 100em;</li><li>h100r  结果：height: 100rem;</li></ul></li><li><p>十六进制表示的颜色缩写：</p><ul><li>c#3： color: #333333;</li></ul></li><li><p>c#e0： color: #e0e0e0;</p><ul><li>c#fc0： color: #ffcc00;</li></ul></li><li><p>常用属性缩写：</p><ul><li>tdn：text-decoration：none</li><li>ti2em：text-indent：2em</li><li>bgc：background-color</li><li>bgi：background-image</li></ul></li><li><ul><li></li></ul></li></ul><h2 id="CSS-引入方式"><a href="#CSS-引入方式" class="headerlink" title="CSS 引入方式"></a>CSS 引入方式</h2><p>可以用下面三种方式将样式表关联到 HTML 文档中。而越接近目标的样式定义优先级越高。高优先级样式将继承的未重叠定义，但覆盖低优先级样式重叠的定义。</p><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><ul><li><p>内部样式表（内嵌样式表）是将所有的 CSS 代码抽取出来，单独放到一个 <code>&lt;style&gt;</code> 标签中，写到 HTML 页面内部。</p></li><li><p><code>&lt;style&gt; </code>标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的 <code>&lt;head&gt; </code>标签中。</p></li><li><p>使用内部样式表设定 CSS，通常也被称为嵌入式引入。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">style</span>&gt;<br>    <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;<br>&lt;/<span class="hljs-selector-tag">style</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h3><ul><li><p>行内样式表（内联样式表）是在元素标签的 style 属性值中设定 CSS 样式。可以直接设置当前标签的样式，适合于修改简单样式，往往优先级很高。</p></li><li><p>使用行内样式表设定 CSS，通常也被称为行内式引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>这一行的字体颜色将显示为红色<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><ul><li><p>把样式单独写到后缀名为 .css 的样式文件，之后把 CSS 文件引入到 HTML 页面中使用。</p></li><li><p>在 HTML 页面中，使用 <code>&lt;link&gt;</code> 标签引入这个文件，<code>&lt;link&gt;</code> 标签的 rel 属性值为 “stylesheet”，href 属性值为样式文件的 URL，可以为相对路径或者绝对路径。</p></li><li><p>使用外部样式表设定 CSS，通常也被称为外链式或链接式引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css文件路径&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>三种引入方式对比：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157039.png" alt="image-20210406181219029"></p><h2 id="CSS-字体属性"><a href="#CSS-字体属性" class="headerlink" title="CSS 字体属性"></a>CSS 字体属性</h2><h3 id="字体系列-font-family"><a href="#字体系列-font-family" class="headerlink" title="字体系列 font-family"></a>字体系列 font-family</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>,tahoma,arial,<span class="hljs-string">&#x27;Hiragino Sans GB&#x27;</span>; &#125;<br></code></pre></td></tr></table></figure><ul><li>各种字体之间必须使用英文逗号隔开。</li><li>如果有空格隔开的多个单词组成的字体，用单引号或者双引号括起来，推荐使用双引号。</li><li>尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示。</li></ul><h3 id="字体大小-font-size"><a href="#字体大小-font-size" class="headerlink" title="字体大小 font-size"></a>字体大小 font-size</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li>谷歌浏览器默认的文字大小为 16px。</li><li>不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。</li><li>在 body 标签选择器中可以一次指定整个页面文字的大小。</li></ul><h3 id="字体粗细-font-weight"><a href="#字体粗细-font-weight" class="headerlink" title="字体粗细 font-weight"></a>字体粗细 font-weight</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li>normal：正常字体，默认值。</li><li>bold：粗体。</li><li>bolder：特粗体，大多数字体表现和 bold 一样。</li><li>lighter：细体。</li><li>number：400 等同于 normal，700 等同于 bold</li></ul><h3 id="文字样式-font-style"><a href="#文字样式-font-style" class="headerlink" title="文字样式 font-style"></a>文字样式 font-style</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">em</span> &#123;<span class="hljs-attribute">font-style</span>: normal;&#125;<br></code></pre></td></tr></table></figure><ul><li>normal：普通样式。</li><li>italic：斜体样式。</li><li>平时我们很少给文字加斜体，反而常常要给斜体标签（em，i）的默认样式改为不倾斜。</li></ul><h3 id="字体复合属性-font"><a href="#字体复合属性-font" class="headerlink" title="字体复合属性 font"></a>字体复合属性 font</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">font</span>: font-style font-weight font-size/line-height font-family;&#125;<br></code></pre></td></tr></table></figure><ul><li><p>使用 font 属性可以一次定义字体系列、大小、粗细、和文字样式。</p></li><li><p>使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开。</p></li><li><p>不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用。</p></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157040.png" alt="image-20200727231909005"></p><h2 id="CSS-文本属性"><a href="#CSS-文本属性" class="headerlink" title="CSS 文本属性"></a>CSS 文本属性</h2><h3 id="文本颜色-color"><a href="#文本颜色-color" class="headerlink" title="文本颜色 color"></a>文本颜色 color</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#cccccc</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>用预定义好的颜色关键字来指定颜色：red、blue、gray 等。</li><li><code>#</code>号加上十六进制数字：<code>#ff0000</code>。</li><li>RGB 写法：rgb(200,0,0) 或 rgb(100%,0%,0%)。</li></ul><h3 id="文本对齐-text-align"><a href="#文本对齐-text-align" class="headerlink" title="文本对齐 text-align"></a>文本对齐 text-align</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">text-align</span>: center;&#125;<br></code></pre></td></tr></table></figure><ul><li>left：左对齐（默认值）。</li><li>right：右对齐。</li><li>center：居中对齐。</li></ul><h3 id="文本装饰-text-decoration"><a href="#文本装饰-text-decoration" class="headerlink" title="文本装饰 text-decoration"></a>文本装饰 text-decoration</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">text-decoration</span>: none;&#125;<br></code></pre></td></tr></table></figure><ul><li>none：没有装饰（默认值）。</li><li>underline：下划线。</li><li>overline：上划线。</li><li>line-through：删除线。</li></ul><h3 id="文本缩进-text-indent"><a href="#文本缩进-text-indent" class="headerlink" title="文本缩进 text-indent"></a>文本缩进 text-indent</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">text-indent</span>: <span class="hljs-number">2em</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li>只指定文本的第一行的缩进，通常是将段落的首行缩进。</li><li>长度单位可以是 px 或者 em，em 是一个相对单位，1 个 em 等于当前元素的字体大小（font-size），如果当前元素没有设置字体大小，则等于父元素的字体大小。</li><li>该长度可以是负值，这样会凸出到边框外。</li></ul><h3 id="行间距-line-height"><a href="#行间距-line-height" class="headerlink" title="行间距 line-height"></a>行间距 line-height</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">line-height</span>: <span class="hljs-number">20px</span>;&#125;<br></code></pre></td></tr></table></figure><ul><li>行间距控制行与行之间的距离，由上间距，文本高度，下间距组成。</li><li>单位可以是 px 或者 em，如果是相对单位，后代元素会继承这个缩放因子，与当前的字体尺寸相乘来设置行间距。</li><li>如果行距小于 font-size 会使相邻两行的文字重叠。</li><li>让文字的行高等于盒子的高度就可以让文字在当前盒子内垂直居中，如果行高小于盒子高度，文字会偏上，如果行高大于盒子高度，则文字偏下。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157041.png" alt="image-20200727233430016"></p><h2 id="CSS-背景"><a href="#CSS-背景" class="headerlink" title="CSS 背景"></a>CSS 背景</h2><h3 id="背景颜色-background-color"><a href="#背景颜色-background-color" class="headerlink" title="背景颜色 background-color"></a>背景颜色 background-color</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">background-color</span>: transparent;&#125;<br></code></pre></td></tr></table></figure><ul><li>transparent：背景色透明（默认值）。</li><li>文本颜色 color 的三种颜色表示法也可以在这使用。</li></ul><h3 id="背景图片-background-image"><a href="#背景图片-background-image" class="headerlink" title="背景图片 background-image"></a>背景图片 background-image</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(./imgs/logo.jpg);&#125;<br></code></pre></td></tr></table></figure><ul><li>常用于 logo 等一些装饰性的小图片或者是超大的背景图片，优点是非常便于控制位置。</li><li>none：无背景图（默认值）。</li><li>url()：使用绝对地址或相对地址指定图片，注意括号里面的路径可以不加引号。</li></ul><h3 id="背景平铺-background-repeat"><a href="#背景平铺-background-repeat" class="headerlink" title="背景平铺 background-repeat"></a>背景平铺 background-repeat</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(./imgs/logo.jpg);<br>    <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>背景图片在背景颜色图层之上，可以使用 opacity 属性调整不透明度。</li><li>repeat：背景图像在横向和纵向平铺（默认值）。</li><li>no-repeat：背景图像不平铺。</li><li>repeat-x：背景图像在横向上平铺。</li><li>repeat-y：背景图像在纵向上平铺。</li></ul><h3 id="背景图片位置-background-position"><a href="#背景图片位置-background-position" class="headerlink" title="背景图片位置 background-position"></a>背景图片位置 background-position</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(./imgs/logo.jpg);<br>    <span class="hljs-attribute">background-position</span>: <span class="hljs-number">50%</span> <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数是方位名词（top、center、bottom、left、right）：两个值前后顺序无关，比如 left top 和 top left 效果一致。如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐（即 center）。</li><li>参数是精确单位：第一个用于横坐标，第二个用于纵坐标。只提供一个数值，该值将用于横坐标，纵坐标将默认为 50%。 </li><li>参数是混合单位：两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标</li></ul><h3 id="背景图像固定-background-attachment"><a href="#背景图像固定-background-attachment" class="headerlink" title="背景图像固定 background-attachment"></a>背景图像固定 background-attachment</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(./imgs/logo.jpg);<br>    <span class="hljs-attribute">background-attachment</span>: fixed;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>设置背景图像是否固定或者随着页面的其余部分滚动。</li><li>scroll：背景图像随着内容滚动（默认值）。</li><li>fixed：背景图像固定，可以用来制作视差滚动。</li></ul><h3 id="背景复合属性-background"><a href="#背景复合属性-background" class="headerlink" title="背景复合属性 background"></a>背景复合属性 background</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">background</span>: transparent <span class="hljs-built_in">url</span>(image.jpg) repeat-y fixed top ;&#125;<br></code></pre></td></tr></table></figure><ul><li><p>可以上面 5 种背景属性合并简写在同一个属性 background 中，顺序没有严格规定，习惯约定的顺序：背景颜色 | 背景图片地址 | 背景平铺 | 背景图片固定 | 背景图片位置 。</p></li><li><p>CSS3 可以通过 background 来为背景颜色设置透明度：<code>background: rgba(0, 0, 0, .3)</code>，最后一个参数是 alpha 透明度，取值范围在 0 ~ 1 之间，可以把 0.3 的 0 省略掉。通过这种方法仅仅是盒子背景半透明，盒子里面的内容不受影响，而 opacity 设置的不透明度会影响盒子里的所有内容（包括背景图片和文字），并且会被继承。</p></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157042.png" alt="image-20200801195304257"></p><h3 id="背景缩放-background-size"><a href="#背景缩放-background-size" class="headerlink" title="背景缩放 background-size"></a>背景缩放 background-size</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(./imgs/logo.jpg);<br>    <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>    <span class="hljs-attribute">background-size</span>: cover;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第一个属性值为背景图片宽度，第二属性值是背景图片高度，可以是具体长度或者百分比。如果省略高度则以根据宽度来等比例缩放。</li><li>cover：等比例缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。</li><li>contain：等比例缩放背景图片以完全装入背景区，可能背景区部分空白。</li></ul><h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><p>把 HTML 页面中的所有元素看作是一个个矩形的盒子，一个 HTML 元素占据空间的大小由盒模型（Box Model）决定。在盒模型中，一个盒子由实际内容（content）、内边距（padding）、边框（border）和外边距（margin）共同构成，盒模型的尺寸即这四部分的尺寸之和。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157043.jpg" alt="盒子模型"></p><h3 id="边框-border"><a href="#边框-border" class="headerlink" title="边框 border"></a>边框 border</h3><ul><li><p>border 属性可以一次设置元素四周的边框。属性值由三部分组成：边框宽度（粗细）、边框样式、边框颜色。三种属性值之间顺序不固定，习惯的顺序为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">border: border-width | border-style | border-color;<br></code></pre></td></tr></table></figure></li><li><p>border-style 可以设置如下值：</p><ul><li> none：没有边框即忽略所有边框的宽度（默认值）。</li><li>solid：边框为单实线（最为常用的）。</li><li>dashed：边框为虚线。</li><li>dotted：边框为点线。</li></ul></li><li><p>border-top，border-bottom，border-left，border-right 分别设定四周边框，后设置的边框如果和之前的重复将会覆盖之前的边框。</p></li><li><p>border-collapse 属性控制相邻单元格的边框重合时是叠加还是合并。</p></li><li><p>标准盒模型下边框会撑开盒子，额外增加盒子的实际大小。</p></li></ul><h3 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距 padding"></a>内边距 padding</h3><ul><li><p>padding 属性可以一次指定四个方向的内边距。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157044.png" alt="image-20210406220323007"></p></li><li><p>padding-top，padding-bottom，padding-left，padding-right 分别设定四周内边距，后设置的内边距如果和之前的重复将会覆盖。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157045.png" alt="image-20210406220232811"></p></li><li><p>标准盒模型下内边距会撑开盒子，额外增加盒子的实际大小。</p></li></ul><h3 id="外边距-magin"><a href="#外边距-magin" class="headerlink" title="外边距 magin"></a>外边距 magin</h3><ul><li><p>margin 外边距复合属性写法和单边写法与内边距 padding 一致。</p></li><li><p>外边距可以让块级盒子水平居中，但是必须满足两个条件：</p><ul><li>当前盒子必须指定了宽度（width）。</li><li>盒子左右的外边距都设置为 auto ，<code>margin: auto;</code> 和 <code>margin: 0 auto;</code> 均可。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">960px</span>;<br>    <span class="hljs-attribute">margin-left</span>: auto; <br>    <span class="hljs-attribute">margin-right</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h3><ul><li>垂直外边距合并：当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。因此尽量只给上下相邻元素中的一个添加 margin 值。</li><li>垂直外边距塌陷：对于两个嵌套关系的块元素 如果父元素没有上内边距（padding-top）或边框（border-top） 则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，这可能会使原来的父元素的上外边距变大，这样整个父元素向下塌陷。可以通过给父元素一个透明上边框（border-top 颜色参数设为 transparent）或者给父元素定义上内边距（padding-top）或者给父元素添加 <code>overflow: hidden</code> 触发 BFC 来避免塌陷。更简单的方法是在子元素中使用 padding-top 代替 margin-top。</li><li>浮动元素、绝对定位、固定定位的元素都不会触发外边距合并的问题。</li></ul><h3 id="圆角边框-border-radius（CSS3）"><a href="#圆角边框-border-radius（CSS3）" class="headerlink" title="圆角边框 border-radius（CSS3）"></a>圆角边框 border-radius（CSS3）</h3><ul><li>border-radius 属性用于设置盒子的外边框圆角。该属性是一个复合属性，和 padding 类似，可以跟不同数量的参数，只有一个参数时四个角都设置相的圆角，跟两个参数时第一个参数是左上和右下的圆角，另一个参数是右上和左下的圆角，四个参数值时，分别代表左上角、右上角、右下角、左下角。</li><li> 要把正方形盒子变为圆形，把数值修改为盒子模型边长的一半即可，或者直接写为 50%。如果盒子是长方形则会变成内切椭圆。</li><li>border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和 border-bottom-left-radius 分别设定四个角的圆角半径。</li></ul><h3 id="盒子阴影-box-shadow（CSS3）"><a href="#盒子阴影-box-shadow（CSS3）" class="headerlink" title="盒子阴影 box-shadow（CSS3）"></a>盒子阴影 box-shadow（CSS3）</h3><ul><li><p>box-shadow 属性为盒子添加阴影。盒子阴影不占用空间，不会影响其他盒子排列。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">box-shadow: h-shadow | v-shadow | blur | spread | color | inset;<br></code></pre></td></tr></table></figure><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157046.png" alt="image-20210407205435147"></p></li><li><p>默认的是外阴影（outset）但是不可以显示指定这个外阴影，否则造成阴影无效，只能将外阴影改成内阴影。</p></li></ul><h3 id="文字阴影-text-shadow（CSS3）"><a href="#文字阴影-text-shadow（CSS3）" class="headerlink" title="文字阴影 text-shadow（CSS3）"></a>文字阴影 text-shadow（CSS3）</h3><ul><li><p>text-shadow 属性将阴影应用于文本。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">text-shadow: h-shadow | v-shadow | blur | color;<br></code></pre></td></tr></table></figure><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157047.png" alt="image-20210407205837953"></p></li></ul><h2 id="HTML-5-和-CSS-3-新特性"><a href="#HTML-5-和-CSS-3-新特性" class="headerlink" title="HTML 5 和 CSS 3 新特性"></a>HTML 5 和 CSS 3 新特性</h2><h3 id="HTML-5-新增的语义化标签"><a href="#HTML-5-新增的语义化标签" class="headerlink" title="HTML 5 新增的语义化标签"></a>HTML 5 新增的语义化标签</h3><p>使用 H5 新增的语义化标签而不是简单的全部使用 <code>&lt;div&gt;</code> 标签更加利于搜索引擎爬取网页内容，这些新标签在页面中可以使用多次。在 IE 9 以上版本的浏览器才支持，IE 9 及以下，需要把这些元素转换为块级元素。</p><ul><li><p><code>&lt;header&gt;</code>：头部标签</p></li><li><p><code>&lt;nav&gt;</code>：导航标签</p></li><li><p><code>&lt;article&gt;</code>：内容标签</p></li><li><p><code>&lt;section&gt;</code>：定义文档某个区域</p></li><li><p><code>&lt;aside&gt;</code>：侧边栏标签</p></li><li><p><code>&lt;footer&gt;</code>：尾部标签</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157048.png" alt="image-20200822210256749"></p></li></ul><h3 id="HTML-5-新增的多媒体标签"><a href="#HTML-5-新增的多媒体标签" class="headerlink" title="HTML 5 新增的多媒体标签"></a>HTML 5 新增的多媒体标签</h3><p>使用 H5 新增的视频和音频标签可以很方便的在页面中嵌入视频和音频，而不再需要使用 flash 或者其他浏览器插件。</p><ul><li><p><code>&lt;video&gt;</code> 标签在不同浏览器的支持情况：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157049.png" alt="image-20200822210914215"></p></li><li><p><code>&lt;video&gt; </code> 元素支持的视频格式有限， 尽量使用 mp4 格式，为了解决浏览器不同版本的视频文件格式兼容问题，常常用 <code>&lt;source&gt;</code> 标签来指定多个格式的视频文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;move.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/ogg&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;move.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span> &gt;</span><br>您的浏览器暂不支持 <span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span> 标签播放视频<br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>视频标签 <code>&lt;video&gt;</code> 常见属性：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157050.png" alt="image-20210409120046918"></p></li><li><p><code>&lt;audio&gt;</code> 标签在不同浏览器的支持情况：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157052.png" alt="image-20200822211514326"></p></li><li><p><code>&lt;audio&gt;</code> 元素支持的音频格式有限， 尽量使用 mp3 格式，为了解决浏览器不同版本的音频文件格式兼容问题，用 <code>&lt;source&gt;</code> 标签来指定多个格式的音频文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;happy.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mpeg&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;happy.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/ogg&quot;</span> &gt;</span><br>    您的浏览器暂不支持 <span class="hljs-tag">&lt;<span class="hljs-name">audio</span>&gt;</span> 标签。<br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>音频标签 <code>&lt;audio&gt;</code>属性：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157053.png" alt="image-20210409121407596"></p></li><li><p>Chrome 浏览器把音频和视频自动播放都禁止了， 要给视频添加静音属性后才能自动播放：<code>&lt;video autoplay=&quot;autoplay&quot; muted=&quot;muted&quot;&gt;</code>。音频可以通过 JavaScript 来自动播放。</p></li></ul><h3 id="HTML-5-增强的表单控件"><a href="#HTML-5-增强的表单控件" class="headerlink" title="HTML 5 增强的表单控件"></a>HTML 5 增强的表单控件</h3><p>H5 给 <code>&lt;input&gt;</code> 标签新增了 type 属性的可选值：使用时会对输入内容做格式检查，如果内容错误，会提示用户<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157054.png" alt="image-20210412130756817"></p><p>H5 新增的表单属性：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157055.png" alt="image-20210412133544555"></p><p>使用 CSS 伪元素选择器更改 placeholder 文字的颜色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">::placeholder</span> &#123;<br>    <span class="hljs-attribute">color</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS-3-选择器"><a href="#CSS-3-选择器" class="headerlink" title="CSS 3 选择器"></a>CSS 3 选择器</h3><p>CSS 3 给我们新增了选择器，可以更加便捷，更加自由的选择目标元素。</p><ul><li><p>属性选择器：属性选择器可以选择有特定属性和属性值的元素。 这样就可以不用借助于类或者 id 选择器。属性选择器和类选择器、伪类选择器一样，权重为 10。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157056.png" alt="image-20210418153308918"></p></li><li><p>结构伪类选择器：结构伪类选择器主要根据文档结构来选择器元素， 常用于选择某个父元素的一个或多个特定的子元素。结构伪类选择器属于伪类选择器，权重为 10。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157057.png" alt="image-20210418153322506"></p><p><code>E:nth-child(n)</code>：先把父元素里面的所有子元素按照位置先后顺序从 1 开始排序，然后选择第 n 个孩子，然后再看是否和 E 标签是否匹配。<br><code>E:nth-of-type(n)</code>：先把父元素里面的所有子元素匹配 E 标签的子元素选择出来，然后从 1 开始排序，选择第 n 个子元素。</p><p>其中的 n 可以是数字，关键字和公式：</p><ul><li>n 可以是数字，选择第 n 个子元素，子元素从 1 开始计数，和数组下标不一样。</li><li>n 可以是关键字：even 选择第偶数个子元素，odd 选择第奇数个子元素。</li><li>n 可以是公式：n 可以取从 0 到正无穷的任何值，但是当公式的值为 0 或者超出了子元素的个数总数没有意义，常见的公式如下：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157058.png" alt="image-20210418154330062"></li></ul></li><li><p>伪元素选择器：可以利用伪元素选择器来创建新的标签元素，而不需要在 HTML 源文档中插入标签，从而简化 HTML 文件结构。伪元素选择器和元素（标签）选择器一样，权重为 1。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157059.png" alt="image-20210418154836709"></p><ul><li>新创建的这个元素在文档树中是找不到的，但是可以在浏览器中显示出来，所以我们称为伪元素。</li><li><code>::before</code> 和 <code>::after</code> 默认创建的是一个行内元素，必须指定 content 属性值，通过 content 属性值决定元素内容。</li><li>使用场景：添加尾部图标，伪元素字体图标，遮罩层效果，添加伪元素清除浮动等。</li></ul></li></ul><h3 id="CSS-3-盒模型-box-sizing"><a href="#CSS-3-盒模型-box-sizing" class="headerlink" title="CSS 3 盒模型 box-sizing"></a>CSS 3 盒模型 box-sizing</h3><p>CSS 3 中可以通过 <code>box-sizing</code> 属性来指定盒模型的计算方式，有 2 个可选值</p><ul><li><code>content-box</code>：标准模式，现代浏览器默认的盒模型，盒子宽度 = content width + padding + border，<code>width</code> 属性实际指定的是 content width。</li><li><code>border-box</code>：怪异模式，IE 6 以前的默认模式，现在多用于移动端页面。盒子宽度即为 <code>width</code> 属性的指定值，即使添加 padding 和 border 也不会撑大盒子了（前提 padding 和 border 之和不会超过width宽度）。</li></ul><h3 id="CSS-3-calc-函数"><a href="#CSS-3-calc-函数" class="headerlink" title="CSS 3 calc() 函数"></a>CSS 3 calc() 函数</h3><ul><li><p><code>calc()</code>： 使用此 CSS 函数可以在声明 CSS 属性值时执行一些计算。括号里面可以使用 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、 来进行值的运算，注意保留单位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">width</span>: <span class="hljs-selector-tag">calc</span>(100% <span class="hljs-selector-tag">-</span> 80<span class="hljs-selector-tag">px</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="CSS-3-滤镜-filter"><a href="#CSS-3-滤镜-filter" class="headerlink" title="CSS 3 滤镜 filter"></a>CSS 3 滤镜 filter</h3><ul><li><p><code>filter</code>：将模糊或颜色偏移等图形效果应用于元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">blur</span>(5<span class="hljs-selector-tag">px</span>);  <span class="hljs-comment">/* blur模糊处理 数值越大越模糊 */</span><br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">grayscale</span>(100%); <span class="hljs-comment">/* 灰色滤镜效果 */</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="CSS-3-过渡-transition"><a href="#CSS-3-过渡-transition" class="headerlink" title="CSS 3 过渡 transition"></a>CSS 3 过渡 transition</h3><ul><li><p>过渡 transition 属性可以为一个元素在不同样式之间切换的时候定义过渡效果。常用来搭配 <code>:hover</code> 伪元素使用给元素添加鼠标悬浮动画。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">transition: property name | duration | timing function | delay <br></code></pre></td></tr></table></figure><ol><li>property name：想要添加过渡变化的 CSS 属性，写 all 指所有的属性都添加过渡，如果要给同时多个属性添加过渡，但是属性值的过渡效果又各不相同可以分组来写，之间用逗号隔开：<code>transition: width .5s ease 1s, height 1.5s ease 1s;</code></li><li>duration：完成过渡需要花费的时间， 单位是秒且不可省略，比如 0.5s。</li><li>timing function：运动曲线：，默认是 ease（可以省略）。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157060.png" alt="image-20200822224841514"></li><li>delay：设置延迟触发时间，默认是 0s （可以省略），单位是秒且不可省略，</li></ol></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">transition</span>: width <span class="hljs-number">0.5s</span> ease <span class="hljs-number">0s</span>;<br>    <span class="hljs-attribute">background-color</span>: green;<br>&#125;<br><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS-3-2D-转换-transform"><a href="#CSS-3-2D-转换-transform" class="headerlink" title="CSS 3 2D 转换 transform"></a>CSS 3 2D 转换 transform</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157061.png" alt="image-20210418161021259"></p><ul><li><p><code>translate(x,y)</code>：让元素在 2 维平面内移动，沿着 X 和 Y 轴移动元素，或者分开写成 <code>translateX(x)</code> 和 <code>translateY(y)</code>。x 和 y 可以是带像素单位的数值或者百分比，移动百分比单位是相对于元素自身，结合绝对定位，可以使子元素在父元素中垂直居中。使用 translate 移动元素的效果类似给元素添加相对定位，对行内元素使用 translate 没有效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">position</span>: absoulte<br>    left: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>rotate(x)</code>：让元素在 2 维平面内顺时针旋转或者逆时针旋转。x 只能是带度数单位（deg）的数值。数值为正时，表示顺时针旋转，数值为负时，逆时针旋转。默认旋转的中心点在元素的正中心，可以通过 <code>transform-origin</code> 顺序性来设置转换中心点 ，详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin">MDN：transform-origin</a>。</p></li><li><p><code>scale(x,y)</code>：缩放，能控制元素的放大和缩小。第一个参数代表宽度缩放倍数，第二参数高度缩放倍数，倍数只有数值不需要单位。如果只写一个参数，第二个参数则和第一个参数一样。和 rotate(x) 一样默认以元素的中心点为转换中心，可以通过 <code>transform-origin</code> 顺序性来设置转换中心点。</p></li><li><p>使用 transform 不会影响到其他元素的位置，也不会挤开其他元素。</p></li><li><p>如果要同时使用多个转换，多个转换之间用空格隔开，推荐的顺序为：<code>transform: translate() rotate() scale();</code> ，转换的先后顺序会影响最终的效果，当同时有移动和其他属性的时候，一般是要将移动放到最前面。因为元素旋转后坐标轴也会跟着旋转。</p></li></ul><h3 id="CSS-3-3D-转换-transform"><a href="#CSS-3-3D-转换-transform" class="headerlink" title="CSS 3 3D 转换 transform"></a>CSS 3 3D 转换 transform</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157062.png" alt="image-20210418181958356"></p><ul><li><p><code>translate3d(x,y,z)</code>：让元素在 3 维平面内移动，其中 x、y、z 分别指要移动的轴的方向的距离，也可以使用 <code>translateZ()</code> 单独指定在 Z 轴方向的移动距离。3D 移动在 2D 移动的基础上多加了一个可以移动的方向，就是 Z 轴方向。Z 轴是垂直屏幕，由里指向外面，往屏幕外面是正值，往里面是负值，如果不给父元素添加透视属性元素在 Z 轴的方向上移动将看不出效果。</p></li><li><p>如果想要元素产生 3D 效果需要给父元素的视距属性 perspective 指定一个值，单位是像素。视距相当于下图中人眼到屏幕的距离 d，此时再指定元素在 Z 轴方向的移动距离 z，元素离眼睛的距离越近在浏览器平面的成像越大，越远成像越小。当 z 大于 d 时相当于元素在眼睛后面，元素将在浏览器中不可见。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157063.png" alt="image-20210419113806666"></p></li><li><p><code>rotate3d(x,y,z,deg)</code>：让元素在三维平面内沿某一个轴进行旋转，x，y，z表示旋转轴的矢量坐标，deg 表示的旋转的角度，需要带单位。或者使用 <code>rotateX()</code>，<code>rotateY()</code>，<code>rotateZ()</code> 属性值单独围绕 X 轴，Y 轴，Z 轴旋转。旋转轴正方向箭头朝向自己，顺时针方向为旋转的正方向或者根据左手准则来判断正方向：左手的大拇指为该轴的正方向，其余手指的完全方向就是该旋转轴的正方向。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157064.png" alt="image-20210422204316032"></p></li><li><p>给父元素添加 <code>transform-style: preserve-3d;</code> ，该属性控制是否给子元素开启三维立体环境，默认值 <code>flat</code>，如果不开启 3D 立体空间，子元素设置的 3D 效果很可能将无效。</p></li></ul><h3 id="CSS-3-动画-animation"><a href="#CSS-3-动画-animation" class="headerlink" title="CSS 3 动画 animation"></a>CSS 3 动画 animation</h3><ul><li><p>动画（animation）通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。相比较过渡（transition），动画可以实现更多变化，更多控制，连续自动播放等效果。</p></li><li><p>制作动画分为两步：</p><ol><li><p>用 @keyframes 定义动画，然后用百分比设置某个时刻的一个状态，规定此时刻的 CSS 样式，一组百分比就是动画序列。0% 代表动画的开始状态，100% 代表动画的完成状态。这样就创建由开始样式逐渐改为完成样式的动画效果。或者用关键词 “from” 和 “to”，等同于 0% 和 100%。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> 动画名称 &#123;<br>    0%&#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br>    &#125;<br>    25%&#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">180px</span>;<br>    &#125;<br>    100%&#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再使用（调用）动画：给元素指定动画的名称和持续时间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-comment">/* 调用动画 */</span><br><span class="hljs-attribute">animation-name</span>: 动画名称;<br><span class="hljs-comment">/* 持续时间 */</span><br><span class="hljs-attribute">animation-duration</span>: 持续时间;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>常用动画属性：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157065.png" alt="image-20210418171503913"></p></li><li><p>动画属性复合写法：<code>animation: name | duration | timing-function | delay | iteration-count | direction | fill-mode | play-state ;</code>，除了动画名称和持续时间外都可以省略不写，使用默认值。</p></li><li><p>动画的速度曲线属性 <code>animation-timing-function</code>的值为 <code>steps()</code> 时可以指定完成两个相邻状态变化用的总步数，从让 CSS 样式一步步离散的变化，而不是线性的变化。</p></li></ul><h2 id="网页布局"><a href="#网页布局" class="headerlink" title="网页布局"></a>网页布局</h2><p>传统网页布局的三种方式</p><ul><li>标准流(普通流/文档流)</li><li>浮动流</li><li>定位流</li></ul><h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><p>标准流是最基本的布局方式，按照默认的元素显示模式进行显示，可以分为块元素和行内元素两种类型。</p><ul><li>块元素：<code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>，其中 <code>&lt;div&gt;</code>是最典型的块元素。<ul><li>高度，宽度、外边距以及内边距都可以控制。</li><li>块级元素即使设置了宽度，仍然独占一行。</li><li>块元素是一个容器及盒子，大多里面可以放行内或者块级元素。但是 <code>&lt;p&gt;</code> 、 <code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code> 文字类块级标签，里面不能放其他块级元素。</li><li>width，height 属性都不会自动继承父元素宽高。</li><li>如果指定了宽度高度，此时再指定内边距和边框会撑大盒子。</li><li>如果没有指定宽度，宽度高度的默认值为 auto，宽度（包括内边距和边框）等于容器的内容宽度（即父元素的 content），高度等于子元素内容的高度加上内边距和边框。</li><li>如果宽度（或高度）设置为 100% 是元素的内容宽度（或高度）等于容器的内容宽度（或高度），如果再设置内边距和边框的话会使溢出父元素的内容区域。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157066.png" alt="image-20210406194712442"></li></ul></li><li>行内元素： <code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;del&gt;</code>、<code>&lt;s&gt;</code>、<code>&lt;ins&gt;</code>、<code>&lt;u&gt;</code>、<code>&lt;span&gt;</code>等，其中 <code>&lt;span&gt;</code> 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。<ul><li>相邻行内元素在一行上，一行可以显示多个。直到一行排不下，才会自动换行。</li><li>高、宽直接设置是无效的。默认的宽度高度就是它本身内容的宽度。可以通过 padding 和 margin 可以改变宽度，通过改变内容的高度（line-height 和 font-size）来间接改变高度。</li><li>行内元素只能容纳文本或其他行内元素。链接 <code>&lt;a&gt;</code> 比较特殊，里面不能再放链接，但是可以放块级元素，当然给 <code>&lt;a&gt;</code> 转换一下块级模式最安全。</li><li>行内元素的 padding-left，padding-right，margin-left，margin-right 属性都能产生水平方向的边距效果，但 padding-top，padding-bottom，margin-top，margin-bottom 却不会产生竖直方向的边距效果。尽管padding-top 和 padding-bottom 会使行内元素的的长宽发生变化，但是并不会影响上下元素的排布，而是和上下元素会重叠在一起。</li></ul></li><li>行内块元素：<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;td&gt;</code>，它们同时具有块元素和行内元素的特点。<ul><li>并不单独占据一整行，一行可以显示多个（行内元素特点）。</li><li>默认宽度就是它本身内容的宽度（行内元素特点）。</li><li>高度、行高、外边距以及内边距都可以控制（块级元素特点）。</li></ul></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157067.png" alt="image-20200801191935055"></p><ul><li>元素显示模式转换：<ul><li>转换为块元素：<code>display: block;</code>。</li><li>转换为行内元素：<code>display: inline;</code>。</li><li>转换为行内块：<code>display: inline-block</code>。</li></ul></li></ul><h3 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动 float"></a>浮动 float</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157068.png" alt="image-20210407210323226"></p><ul><li><p>浮动可以改变元素默认的排列方式。如果多个盒子都设置了浮动，它们会一行内排列显示，并且元素的顶部对齐。如果父元素宽度装不下这些元素，多出的元素会另起一行对齐。</p></li><li><p>浮动元素会具有行内块元素相似的特性。可以直接设置高度和宽度，默认宽度根据内容宽度来确定。</p></li><li><p>float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及父元素块的内容边缘或者另一个浮动框的边缘。</p></li><li><p>浮动元素会脱离标准流的控制，移动到指定位置（俗称脱标），不再保留在在标准流中原先的位置。</p></li><li><p>浮动的盒子只会影响它后面的标准流，不会影响前面的标准流，因此浮动元素有可能叠加到后面标准流盒子图层的上方。但是不会压住后面标准流盒子里面的文字或者图片，文字图片会围绕浮动元素排列。</p></li><li><p>一般情况下，一个元素浮动了，他的兄弟元素也多采用浮动，除非是想造成环绕效果。</p></li><li><p>浮动常常和标准流的父盒子搭配，标准流的父元素来约束上下位置，之后内部子元素采取浮动排列左右位置。</p></li><li><p>并且标准流的父元素常常不指定高度，而是让浮动的子元素去撑开父元素的高度，但是这可能造成高度坍塌。</p></li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ul><li>当浮动的子盒子的数量无法确定时，父盒子无法事先指定一个确定的高度，但又因为子盒子为浮动元素不再占用原文档流的位置，不会撑开父盒子，这样相当于父级盒子里面没有内容。这会导致父元素高度为 0，从而导致父盒子后面的兄弟元素被子盒子所遮挡。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157069.png" alt="image-20200803192620784"></p><ul><li><p>清除浮动（也叫闭合浮动）的本质是清除浮动元素脱离标准流后造成的影响，如果父盒子设置了高度属性，则不需要清除浮动。清除浮动之后，父级元素就能根据子盒子来自动检测高度。父级元素有了高度，就不会影响后面的标准流了。</p></li><li><p>给父元素后面的兄弟元素添加 <code>clear: both</code> 样式来清除浮动的影响，但是这会使该元素的上边距出现失效的可能。</p></li><li><p>额外标签法：给末尾的浮动子元素添加一个空的块元素，然后在样式里写上属性 <code>clear: both</code>，例如在最末尾子元素的后面添加标签 <code> &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code> 。额外标签法也称为隔墙法，是 W3C 所推荐的做法，但是这样在 HTML 中添加了无意义的标签，结构化较差，复用性较差。</p></li><li><p> 给父级添加 overflow 属性，将其属性值设置为 hidden、auto 或 scroll，优点是方便简洁，但是将无法再显示父元素中溢出的部分。</p></li><li><p><code>:after</code> 伪元素法：CSS 中添加如下的样式，然后父元素 <code>class</code> 属性添加上这个 <code>clearfix</code> 值就可以，这是方法的本质也是在父元素最后面插入一个额外的元素，是额外标签法的升级版，这种方法不需要额外手动添加标签，复用性更好，并且兼容低版本 IE 浏览器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br><span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">/* 伪元素内容为空 */</span><br><span class="hljs-attribute">display</span>: block;<span class="hljs-comment">/* 插入的标签 */</span><br><span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<span class="hljs-comment">/* 元素高度为0从而不可见 */</span><br><span class="hljs-attribute">clear</span>: both;<span class="hljs-comment">/* 核心属性清除浮动 */</span><br><span class="hljs-attribute">visibility</span>: hidden;<span class="hljs-comment">/* 该元素不可见 */</span><br>&#125;<br><span class="hljs-selector-class">.clearfix</span> &#123; <span class="hljs-comment">/* IE6、7 专有 */</span><br><span class="hljs-attribute">*zoom</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>双伪元素清除浮动：将前后的浮动都闭合，更加彻底，父元素 <code>class</code> 属性添加上这个 <code>clearfix</code> 值就可以：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:before</span>,<span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br><span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-attribute">display</span>:table;  <span class="hljs-comment">/* 转换为块级元素并且一行显示 */</span><br>&#125;<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br><span class="hljs-attribute">clear</span>:both;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span> &#123;<br><span class="hljs-attribute">*zoom</span>:<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>几点清除浮动方式的对比：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157070.png" alt="image-20200803200001456"></p><h3 id="定位-position"><a href="#定位-position" class="headerlink" title="定位 position"></a>定位 position</h3><ul><li><p>定位可以让元素自由的在某个父盒子内移动位置，或者固定在浏览器中的某个位置，并且可以压住其他盒子。</p></li><li><p>定位 = 定位模式 + 边偏移 。定位模式用于指定一个元素在文档中的定位方式，边偏移则决定该元素移动位置的方向和距离。</p></li><li><p>边偏移决定了盒子移动的最终位置。有 top、bottom、left 和 right 4 个属性。这个距离指的是对应边与对应边的平行距离，而不是某一个定位点的偏移。例如 left 左侧偏移量是该元素左边线相对于父元素左边线的距离，right 右侧偏移量则是该元素该元素右边线相对于父元素右边线的距离。如果一个盒子既有 left 属性又有 right 属性，只有 left 属性会生效；既有 top 属性又有 bottom 属性只有 top 属性会生效，这并不是层叠性的体现，而是解析规定。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157071.png" alt="image-20210408174729510"></p></li><li><p>定位模式决定元素的定位方式 ，它通过 CSS 的 position 属性来设置：</p><ul><li>static：静态定位是元素的默认定位方式，无定位的意思。按照标准流特性摆放位置，它没有边偏移。</li><li>relative：相对定位在移动位置的时候参照元素原来的位置，相对定位并没有脱离标准流，继续占有移动前在标准流中的位置，后面的盒子仍然以标准流的方式对待它。相对定位的元素经常用来作为绝对定位元素的父级。</li><li>absolute：绝对定位在移动位置的时候相以最近一级的有定位的祖先元素为参考元素来移动位置。如果没有祖先元素或者祖先元素都没有定位，则以 HTML 根元素所在的包含块（被称为初始包含块（initial containing block），可以理解为浏览器视口）为参考来定位。绝对定位脱离标准流，不再占有原先的位置。常常给父盒子添加相对定位但不指定边偏移，这样子盒子就可以使用绝对定位，口诀“子绝父相”。</li><li>fixed：固定定位是元素固定于浏览器可视区（viewport，视口）中的某个位置。这样浏览器滚动页面时元素的位置不会改变。固定定位也是脱标的，不在占有原先的位置。固定定位也可以看做以视口为参考对象的绝对定位。</li><li>sticky：粘性定位可以被认为是相对定位和固定定位的混合。粘性定位占有原先的位置，只有当页面滚动到一定位置后才会固定到浏览器窗口某个位置。兼容性较差，IE 不支持。</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157072.png" alt="image-20200806221708539"></p></li><li><p>在使用定位布局时，可能会出现元素重叠的情况，使用 <code>z-index</code> 属性控制元素在 Z 轴方向上的叠放顺序，数值可以是正整数、负整数或 0，数字后面不跟单位， 默认值是 auto，数值越大，盒子越靠上， 如果<code>z-index</code> 属性值相同，则按照书写顺序，后面的元素叠放在上层。非静态定位的盒子 z-index 属性才能生效。</p></li><li><p>绝对定位、固定定位的元素和浮动元素类似，具有行内块元素的特点，可以直接给元素设置高度和宽度，默认宽度根据内容的宽度来确定。</p></li><li><p> 绝对定位、固定定位的元素虽然和浮动元素一样都脱离标准流，但和浮动元素不同的是， 绝对定位和固定定位的盒子会压住下面标准流所有的内容，包括图片和文字，不会像浮动一样产生环绕效果。</p></li></ul><h3 id="元素显示与隐藏"><a href="#元素显示与隐藏" class="headerlink" title="元素显示与隐藏"></a>元素显示与隐藏</h3><p>display，visibility，overflow 这三个属性和元素的显示与隐藏有关。</p><ul><li>display 属性设置一个元素应如何显示。<ul><li>none：隐藏元素，且不再占有原来的位置，相当于从 HTML 文档中暂时删除了这个标签，会影响后面元素的布局。</li><li>block：以块元素来显示。</li></ul></li><li>visibility 属性设置一个元素的可见性。<ul><li>visible：元素可见。visibility 属性的默认值。</li><li>hidden：元素隐藏，仅仅是视觉上不可见，但是继续占有原来的位置，布局不受影响。</li></ul></li><li>overflow 属性指定了当子元素内容超出了当前元素所指定的高度或宽度时，如何处理溢出的内容内容。<ul><li>visible：发生溢出时不剪切内容也不添加滚动条，溢出部分不会影响后面的元素布局。overflow 属性的默认值。</li><li>auto：自动显示溢出发生的一侧的滚动条，如果不溢出则不显示滚动条。</li><li>hidden：溢出的部分隐藏起来不可见，并且溢出部分不会影响其他元素的布局，相当于抹掉了溢出部分。</li><li>scroll：不管内容是否发生溢出都会显示滚动条。</li></ul></li></ul><h3 id="CSS-高级技巧"><a href="#CSS-高级技巧" class="headerlink" title="CSS 高级技巧"></a>CSS 高级技巧</h3><ul><li><p>精灵图 ：也称 CSS Sprites、CSS 雪碧，CSS 精灵技术将网页中的一些小背景图像整合到一张大图中，通过 background-positions 属性更改大图中的坐标来选择小背景图。这样只需要请求一张大图而不必多次请求单个小背景图，可以有效地减少图片请求的次数，提高页面的加载速度。</p></li><li><p>字体图标 iconfont：将矢量图标打包成字体文件，每个图标对应这种字体中的一个文字，一旦字体加载了，对应的图标就会马上渲染出来，减少了服务器请求。字体图标的本质还是一个个文字，可以通过字体相关的属性来改变图标的大小、颜色、阴影等。字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。如果遇到一些结构和样式比较简单的小图标，就用字体图标。如果遇到一些结构和样式复杂一点的小图片，就用精灵图。</p></li><li><p>CSS 三角形：创建一个长宽都为 0 ，边框不为 0 的盒子，通过改变四周的 border 宽度、颜色和透明度来创建不同形状的三角形。指定 4 边宽度且其中 3 边透明就可以创建一个等腰三角形。指定 2 边宽度且其中1边透明可以创建一个直角三角形。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-left-color</span>: pink;<br>&#125;<br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-color</span>: transparent red transparent transparent;<br>    <span class="hljs-attribute">border-style</span>: solid;<br>    <span class="hljs-attribute">border-width</span>: <span class="hljs-number">22px</span> <span class="hljs-number">8px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>cursor 属性更改用户的鼠标经过元素时的样式。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157073.png" alt="image-20210408201120418"></p></li><li><p>outline 属性控制表单控件的轮廓线，给表单控件添加 <code>outline: 0;</code> 或者 <code>outline: none;</code> 样式之后，就可以去掉表单默认的蓝色边框。</p></li><li><p>resize 属性防止拖拽文本域 ：给文本域控件 textarea 添加 <code>resize: none;</code> 样式防止用户在使用的时候改变文本域的大小。</p></li><li><p>vertical-align 属性设置行内块元素与文字的垂直对齐方式。vertical-align 属性的默认值为 baseline，当行内块元素（图片或者表单控件）和文字一行时，行内块元素底部会出现空白缝隙，需要给行内块添加 <code>vertical-align: bottom;</code> 或者把行内块转换为块级元素，如果还没有完全对齐可以利用 padding-top 来微调。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157074.png" alt="image-20210408210953438"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157076.png" alt="image-20200807010404572"></p></li><li><p>单行文本溢出时显示省略号：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">white-space</span>: <span class="hljs-selector-tag">nowrap</span>;  <span class="hljs-comment">/* 默认值 normal 自动换行，nowarp 强制一行内显示文本，*/</span><br><span class="hljs-selector-tag">overflow</span>: <span class="hljs-selector-tag">hidden</span>;<span class="hljs-comment">/* 超出的部分隐藏*/</span><br><span class="hljs-selector-tag">text-overflow</span>: <span class="hljs-selector-tag">ellipsis</span>;<span class="hljs-comment">/* 文字用省略号替代超出的部分*/</span><br></code></pre></td></tr></table></figure></li><li><p>多行文本溢出时显示省略号：有较大兼容性问题， 适合于 WebKit 内核浏览器或者移动端浏览器（移动端大部分是 WebKit 内核）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">overflow</span>: <span class="hljs-selector-tag">hidden</span>;<br><span class="hljs-selector-tag">text-overflow</span>: <span class="hljs-selector-tag">ellipsis</span>;<br><span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">-webkit-box</span>;<span class="hljs-comment">/* 弹性伸缩盒子模型显示 */</span><br><span class="hljs-selector-tag">-webkit-line-clamp</span>: 2;<span class="hljs-comment">/* 限制在一个块元素显示的文本的行数 */</span><br><span class="hljs-selector-tag">-webkit-box-orient</span>: <span class="hljs-selector-tag">vertical</span>;<span class="hljs-comment">/* 设置或检索伸缩盒对象的子元素的排列方式 */</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li><p>建议 CSS 属性的书写顺序：</p><ol><li>布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）</li><li>自身属性：width / height / margin / padding / border / background</li><li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li><li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</li></ol></li><li><p>对浏览器的一些不好的默认样式进行覆盖。推荐初始化样式：<a href="http://necolas.github.io/normalize.css/">normalize.css</a></p></li><li><p>一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。布局流程：</p><ol><li>先确定页面的版心（可视区）。</li><li>分析页面中的行模块，以及每个行模块中的列模块。</li><li>制作 HTML 结构。先有结构，后有样式。</li><li>先设置盒子大小，再设置盒子位置。</li><li>先用标准流的父元素排列上下垂直的盒子位置, </li><li>内部一行显示的子元素采取浮动排列左右位置。</li><li>如果有子元素层叠的情况，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。</li></ol></li><li><p>CSS选择符是从右到左进行匹配的。只要当前的选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和匹配的元素，或者因为不匹配而退出。</p><ol><li>避免使用通配规则，除了传统意义上的通配选择符之外，相邻兄弟选择符、子选择符、后代选择符和属性选择符都可以归纳为“通配规则”。</li><li>推荐仅用ID、类和标签选择符，尽量少的去使用关系选择器，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素</li><li>通常处理后代选择器的开销是最高的，尽可能使用子选择器来代替后代选择器</li><li>通常在页面中一个指定的ID只能对应一个选择符，所以没有必要在给ID选择器添加额外的限定符。</li></ol></li><li><p>边框合并：当两个兄弟元素边框的外间距为 0 时，边框因为合并被加粗，让 <code>margin-left</code> 属性的值为负的边框宽度，这样正好可以压住相邻盒子的边框，这样所有元素的边框都是相同宽度（border-collapse 只能控制表格中单元格的边框合并）。但添加鼠标经过样式时，被压住的一边边框颜色不变化，应该在鼠标经过样式中当前经过的盒子的层级（如果没有有定位，则加相对定位（保留位置），如果有定位，则增加 z-index 属性值）。<br>  <img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157077.png" alt="image-20210408213153450"></p></li><li><p>文字环绕：运用浮动元素不会压住文字的特性，可以直接在浮动元素的父元素中添加段落就可以制造环绕效果。</p></li><li><p>水平分割线的四种方法：</p><ol><li>直接使用字符 “|”。</li><li>给元素添加边框 <code>border：1px solid</code>。</li><li>在 HTML 中插入一个 width 为 1px 的盒子。</li><li>使用 <code>:after</code> 伪元素插入一个 width 为1px的盒子并设置绝对定位。</li></ol></li><li><p>水平居中的方法：</p><ol><li><p>行内元素或者行内块元素直接给其父元素添加 <code>text-align: center</code> 即可，如果是块元素先设置 <code>display:inline-block</code> 转换为行内块元素，然后给父元素添加 <code>text-align: center</code>。</p></li><li><p>已经确定了宽度的默认定位的块元素可以使用 <code>margin: 0 auto</code>直接居中。</p></li><li><p>绝对定位的元素不能通过 <code>margin: 0 auto</code> 水平居中，通过 <code>left: 50%</code> 让元素的左侧移动到父元素的水平中心位置，然后让 <code>margin-left</code> 属性的值为该元素宽度一半，即让元素向左移动自身宽度的一半即可达到水平居中的效果，或者使用 2D 转换向左平移。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br><span class="hljs-attribute">margin-left</span>: -XXXpx;<br>&#125;<br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>水平垂直居中的 2 种方法：</p><ol><li><p>先设置 <code>display:inline-block</code> 转换为行内块元素，然后给父元素添加 <code>text-align: center;</code>， <code>line-height</code> 属性设置为父元素高度。</p></li><li><p>利用绝对定位和 2D 转换。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>两个行内（块）元素一行左右两端排列的 3 种方案：</p><ol><li>给两个元素分别添加左浮动和右浮动。</li><li>将右端元素设置成左端元素的 <code>:after</code>伪元素，常用于右端的元素只有单个样式。</li><li>将右端元素放在左端元素的内部，然后给右端元素添加右浮动。常用于左端元素的文字很少，利用了文字环绕的原理。</li></ol></li><li><p>当使用 CSS3 新的盒子模型时，添加鼠标经过边框样式可能导致内部元素抖动，可以先添加一个透明的边框，然后鼠标经过时改变边框的颜色为非透明。</p></li><li><p>一行中的最后一个元素不需要添加边距时，可以使用 <code>:nth-child</code> 结构伪类选择器将最后的盒子的边距设为 0，或者给父元素额外增加一点宽度避免最后一个盒子来溢出到下一行，然后给父元素添加 <code>overflow：hidden</code> 样式。</p></li><li><p>给图片 <code>&lt;img&gt;</code> 元素一个固定的宽度，这样上传不同尺寸的图片会自动缩放，不会撑开图片盒子导致其他元素的布局发生改变。</p></li><li><p>给元素添加绝对定位，然后令 <code>left: 50%</code> 和设置 <code>margin-left</code> 的值为版心宽度的一半实现元素固定停靠在版心旁。</p></li></ul><h2 id="移动端-Web-开发"><a href="#移动端-Web-开发" class="headerlink" title="移动端 Web 开发"></a>移动端 Web 开发</h2><h3 id="移动端基础"><a href="#移动端基础" class="headerlink" title="移动端基础"></a>移动端基础</h3><p>移动端主流浏览器大多基于 WebKit 内核，不需考虑其他内核浏览器的兼容性，并且可以放心使用 HTML 5 的新标签和 CSS 3 的新样式。</p><p>在 PC 端和早前的手机屏幕，通常 1 个逻辑像素（logical pixel，也称设备独立像素 device independent pixel，dip or dp）对应 1 个物理像素（device pixel）。但是随着各种高像素屏相继出现，智能手机的像素密度逐渐提高，1 个逻辑像素不再对应 1 个物理像素，使用多个物理像素去共同显示一个逻辑像素，一个逻辑像素包含点物理像素点就越多，显示效果就更细腻平滑。一个逻辑像素对应的物理像素个数称为物理像素比（devicePixelRatio，dpr）或屏幕像素比，物理像素比取决于屏幕的特性（是否为高像素密度屏幕）以及该设备所设置的屏幕分辨率。页面缩放比为 1 时，一个 CSS 像素（CSS pixel）就对应一个 dip。</p><p>以 Apple 早期的视网膜屏（Retina）为例，每 4 个像素为一组，渲染出普通屏幕中一个像素显示区域内的图像，从而实现更为精细的显示效果。此时宽度 2 px 的元素跨越了 4 个物理像素的宽度。如果用户进行了放大，那么一个 CSS 像素还将跨越更多的物理像素。Retina 指的是一种视觉效果，指在正常视线距离内，肉眼很难看到像素颗粒的的屏幕。也用 Retina 屏幕泛指高像素密度的屏幕。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157078.png" alt="image-20210425192054954"></p><p>移动端的设备屏幕像素尺寸多种多样，碎片化严重。但是只需关注开发尺寸，即设备逻辑像素，不需要关注设备的物理像素尺寸。如今主流手机显示屏的物理像素比一般为 2 或者 3，高密度桌面显示屏的物理像素比一般为 1，常见的移动设备如下表：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157079.png" alt="image-20210425191144496"></p><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>在 PC 端，视口（viewport）就是浏览器显示页面内容的屏幕区域，其宽度和浏览器窗口的宽度保持一致（包括滚动条，但不包括标签栏，书签栏，地址栏等浏览器的 UI 部分）。在 CSS 标准文档中，视口也被称为初始包含块，它是 CSS 百分比宽度计算的根源。移动端设备通常宽度是 240px ~ 640px，而大多数为 PC 端设计的网站宽度至少为 800px，如果仍以移动设备的浏览器窗口作为视口的话，网站内容在手机上看起来会非常窄。因此，引入了布局视口、视觉视口和理想视口三个概念：</p><ul><li><p>布局视口：一般移动设备的浏览器都默认设置了一个视口元标签，定义一个虚拟的布局视口（layout viewport），用于解决早期的页面在手机上显示的问题。iOS，Android 上的浏览器基本都将这个视口分辨率设置为 980px，所以 PC 上的网页基本能在手机上完整呈现，只不过由于手机屏幕尺寸的原因，元素看上去很小，可以通过手动缩放网页来放大局部的内容。</p></li><li><p>视觉视口：视觉视口（visual viewport）是用户当前在浏览器中所看到的区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口，布局视口仍保持原来的宽度。当用户放大时，视觉视口将会变小，一个 CSS 像素将跨越更多的物理像素，缩写则反之。视觉视口和缩放比例的关系为：<code>当前缩放值 = 理想视口宽度 / 视觉视口宽度</code>。</p></li><li><p>理想视口：布局视口的默认宽度并不是一个理想的宽度，于是移动浏览器厂商引入了理想视口（ideal viewport）的概念，它对当前设备而言是最理想的布局视口尺寸。显示在理想视口中的网站具有最理想的宽度，用户无需进行缩放。理想视口宽度的值其实就等于设备逻辑像素宽度的值。</p></li></ul><p>为了使网站在不同的移动端设备都能有最理想的阅读宽度，在 HTML 文档中显式添加视口元标签（viewport meta 标签）来进行布局视口设置，让布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，布局视口就多宽。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157080.png" alt="image-20210425191519083"></p><p><strong>注意：视口元标签只对移动端浏览器有效，对 PC 端浏览器是无效的，单独设置 <code>initial-scale=1.0</code> 或 <code>width=device-width</code> 在部分设备可能有兼容性问题，所以设置布局视口为理想视口的最佳方法是同时设置这两个属性，此外即使设置了 <code>user-scalable = no</code>，在部分浏览器中也可以强制启用手动缩放。</strong></p><h3 id="多倍图"><a href="#多倍图" class="headerlink" title="多倍图"></a>多倍图</h3><p>由于如今手机显示屏的物理像素比普遍在 2 以上，在这些设备上打开一些图片时，用多个物理像素来描绘 1 个逻辑像素，这相当于拿一个放大镜去看图片，如果图片本身的清晰度不够高，图片的边缘就会变得模糊。</p><p>多倍图原理：使用多倍于 CSS 像素宽度的高分辨率原图，然后通过缩小图片尺寸来保证图片占用的空间大小不变，这样即使图片在高清设备中显示也不会显得模糊。平常使用最多的是二倍图，随着手机分辨率的不断提高，现在三倍图四倍图的应用也逐渐增多。以二倍图为例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-comment">/*原始图片 100*100px*/</span><br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-comment">/*原始图片 100*100px*/</span><br><span class="hljs-attribute">background-size</span>: <span class="hljs-number">50px</span> <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>移动端多倍图和精灵图技术一起使用时注意移动的坐标也要对应缩小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.logo</span> &#123;<br>    <span class="hljs-comment">/* 选取的图片范围大小 */</span><br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">18px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-comment">/* 移动坐标为原图坐标的一半 */</span><br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(../images/sprites.png) no-repeat -<span class="hljs-number">80px</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 原始精灵图片 400*400px*/</span><br>    <span class="hljs-attribute">background-size</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移动端主流方案"><a href="#移动端主流方案" class="headerlink" title="移动端主流方案"></a>移动端主流方案</h3><p>移动端 Web 页面开发有两种常见方案：</p><ol><li>单独制作移动端访问的页面，用户访问页面时判断用户设备是否是移动设备，如果是则跳转到特定的移动端页面。单独的移动端页面多混合使用流式布局，Flex 弹性布局，以及媒体查询、Less、rem 等技术。 </li><li>制作响应式页面兼容移动端，移动端和 PC 端访问的是同一个页面，通过判断用户设备屏幕宽度（媒体查询）自动改变样式，以适应不同终端，制作相对麻烦， 需要花很大精力去调兼容性问题，媒体查询<br>和 bootstarp。</li></ol><p>移动端页面常用的 CSS 初始化样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 移动端可以放心使用 CSS3 的怪异盒模型*/</span><br><span class="hljs-selector-tag">box-sizing</span>: <span class="hljs-selector-tag">border-box</span>;<br><span class="hljs-selector-tag">-webkit-box-sizing</span>: <span class="hljs-selector-tag">border-box</span>;<br><br><span class="hljs-comment">/*点击高亮我们需要清除清除 设置为transparent 完成透明*/</span><br><span class="hljs-selector-tag">-webkit-tap-highlight-color</span>: <span class="hljs-selector-tag">transparent</span>;<br><br><span class="hljs-comment">/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/</span><br><span class="hljs-selector-tag">-webkit-appearance</span>: <span class="hljs-selector-tag">none</span>;<br><br><span class="hljs-comment">/*禁用长按页面时的弹出菜单*/</span><br><span class="hljs-selector-tag">img</span>,<span class="hljs-selector-tag">a</span> &#123; <br>    <span class="hljs-attribute">-webkit-touch-callout</span>: none; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><p>流式布局，也称作百分比布局、非固定像素布局。</p><p>不给盒子 <code>width</code> 属性设置具体的像素值，而是设置一个百分比，这样盒子会根据浏览器视口的宽度自动进行伸缩填充。</p><p>常配合 <code>max-width</code> 和 <code>min-width</code> 这两个属性指定可伸缩的最大宽度和最小宽度。</p><h3 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h3><p>Flex 是 Flexible Box 的缩写，Flex 布局也称作弹性布局、伸缩布局，flex 布局极为简单，操作方便，移动端应用很广泛，但在 PC 端浏览器支持情况较差，IE 11 以下的版本，不支持或仅部分支持。</p><p>移动端或者不考虑兼容性问题的PC端页面布局，推荐使用 Flex 弹性布局。</p><p>任何一个元素都可以指定为 Flex 布局，给元素添加 <code>display: flex;</code> 样式即为该元素指定 Flex 布局。元素设为 Flex 布局以后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</p><p>常常将父元素指定 Flex 布局，然后来控制子元素的位置和排列方式。</p><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157081.png" alt="image-20210427175026669"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），交叉轴也叫侧轴。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157082.png" alt="img"></p><p>对容器（父元素）进行设置的 6 个属性：</p><ul><li><p><code>flex-direction</code>：设置主轴的方向，即项目的排列方向，有 4 个可能值。</p><ul><li><code>row</code>：默认值，主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></li><li><p><code>flex-wrap</code>：设置子元素在一条轴线排不下时是否换行，有 3 个可能值。</p><ul><li><code>nowrap</code>：默认值，不换行，如果所有项目在容器的一行放不下，则对压缩所有项目的宽度直至一行能恰好放下。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157083.png" alt="img"></li><li><code>wrap</code>：容器一行放不下时自动换行，第一行在上方。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157084.jpg" alt="img"></li><li><code>wrap-reverse</code>：容器一行放不下时自动换行，并且交叉轴反向，即第一行在下方。交叉轴默认都是自左向右或自上向下。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157085.jpg" alt="img"></li></ul></li><li><p><code>flex-flow</code>：<code>flex-direction</code> 和 <code>flex-wrap</code> 的复合属性，可以同时设置主轴方向和换行：<code>flex-flow: flex-direction flex-wrap;</code> ，默认值为 <code>row nowrap</code>。</p></li><li><p><code>justify-content</code>：设置项目在主轴上的对齐方式，有 5 个可能值。</p><ul><li>flex-start：默认值，项目从主轴头部开始排列。</li><li>flex-end：项目从主轴尾部开始排列。</li><li>center：项目在主轴居中对齐，如果主轴是水平方向，则水平居中；主轴垂直方向，则垂直居中。</li><li>space-between：第一个项目和最后一项目分别主轴头部和尾部，其余项目之间的间隔相等，相当于其余项目平分剩余空间，类似圣杯布局。</li><li>space-around：项目和项目之间的间隔相等，项目之间的间隔比项目与边框的间隔大一倍，相当于所有项目平分剩余空间。</li></ul><p>当 <code>flex-direction: row</code>，5 种对齐方式如下图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157086.png" alt="img"></p></li><li><p><code>align-items</code>：设置每一根主轴上的项目在交叉轴（侧轴）上的对齐方式。有 5 个可能值：</p><ul><li><code>flex-start</code>：项目与交叉轴的起点对齐。</li><li><code>flex-end</code>：项目与交叉轴的终点对齐。</li><li><code>center</code>：项目与交叉轴的中点对齐。</li><li><code>baseline</code>: 所有项目中第一行文字的基线对齐。</li><li><code>stretch</code>：默认值，如果项目未设置在交叉轴方向的长度或设为 <code>auto</code>，将拉伸占满整个容器。</li></ul><p><strong>注意：<code>flex-wrap</code> 属性可以更改交叉轴的方向，即使项目发生了换行该属性也有意义。</strong></p><p>当 <code>flex-direction: row;flex-wrap: wrap;</code> 或者 <code>flex-direction: row;flex-wrap: no-wrap;</code>，5 种对齐方式如下图</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157087.png" alt="img"></p></li><li><p><code>align-content</code>：设置多根主轴在交叉轴（侧轴）上的对齐方式，当项目发生换行时才有多根主轴该属性才有意义，如果项目只有一根轴线，该属性不起作用。有 6 个可能值：</p><ul><li><code>flex-start</code>：每根主轴与交叉轴的起点对齐。</li><li><code>flex-end</code>：每根主轴与交叉轴的终点对齐。</li><li><code>center</code>：所有主轴整体上与交叉轴的中点对齐。</li><li><code>space-between</code>：第一根主轴和最后一根主轴分别于交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：轴线和轴线之间的间隔都相等，轴线之间的间隔比轴线与边框的间隔大一倍，相当于所有轴线平分剩余空间。</li><li><code>stretch</code>：默认值，轴线占满整个交叉轴。</li></ul><p>当 <code>flex-direction: row;flex-wrap: wrap;</code> ，5 种对齐方式如下图</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157088.png" alt="img"></p></li></ul><p>对项目（子元素）设置的 6 个属性：</p><ul><li><code>order</code>：定义项目的排列顺序。数值越小，排列越靠前，默认值为 0，将该属性设置为负值可以使后面的项目插队到前面。</li><li><code>flex-grow</code>：定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。<br>例如所有项目的<code>flex-grow</code>属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157089.png" alt="img"></li><li><code>flex-shrink</code>：定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小。<br>例如一个项目的 <code>flex-shrink</code> 属性为 0，其他项目都为 1，则空间不足时，该项目不缩小。负值对该属性无效。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157090.jpg" alt="img"></li><li><code>flex-basis</code>：定义了在分配多余空间之前，项目占据的主轴空间（main size）的基础长度，会使项目本来的 <code>width</code> 属性失效（当主轴是 row 时）。它的默认值为 <code>auto</code>，即项目的本来大小。浏览器根据这个属性值，计算主轴是否有多余空间。</li><li><code>flex</code>：该属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。属性值可以是一个无单位数，它会被当作<code>flex:&lt;number&gt; 1 0</code>，相当于只指定 <code>flex-grow</code> 属性<code>&lt;flex-shrink&gt;</code>的值被假定为 1，然后<code>&lt;flex-basis&gt;</code> 的值被假定为 0。</li><li><code>align-self</code>：定义单个项目在侧轴方向上的对齐方式，可覆盖 Flex 容器所设置的 <code>align-items</code> 属性，让当前项目与容器中的其他项目有不一样的对齐方式。默认值为 <code>auto</code>，表示继承容器（父元素）的 <code>align-items</code> 属性。其他可能取值与 <code>align-items</code> 属性完全一致。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157091.png" alt="img"></li></ul><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询（Media Query）是 CSS 3 的新语法，可以根据设备的大致类型（如打印设备与带屏幕的设备）或者特定的特征和设备参数（例如屏幕分辨率和浏览器宽度）不同的样式。最常见的就是给根据不同设备的浏览器器视口尺寸，设置不同的样式，在调整浏览器窗口大小的过程中，也会根据浏览器视口的宽度和高度变化来重新渲染页面。</p><p>媒体查询语法：使用 <code>@media</code> 指定一条媒体查询语句和一个 CSS 块，当且仅当该媒体查询与正在使用其内容的设备匹配时，该CSS块才能应用于该文档。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> mediatype <span class="hljs-keyword">and</span>|<span class="hljs-keyword">not</span>|<span class="hljs-keyword">only</span> (media feature) &#123;<br><span class="hljs-selector-tag">CSS-Code</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>媒体类型（mediatype）将不同的终端设备划分成不同的类型：</p><ul><li><code>all</code> 用于所有设备</li><li><code>print</code> 用于打印机和打印预览</li><li><code>screen</code> 用于电脑屏幕，平板电脑，智能手机等</li></ul><p>逻辑操作符（logical operators） <code>not</code>, <code>and</code>, 和 <code>only</code> 可用于联合构造复杂的媒体查询，将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。</p><p>媒体特性（media feature）描述了浏览环境的具体特征。每条媒体特性表达式都必须用括号括起来。最常用的就是浏览器视口宽度特性。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192157092.png" alt="image-20210503163140241"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">30em</span>) &#123; <br><span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>; &#125;<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">400px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">700px</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>宽度最大值 <code>max-width</code> 和最小值 <code>min-width</code> 都是包含临界值的，媒体查询 4 级规范可以使用如下更加简洁的语法，但是只有少部分浏览器支持，存在较大兼容性问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (width &lt;= <span class="hljs-number">30em</span>) &#123;<br><span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>; &#125;<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-number">400px</span> &lt;= width &lt;= <span class="hljs-number">700px</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当有多条根据视口宽度的媒体查询语句应遵循从小到大或者从大到小的顺序来写，结合 CSS 的层叠性就可以只指定最大或者最小值，这样代码更加简洁。以从小到大为例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">500px</span>) &#123;<br>    <span class="hljs-selector-tag">div</span> &#123;<br>        <span class="hljs-attribute">background-color</span>: red;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">700px</span>) &#123;<br>    <span class="hljs-selector-tag">div</span> &#123;<br>        <span class="hljs-attribute">background-color</span>: green;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">1000px</span>) &#123;<br>    <span class="hljs-selector-tag">div</span> &#123;<br>        <span class="hljs-attribute">background-color</span>: yellow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用 <code>media</code> 属性直接在 <code>&lt;link&gt;</code> 标签中判断设备浏览器视口的尺寸，然后使用不同的 CSS 文件。<strong>注意：即使媒体查询没有匹配成功，<code>href</code> 属性所引用的 CSS 文件仍然会被下载，但是其中的样式将不会生效。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styleA.css&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen and (min-width: 320px)&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styleB.css&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen and (min-width: 640px)&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><p>Less （Leaner Style Sheets）是一门 CSS 扩展语言，也称为 CSS 预处理语言。做为 CSS 的一种形式的扩展，它并没有减少 CSS 的功能，而是在现有的 CSS 语法基础之上，引入了变量，混合，嵌套、运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本。除了 Less 外，Sass、Stylus 也是常见的 CSS 预处理语言。</p><p>Less 包含一套自定义的语法及一个解析器，用户根据这些语法定义样式规则，这些规则最终会通过编译器，编译生成对应的 CSS 文件。新建一个后缀名为 less 的文件， 即可在里面书写 less 语句，然后利用编译器把 Less 文件翻译成为 CSS 文件，然后 HTML 页面引用生成的 CSS 文件。</p><p>下面仅对 Less 的变量、签到、元素三个功能做了解，其余 Less 功能见  <a href="https://less.bootcss.com/">Less 中文文档</a>。</p><ul><li><p>Less 变量声明：<code>@变量名:值;</code>。变量命名规范：</p><ul><li>必须有@为前缀</li><li>不能包含特殊字符</li><li>不能以数字开头</li><li>大小写敏感</li></ul><p>变量的使用：</p>  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@color:</span> red;<br><span class="hljs-variable">@size:</span> <span class="hljs-number">20px</span><br>body&#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-variable">@color</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">@size</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Less 嵌套：CSS 中的后代选择器在 Less 中可以直接嵌套写在父选择器里面。<br>CSS 写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#header</span> <span class="hljs-selector-class">.logo</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Less 嵌套写法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-id">#header</span> &#123;<br><span class="hljs-selector-class">.logo</span> &#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果遇见（交集|伪类|伪元素选择器），需要在选择器前面添加 <code>&amp;</code> 符号，否则被解析为后代选择器。</p><p>CSS 写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>Less 嵌套写法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Less 运算：Less提供了加（+）、减（-）、乘（*）、除（/）算术运算，任意两个数字、颜色或者变量都可以参与运算。如果参与运算的两个值之间只有一个值有单位，则运算结果就取该单位，对于两个值都带有单位且单位不相同，运算结果的值取第一个值的单位。<strong>注意：最新的 Less 语法中除法运算必须要用小括号括起来。</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@width:</span> <span class="hljs-number">100px</span> + <span class="hljs-number">50</span>;<br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: (<span class="hljs-number">#999</span> - <span class="hljs-number">#222</span>);<br>  <span class="hljs-attribute">border</span>: (<span class="hljs-variable">@width</span> / <span class="hljs-number">2</span>)  solid red;<br>  <span class="hljs-attribute">width</span>: (<span class="hljs-variable">@width</span> - <span class="hljs-number">50</span>) * <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-variable">@width</span> - <span class="hljs-number">10%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面 Less 编译所生成的 CSS 代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#777777</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">75px</span> solid red;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">140px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="rem-单位"><a href="#rem-单位" class="headerlink" title="rem 单位"></a>rem 单位</h3><p>rem（root em）是 CSS 3 新增的一个相对单位，类似于 em。1em 等于该元素所设置字体大小，而 rem 是相对于 HTML 根元素字体的大小。例如当 HTML 根元素设置 <code>font-size: 12px;</code>，那么 1rem 就代表 24px。</p><p>em 单位所参考元素的字体大小很可能不一致， 但是整个页面只有一个 HTML 根元素，只修改根元素的字体大小就可以成比例地调整页面中所有使用 rem 作单位的元素大小 。</p><p>rem 适配方案</p><p>使用媒体查询根据不同设备的视口宽度等比例地设置 HTML 根元素的字体大小属性，页面元素使用 rem 作为尺寸单位，当 HTML 根元素字体大小变化，元素的尺寸也会发生变化，从而达到等比缩放的适配，从而实现在不同设备上元素大小动态变化。</p><p>通常把整个设计稿的宽度划为 n 等份，这里的 n 一般为 10，15，20 等。每一份的宽度就代表 1rem，也就是 HTML 根元素 <code>font-size</code> 属性要设置值。那么页面元素的 rem 值 = 设计稿上的页面元素值（px） / HTML 根元素  <code>font-size</code> 属性值。可以使用 Less 的元素功能或者编辑器的相关插件将原来的 px 单位值自动改为对应的 rem 单位值。</p><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>响应式需要一个父级做为布局容器，通过媒体查询改变在各种屏幕尺寸下的父级容器的大小以及子元素的大小和排列方式，依据屏幕尺寸的不同呈现特定的布局样式，从而达到适配不同设备的目的。</p><p>响应式布局中通常将屏幕尺寸划分 4 个档次：</p><ul><li>超小屏幕（手机）： 屏幕宽度小于 768px，通常父级容器宽度设置为 100%。</li><li>小屏设备（平板） ：大于等于 768px，小于 992px，通常父级容器宽度设置为 750px，在页面两侧留少量空白。</li><li>中等屏幕（桌面显示器）：大于等于 992px，小于 1200px，通常父级容器宽度设置为 970px。</li><li>宽屏设备（大桌面显示器）：大于等于 1200px，通常父级容器宽度设置为 1170px。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.bilibili.com/video/av80149248">B 站视频：黑马程序员pink老师前端入门视频教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/46038860">知乎：浅谈移动端中的视口（viewport）</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰：Flex 布局教程：语法篇</a></li><li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">https://css-tricks.com/snippets/css/a-guide-to-flexbox/</a></li><li><a href="http://www.itcast.cn/news/20201016/16152387135.shtml">传智播客：BFC是什么?10 分钟讲透BFC 原理</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 设计模式学习笔记</title>
    <link href="/2020/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这学期上了设计模式的专业课，感觉是迄今在校上过的对自己代码能力提升最有帮助的专业课了。感谢开设这门课的王老师——在大学生涯中碰到的为数不多对教学充满热情、认真对待的老师之一，让我领略到设计模式的魅力。</p><p>笔记的目录结构参考了 B 站上李建忠老师的 <a href="https://www.bilibili.com/video/BV1kW411P7KS">C++ 设计模式</a>视频中所讲授的顺序。除了第一二三章外，绝大部分文字和图片摘录于本学期老师指定的设计模式教材 <a href="https://blog.csdn.net/LoveLion/article/details/79602149">《Java 设计模式》</a>以及配套的 PPT 教学课件。</p><p>个人不建议没接触过设计模式的直接从李建忠老师的视频入门，李老师的课程更适合之前学过设计模式的人用来复习。前两节课入门听一听还是可以的，到后面举例和代码越来越少，没有实际的应用场景很难真正理解模式的真正意义。可以先看看其他书籍或视频，多写一些代码，再来看这个就别有一番滋味了。书籍推荐上面提到的王伟的《Java 设计模式》，书中有很好的设计模式应用场景举例，配合给的 Java 代码实现，理解起来轻松多了。网上有免费的电子版，感兴趣的可以去搜搜看。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>设计模式：前人总结的可以解决特定问题的一套模式也就是模版。</p><blockquote><p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。——Christopher Alexander</p></blockquote><p>历史性著作《设计模式：可复用面向对象软件的基础》一书中描述了23种经典面向对象设计模式，创立了模式在软件设计中的地位。</p><p>由于《设计模式》一书确定了设计模式的地位，通常所说的设计模式隐含地表示“面向对象设计模式”。但这并不意味“设计模式”就等于“面向对象设计模式”。</p><p>编程的两种思维模式：</p><ul><li>底层思维：向下，如何把握机器底层从微观理解对象构造，关注于语言构造、编译转换、内存模型、运行时机制</li><li>抽象思维：向上，如何将我们的周围世界抽象为程序代码，面向对象、组件封装、设计模式、架构模式。</li></ul><p>软件设计复杂的根本原因是要面对各种各样的变化：客户需求的变化、技术平台的变化、开发团队的变化、市场环境的变化。</p><blockquote><p>建筑商从来不会去想给一栋已建好的 100 层高的楼房底下再新修一个小地下室——这样做花费极大而且注定要失败。然而令人惊奇的是，软件系统的用户在要求作出类似改变时却不会仔细考虑，而且他们认为这只是需要简单编程的事。——《Object-Oriented Analysis and Design with Applications》</p></blockquote><p>解决复杂性通常有两种思路：</p><ul><li>分解：人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。例如常见的结构化设计语言：C 语言。分而治之不容易复用，但出现新的变化时针往往要修改已有的代码来应对变化。</li><li>抽象：更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。即忽略具体实现，归纳总结提取一类事物的共性。</li></ul><p>使用了面向对象的机制并不代表就是一个好的面向对象设计，好的软件设计的标准是复用，复用性越高，说明越是一个好的软件设计。所谓“好的面向对象设计”指是那些可以满足 “应对变化，提高复用”的设计 。</p><h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><h3 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h3><p>对象是什么？</p><ul><li>从语言实现层面来看，对象封装了代码和数据。</li><li>从规格层面讲，对象是一系列可被使用的公共接口。</li><li>从概念层面讲，对象是某种拥有责任的抽象。</li></ul><p>面向对象三大机制：</p><ul><li>封装（Encapsulation）：隐藏内部实现，将对象的状态和行为捆绑到一个单一逻辑单元机制。封装并不是面向对象语言（OOPL）独有, 但面向对象的封装更加完美。封装代码和数据的本质是封装变化点，使得一侧变化一侧稳定。使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li><li>继承（Inheritance）：复用现有代码，子类自动共享父类数据结构和方法，通过继承可以不加修改地重用和扩展已经测试的代码。即使没有已有类的源代码，仍然可以从已有的类中派生出新类。编译单位级别的复用而不是源代码片段级的复用可以显著地减少代码冗余，提高代码质量，减轻维护代码的负担。</li><li>多态（Polymorphism）：改写对象行为，允许不同类的对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。</li></ul><h3 id="类重用的方式"><a href="#类重用的方式" class="headerlink" title="类重用的方式"></a>类重用的方式</h3><p>类间的六种重用方法的耦合性由弱到强分别是：依赖 &lt; （普通）关联 &lt; 聚合 &lt; 组合 &lt; 实现 = 泛化。优先使用耦合度较低的依赖和关联，少用继承。在 UML 类图中的六种关系的表示如下：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236068.png" alt="img"></p><p>下图对其中的五种类关系进行了举例，更详细的说明可以移步我的另一篇博客：<a href="https://kiku.vip/2020/12/19/UMLClassDiagram/">UML 中的类图</a>。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236069.png" alt="image-20201213084132558"></p><h3 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h3><p>单一职责原则（Single Responsibility Principle，SRP）</p><ul><li>一个类应该仅有一个引起它变化的原因，变化的方向隐含着类的责任。</li><li>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</li></ul><p>开放封闭原则（Open-Closed Principle，OCP）</p><ul><li> 对扩展开放，对更改封闭。</li><li> 类模块应该是可扩展的，但是不可修改。</li><li> 需求变更时，不应该尝试去更改已有的模块，而是去增加一些模块来应对变化。</li></ul><p>里氏替换原则（Liskov Substitution Principle，LSP）</p><ul><li> 所有引用基类的地方必须能透明地使用其子类的对象。</li><li> 子类必须能够替换它们的基类（is-a）。</li><li> 继承表达类型抽象。</li><li> 如果继承是为扩展，子类只能通过新添加方法来扩展功能，而不是覆写父类中的具体方法，否则当子类对象将父类对象替换掉时，程序逻辑可能发生改变。</li><li> 如果继承是为了多态，不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承，这样父类是不可实例化的，也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。</li></ul><p>依赖倒置原则（Dependence Inversion Principle，DIP）</p><ul><li><p>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。高层模块应该是稳定的，底层模块是容易根据需求功能发生变化的，高层模块如果依赖于变化的底层模块，则高层模块也变得不稳定，要经常去修改。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236070.png" alt="image-20200918222855319"></p></li><li><p>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。即在抽象类中不应该使用和子类细节相关的属性和方法。</p></li><li><p>针对抽象层（接口或抽象类）编程，而不是针对实现编程。在函数的形参列表中或者关联关系中尽量引用抽象类。即不将变量类型声明为某个特定的具体类，而是声明为某个接口或者抽象类。客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。具体类的对象实例通过依赖注入（Dependence Injection）的方式注入到其他对象的函数中，具体可以分为构造注入、设值注入、接口注入。</p></li><li><p>开闭原则是目标，里氏替换原则是基础，依赖倒转原则是手段。</p></li></ul><p>接口隔离原则（Interface Segregation Principle，ISP）</p><ul><li>不应该强迫客户程序依赖它们不用的方法。应该使用适当的修饰符控制接口中方法和变量的可见性，使用该接口的客户端仅需知道与之相关的方法和变量即可。</li><li>接口应该小而完备。当一个接口太大时，需要将它分割成一些更细小的接口；每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</li><li>接口标准化是软件从其他行业，例如制造业，建筑业借鉴过来的经验，接口的标准化，也是一个行业成熟强盛的标志。</li></ul><p>合成复用原则（Composite Reuse Principle，CRP）</p><ul><li>优先使用对象组合达到复用的目的，而不是类继承。</li><li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高。而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li><li>继承是类属关系，组合是对象关系，只有在两个类直接具有明确的类属关系的时候才能用继承。</li></ul><p>迪米特法则（Law of Demeter，LoD）</p><ul><li>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。又称为最少知识原则(Least Knowledge Principle, LKP)</li><li>不要和陌生人说话，只与朋友（密切相关的对象）通信，</li><li>应当尽可能少地与其他实体发生相互作用，减少对象之间的交互，不必通信则不应该通信，如果必须通信，可以通过第三方转发通信，降低耦合。</li><li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案，耦合度越低，越利于复用。</li></ul><h3 id="三种粒度的软件设计经验"><a href="#三种粒度的软件设计经验" class="headerlink" title="三种粒度的软件设计经验"></a>三种粒度的软件设计经验</h3><ul><li>设计习语（Design Idioms）：描述与特定编程语言相关的低层模式，技巧，惯用法。</li><li>设计模式（Design Patterns）：主要描述的是“类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式等方面。</li><li>架构模式（Architectural Patterns）：描述系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。</li></ul><p>设计模式解决的是设计思想的复用性，并不针对具体的编程语言。软件体系结构则是构件层面的复用，粒度更大。</p><h2 id="设计模式的定义与分类"><a href="#设计模式的定义与分类" class="headerlink" title="设计模式的定义与分类"></a>设计模式的定义与分类</h2><h3 id="设计模式定义"><a href="#设计模式定义" class="headerlink" title="设计模式定义"></a>设计模式定义</h3><p>GoF（Gang of Four，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides，四位作者的被合称为”四人组“）1995 年在他们的著作《设计模式：可复用面向对象软件的基础》中对设计模式是这样定义的：设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。</p><blockquote><p>Design patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>设计模式也可以理解为设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。简单说就是前人总结的可以解决特定问题的一套模式也就是模版。</p><p>设计模式的基本要素：</p><ul><li>模式名称 (Pattern Name) </li><li>问题 (Problem) </li><li>解决方案 (Solution) </li><li>效果 (Consequences) </li></ul><h3 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h3><p>设计模式传统按照目的和范围分类。</p><p>根据目的划分：</p><ul><li>创建型（Creational）模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。</li><li>结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。</li><li>行为型（Behavioral）模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。</li></ul><p>根据范围划分：</p><ul><li>类模式：处理类和子类之间的静态关系，这些关系通过继承建立，在编译时刻就被确定下来，是一种静态关系</li><li>对象模式：处理对象间的动态关系，这些关系在运行时变化，更具动态性</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236071.png" alt="image-20201213090054431"></p><p>李建忠老师提出一种从封装变化角度对模式分类的方法：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236072.png" alt="image-20201213090302933"></p><h3 id="模式的使用"><a href="#模式的使用" class="headerlink" title="模式的使用"></a>模式的使用</h3><p>现代软件设计的特征是需求的频繁变化。设计模式的要点是寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化。什么时候、什么地点应用设计模式比理解设计模式结构本身更为重要。</p><p>设计模式的宗旨是管理变化，提高复用性。设计模式不是把变化消灭了，而是把变化点和稳定点解耦合，然后将变化点转移集中到某一个或几个类中，来更好地应对变化。例如通过 Java 的反射机制配合配置文件可以方便地替换加载不同的类。</p><p>假设一种极端情况，软件中的所有都在变化，那么没有一种设计模式能解决问题。反之如果软件所有部分都是稳定的，没有变坏点，那么也没必要使用设计模式。绝大多数软件则是既有稳定的一部分，也有变化的一部分。通常 Framework 的开发人员对设计模式的理解要求更高，因为 Framework 往往要给 Application 开发者预留下很多接口和扩展点应应对将来可能的变化。</p><p>不要拘泥于 GOF 提出的 23 种设计模式，代码只要符合设计原则，解决耦合性问题，提高了复用性，就可以把它当做是一种模式的应用。</p><p>在什么时候不应该使用设计模式：</p><ul><li>代码可读性很差时，先提高代码可读性。</li><li>需求理解还很浅时，先搭建一个快速原型版本了解用户需求，再在后续的迭代中使用设计模式。</li><li>变化没有显现时，不要过度使用设计模式去预测变化。</li><li>不是系统过的关键依赖点，优先在关键依赖点使用模式。</li><li>项目没有复用价值时，典型的就是一些外包软件，甲方没有后期的软件升级迭代计划，就没有去使用设计模式的价值。反之，如果是自己公司的软件产品，前期使用好的设计模式能够大大减少后期需求变更时的工作量。</li><li>项目将要发布时，使用模式重构可能给项目带来新的 Bug。</li></ul><h3 id="重构到模式"><a href="#重构到模式" class="headerlink" title="重构到模式"></a>重构到模式</h3><p>设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的“Refactoring to Patterns”是目前普遍公认的最好的使用设计模式的方法。</p><p>重构获得模式（Refactoring to Patterns）：审视现有代码违反了哪些设计原则，在重构软件的过程中改善现有设计，一步步迭代到设计模式。良好的设计模式是演化的结果，不要追求一步到位，除非你是一个设计模式大师。</p><p>可以从下面 5 个重构的关键技法考虑优化代码的可能性：</p><ul><li>静态 → 动态</li><li>早绑定 → 晚绑定</li><li>继承 → 组合</li><li>编译时依赖 → 运行时依赖</li><li>紧耦合 → 松耦合</li></ul><h2 id="组件协作模式"><a href="#组件协作模式" class="headerlink" title="组件协作模式"></a>组件协作模式</h2><p>现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。通过组件协作模式，我们可以调用这些第三方库或框架，补充上特定的上层应用业务代码，就可以快速搭建出产品，而不用去造底层的轮子。</p><h3 id="模板方法-Template-Method"><a href="#模板方法-Template-Method" class="headerlink" title="模板方法 Template Method"></a>模板方法 Template Method</h3><p>模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><blockquote><p>Template Method Pattern: Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>某个算法框架由很多基本方法 （Primitive Method）组成，在抽象的父类中提供一个称之为模板方法（Template Method）的方法来定义这些基本方法的执行次序，而通过其子类来覆盖重写（override）某些步骤，从而使得相同的算法框架可以有不同的执行结果。</p><p>被模板调用的基本方法可以是具体方法（Concrete Method），空实现的钩子方法（Hook Method，钩子方法通常返回一个 <code>boolean</code> 类型的值，并以此来判断是否执行某一基本方法，因此在子类中可以通过覆盖钩子方法来决定是否执行父类中的某一方法，从而实现子类对父类行为的控制。），也可以是没有任何实现的抽象方法(Abstract Method)，一般推荐将它们设置为 <code>protected</code> 方法，因为这些方法通常只会让子类来重写才有意义，而不直接提供对外访问。</p><p>动机：在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><p>应用实例：“不要调用我，让我来调用你”的反向控制结构（Inverse of Control：Don’t call me, Let me call you.）是 Template Method 的典型应用。在早期应用程序开发者往往会写一个程序主流程来调用早已经写好的库和框架中的方法（早绑定）。而现在很多框架则是根据写好的模板方法的流程来调用应用程序开发者对基本方法的实现或者覆写（晚绑定）。这样应用程序开发者将程序的流程控制权还给框架，让框架来调用自己写的应用程序中的方法，而不是自己写程序去主动调用框架中的方法。但这样可能会让应用程序开发者只见树木，不见森林，看不到框架中调用方法的步骤和细节，所以必要时还是需要阅读框架源码查看底层细节。</p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236073.png" alt="image-20201213094249455"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span> </span>&#123;<br>    <span class="hljs-comment">//模板方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        primitiveOperation1();<br>        primitiveOperation2();<br>        primitiveOperation3();<br>&#125;<br><br>    <span class="hljs-comment">//基本方法—具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">primitiveOperation1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//实现代码</span><br>    &#125;<br><br>    <span class="hljs-comment">//基本方法—抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">primitiveOperation2</span><span class="hljs-params">()</span></span>;    <br><br>    <span class="hljs-comment">//基本方法—钩子方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">primitiveOperation3</span><span class="hljs-params">()</span>   </span><br><span class="hljs-function">    </span>&#123;  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 Strategy"></a>策略模式 Strategy</h3><p>策略模式：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它的客户变化。</p><blockquote><p>Strategy Pattern: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>策略模式又被称为政策（Policy）模式，每一个封装算法的类称之为策略（Strategy）类，策略模式提供了一种可插入式（Pluggable）算法的实现方案，同过传入不同的实现策略接口的对象，为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。通常上下文可以共享同一个 Strategy 对象，结合单例模式可以节省对象开销。</p><p>动机：在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都硬编码（Hard Coding）到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担（因为要白白执行很多判断语句）。</p><p>应用实例：当实现某个目标的算法不止一条，例如排序、查找、折扣计算等，使用策略模式可以在运行时方便地根据需要在各个算法之间进行切换。当含有大量嵌套的像 <code>if-else</code> 或者 <code>switch-case</code> 条件判断语句的代码通常往往都要考虑都需 Strategy 模式来消除条件判断语句解耦合。但是如果是性别和星期这种绝对稳定不变，没有变化可能的就不需要使用策略模式。</p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236074.png" alt="image-20201214220657032"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象策略类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//声明抽象算法</span><br>&#125;<br><span class="hljs-comment">//具体策略类A</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span> </span>&#123;<br>    <span class="hljs-comment">//算法的具体实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//算法A</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体策略类A</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span> </span>&#123;<br>    <span class="hljs-comment">//算法的具体实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//算法B</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//上下文环境类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Strategy strategy; <span class="hljs-comment">//维持一个对抽象策略类的引用</span><br><br>    <span class="hljs-comment">//注入策略对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStrategy</span><span class="hljs-params">(Strategy strategy)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.strategy= strategy;<br>    &#125;<br><br>    <span class="hljs-comment">//调用策略类中的算法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123;<br>        strategy.algorithm();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式 Observer"></a>观察者模式 Observer</h3><p>观察者模式：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。</p><blockquote><p>Observer Pattern: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>观察者模式又被称为发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式、从属者（Dependents）模式。</p><p>定义了对象之间一种一对多的依赖关系，让一个对象的改变能够影响其他对象。发生改变的对象称为观察目标，被通知的对象称为观察者。一个观察目标可以对应多个观察者，观察目标发送通知时，无需指定观察者，通知会自动传播。观察者自己决定是否需要订阅通知，目标对象对此一无所知。</p><p>动机：在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。</p><p>应用实例：</p><ul><li>网上商店中商品在名称、价格等发生变化，系统自动通知收藏该商品的会员。</li><li>基于事件的 UI 框架。</li><li>在传统的 MVC（Model-View-Controller）模式中，模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者，当模型层的数据发生改变时，视图层将自动改变其显示内容。</li><li>JDK 中 <code>java.util.Observer</code>、<code>java.util.Observable</code> 这两个类提供 Java 对观察者模式的支持：</li></ul><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236075.png" alt="image-20201214223247310"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象目标类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-comment">//定义一个观察者集合用于存储所有观察者对象</span><br>    <span class="hljs-keyword">protected</span> ArrayList observers&lt;Observer&gt; = <span class="hljs-keyword">new</span> ArrayList();<br><br>    <span class="hljs-comment">//注册方法，用于向观察者集合中增加一个观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        observers.add(observer);<br>    &#125;<br><br>    <span class="hljs-comment">//注销方法，用于在观察者集合中删除一个观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        observers.remove(observer);<br>    &#125;<br><br>    <span class="hljs-comment">//声明抽象通知方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体目标类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-comment">//实现通知方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//遍历观察者集合，调用每一个观察者的响应方法</span><br>        <span class="hljs-keyword">for</span>(Object obs:observers) &#123;<br>            ((Observer)obs).update();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。</p><h3 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 Decorator"></a>装饰模式 Decorator</h3><p>装饰模式：动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。</p><blockquote><p>Decorator Pattern: Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>装饰模式通过一种无须定义子类的方式给对象动态增加职责，采用组合而非继承的手法，在不改变一个对象本身功能的基础上给对象增加额外的新行为，是一种用于替代继承的技术。Decorator 模式实现了在运行时<br>动态扩展对象功能的能力，而且可以根据需要扩展多个功能。在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能。Decorator 类在接口上表现为 is-a Component 的继承关系，即 Decorator 类继承了 Component 类所具有的接口。但在实现上又表现为 has-a Component 的组合关系，即 Decorator 类又关联了一个 Component 对象。</p><p>透明（Transparent）装饰模式：要求客户端完全针对抽象编程，不将对象的引用声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别，可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象，但是无法在客户端单独调用装饰类里面的新增方法。</p><p>半透明（Semi-transparent）装饰模式：用具体装饰类型来声明装饰之后的对象，而具体构件使用抽象构件类型来声明。对于客户端而言，具体构件类型无须关心，是透明的，但是具体装饰类型必须指定，这是不透明的。可以单独调用装饰类里面的新增方法，但是不能如果对用一个对象的多次装饰，只能调用到最后一次装饰时具体装饰类中新增加的方法，无法调用到之前装饰时新增的方法。</p><p>动机：在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p><p>应用实例：当一个类既继承某一个类又聚合了这个类的对象，并且存在一个以这个类的对象为参数的构造方法，往往就使用到了装饰模式。Java 的 I/O 中使用装饰模式来为输入和输出字符流添加期望的功能。嵌套地调用构造方法也是使用到装饰模式的显著特征：<code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in))</code>.。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236076.png" alt="image-20201215110448194"></p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236077.png" alt="image-20201214225133922"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Component component; <span class="hljs-comment">//维持一个对抽象构件对象的引用</span><br><br>    <span class="hljs-comment">//注入一个抽象构件类型的对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Decorator</span><span class="hljs-params">(Component component)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.component=component;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        component.operation();  <span class="hljs-comment">//调用原有业务方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 Bridge"></a>桥接模式 Bridge</h3><p>桥接模式：将抽象部分与它的实现部分解耦，使得两者都能够独立变化。</p><blockquote><p>Bridge Pattern: Decouple an abstraction from its implementation so that the two can vary independently.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>桥接模式又被称为柄体（Handle and Body）模式或接口（Interface）模式。Bridge 模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。Bridge 模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge 模式是比多继承方案更好的解决方法。</p><p>动机：由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个维度的变化。</p><p>应用实例：Bridge 模式的应用一般在“两个非常强的变化维度”，例如一款毛笔在型号和颜色有两个变化维度，使用桥接模式让颜色和型号实现了分离，增加新的颜色或者型号对另一方没有任何影响。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236079.png" alt="image-20201215111848313"></p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236080.png" alt="image-20201215111239464"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现类接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Implementor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationImpl</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteImplementor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Implementor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationImpl</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//具体业务方法的实现</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Abstraction</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Implementor impl; <span class="hljs-comment">//定义实现类接口对象</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImpl</span><span class="hljs-params">(Implementor impl)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.impl=impl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//声明抽象业务方法</span><br>&#125;<br><span class="hljs-comment">//扩充抽象类（细化抽象类）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefinedAbstraction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Abstraction</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//业务代码</span><br>        impl.operationImpl(); <span class="hljs-comment">//调用实现类的方法</span><br>        <span class="hljs-comment">//业务代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象创建模式"><a href="#对象创建模式" class="headerlink" title="对象创建模式"></a>对象创建模式</h2><p>通过“对象创建” 模式绕开 new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</p><h3 id="简单工厂模式-Simple-Factory"><a href="#简单工厂模式-Simple-Factory" class="headerlink" title="简单工厂模式 Simple Factory"></a>简单工厂模式 Simple Factory</h3><p>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><p>简单工厂模式又被称为静态工厂方法（Static Factory Method）模式，因为在简单工厂模式中用于创建实例的方法通常是静态（static）方法。对象创建和使用的分离，客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可。简单工厂模式并不在 GOF 所提出的 23 种设计模式之列。</p><p>动机：客户端只知道传入工厂类的参数，对于如何创建对象并不关心。工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p><p>应用实例：下图的图表工厂可以通过传入不同的类型参数即可得到不同类型的图表。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236081.png" alt="image-20201215114345630"></p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236082.png" alt="image-20201215112908212"></p><p>简单工厂的简化：将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236083.png" alt="image-20201215113630774"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-comment">//静态工厂方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Product <span class="hljs-title">getProduct</span><span class="hljs-params">(String arg)</span> </span>&#123;<br>        Product product = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (arg.equalsIgnoreCase(<span class="hljs-string">&quot;A&quot;</span>)) &#123;<br>            product = <span class="hljs-keyword">new</span> ConcreteProductA();<br>            <span class="hljs-comment">//初始化设置product</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arg.equalsIgnoreCase(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>            product = <span class="hljs-keyword">new</span> ConcreteProductB();<br>            <span class="hljs-comment">//初始化设置product</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工厂方法-Factory-Method"><a href="#工厂方法-Factory-Method" class="headerlink" title="工厂方法 Factory Method"></a>工厂方法 Factory Method</h3><p>工厂方法模式：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p><blockquote><p>Factory Method Pattern: Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>工厂模式（Factory Pattern）又被称为虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern），工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><p>动机：在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。</p><p>应用举例：日志记录器（Logger）工厂可以封装记录器的初始化过程并保证多种记录器切换的灵活性。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236084.png" alt="image-20201215115120118"></p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236085.png" alt="image-20201215114920393"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象工厂-Abstract-Factory"><a href="#抽象工厂-Abstract-Factory" class="headerlink" title="抽象工厂 Abstract Factory"></a>抽象工厂 Abstract Factory</h3><p>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p><blockquote><p>Abstract Factory Pattern: Provide an interface for creating families of related or dependent objects without specifying their concrete classes.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>抽象工厂模式又称为工具（Kit）模式，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品，也可以叫它家族工厂，产品族工厂。抽象工厂可以很方便的增加新的产品族，无须修改已有系统，只需要增加具体产品并对应增加一个新的具体工厂。但若是要增加新的产品等级结构，则需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。如果没有多个产品族对象创建的需求变化，完全可以使用简单工厂模式，如果一个产品族只有一种产品，则完全可以使用抽象工厂模式。</p><p>动机：在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。</p><p>应用实例：海尔工厂生产海尔产品族中的所有产品。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236086.png" alt="image-20201215120824157"></p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236087.png" alt="image-20201215120210674"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractProductA <span class="hljs-title">createProductA</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//工厂方法一</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractProductB <span class="hljs-title">createProductB</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//工厂方法二</span><br>    ……<br>&#125;<br><span class="hljs-comment">//具体工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-comment">//工厂方法一</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractProductA <span class="hljs-title">createProductA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductA1();<br>    &#125;<br><br>    <span class="hljs-comment">//工厂方法二</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractProductB <span class="hljs-title">createProductB</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductB1();<br>    &#125;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h3><p>原型模式：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。</p><blockquote><p>Prototype Pattern: Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>原型方法通过复制一个原型对象得到与原型对象一模一样的新对象，相比使用工厂方法，原型方法把创建任务回归到类本身中来，创建新对象（也称为克隆对象）的工厂就是原型类自身，原型对象通过复制自己来实现创建过程。原型模式常用来创建结构复杂的对象，使用工厂方还需要对创建的对象进行大量初始化操作才能得到自己想要的状态，使用原型模式可以直接从一个理想的中间状态的原型对象克隆出新对象，再根据需要对其成员变量稍作修改。</p><p>浅克隆与深克隆：</p><ul><li>浅克隆（Shallow Clone）：当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236088.png" alt="image-20201215130409732"></li></ul><ul><li>深克隆（Deep Clone）：除了对象本身被复制外，对象所包含的所有成员变量也将被复制<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236089.png" alt="image-20201215130353383"></li></ul><p>动机：在软件系统中，经常面临着“某些结构复杂的对象”的创建工作;由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。</p><p>应用实例：Java 中 <code>Object</code> 类已经提供了浅克隆的实现，可以根据自己需要来在类中实现 <code>Cloneable</code> 接口来重写 <code>clone()</code> 方法，手动给成员变量赋值或者利用序列化来实现深克隆，<code>clone()</code> 方法并不是 <code>Cloneable</code> 接口中的方法，而是 <code>Object</code> 类中的方法，<code>Cloneable</code> 只是一个空的标记接口。</p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236090.png" alt="image-20201215122228277"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcretePrototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-comment">//浅克隆</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        Object object = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = <span class="hljs-keyword">super</span>.clone();<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(CloneNotSupportedExecption exception) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Not support cloneable&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (ConcretePrototype)object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构建器-Builder"><a href="#构建器-Builder" class="headerlink" title="构建器 Builder"></a>构建器 Builder</h3><p>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><blockquote><p>Builder Pattern: Separate the construction of a complex object from its representation so that the same construction process can create different representations.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>建造者模式可以将部件本身和它们的组装过程分开，关注如何一步步创建一个包含多个组成部分的复杂对象，用户只需要指定复杂对象的类型即可得到该对象，而无须知道其内部的具体构造细节。Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</p><p>动机：在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p>应用实例：使用建造者模式来实现游戏人物模型的创建，根据不同的角色先逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236091.png" alt="image-20201215171434220"></p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236092.png" alt="image-20201215161637683"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//复杂对象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<br><span class="hljs-keyword">private</span> String partA; <span class="hljs-comment">//定义部件，部件可以是任意类型，包括值类型和引用类型</span><br><span class="hljs-keyword">private</span> String partB;<br><span class="hljs-keyword">private</span> String partC;<br><br><span class="hljs-comment">//partA的Getter/Setter方法省略</span><br><span class="hljs-comment">//partB的Getter/Setter方法省略</span><br><span class="hljs-comment">//partC的Getter/Setter方法省略</span><br>&#125;<br><span class="hljs-comment">//抽象建造者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>    <span class="hljs-comment">//创建产品对象</span><br>   <span class="hljs-keyword">protected</span> Product product=<span class="hljs-keyword">new</span> Product();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//返回产品对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体建造者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span> </span>&#123;<br>        product.setPartA(<span class="hljs-string">&quot;A1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span> </span>&#123;<br>        product.setPartB(<span class="hljs-string">&quot;B1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span> </span>&#123;<br>        product.setPartC(<span class="hljs-string">&quot;C1&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//指挥者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Builder builder;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.builder=builder;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBuilder</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.builder=builer;<br>    &#125;<br><br>    <span class="hljs-comment">//产品构建与组装方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.buildPartA();<br>        builder.buildPartB();<br>        builder.buildPartC();<br>        <span class="hljs-keyword">return</span> builder.getResult();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象性能模式"><a href="#对象性能模式" class="headerlink" title="对象性能模式"></a>对象性能模式</h2><p>面向对象很好地解决了“抽象”的问题，但是必不可免地要付出—定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。</p><h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h3><p>单例模式：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</p><blockquote><p>Singleton Pattern: Ensure a class has only one instance, and provide a global point of access to it.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>让类自身负责创建和保存它的唯一实例，保证不能创建其他实例，并提供一个访问该实例的方法。和工厂不同，单例模式之所以不直接用 <code>new</code> 来创建创建，绕过常规的构造器，不是为了解耦合，而是为了逻辑正确、安全和性能（节省对象开销）。</p><p>动机：在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。</p><p>应用实例：Windows 操作系统中的任务管理器和回收站、Java 的 <code>Runtime</code> 类实例、各种连接池。</p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236093.png" alt="image-20201215173916775"></p><p>代码：</p><ol><li><p>饿汉式单例模式（EagerSingleton）：类加载到内存就实例化一个单例，JVM会保证线程安全，无须考虑多个线程同时访问的问题，调用速度和反应时间优于懒汉式单例。不管用到与否,只要加载了这个类就会实例化，，系统加载时间可能会比较长，资源利用效率不及懒汉式单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EagerSingleton</span> </span>&#123; <br>    <span class="hljs-comment">//声明实例为 static 类变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EagerSingleton instance = <span class="hljs-keyword">new</span> EagerSingleton(); <br>    <span class="hljs-comment">//构造器 private 防止被其他类调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">EagerSingleton</span><span class="hljs-params">()</span> </span>&#123; &#125; <br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EagerSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>懒汉式单例类（LazySingleton）：实现了延迟加载，解决了饿汉式的缺点,但是带来了线程不安全问题,可能导致有多个实例被创建，需通过双重检查锁定等机制进行控制，处理多个线程同时访问的问题，这将导致系统性能受到一定影响。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法锁，在获取实例方法上加锁,有较高的性能损耗,</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazySingleton</span> </span>&#123; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LazySingleton instance = <span class="hljs-keyword">null</span>; <br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazySingleton</span><span class="hljs-params">()</span> </span>&#123; &#125; <br>    <span class="hljs-comment">//给获取实例加锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> LazySingleton(); <br>        &#125;<br>        <span class="hljs-keyword">return</span> instance; <br>    &#125;<br>&#125;<br><span class="hljs-comment">//锁代码块，在局部代码块加锁，并双重检查锁定（Double-Check Locking）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazySingleton</span> </span>&#123; <br>    <span class="hljs-comment">//由于编译器指令重排（reorder）优化导致多线程不安全，可能在一个线程拿到锁但还没有来得及执行构造器，另一线程就提前得到了返回地址使用静态内部类,在静态内部类里面声明一个static修饰的外部类变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> LazySingleton instance = <span class="hljs-keyword">null</span>; <br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazySingleton</span><span class="hljs-params">()</span> </span>&#123; &#125; <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-comment">//第一重判断</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//锁定代码块</span><br>            <span class="hljs-keyword">synchronized</span> (LazySingleton.class) &#123;<br>                <span class="hljs-comment">//第二重判断，instance 要用 volatile 修饰</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> LazySingleton(); <span class="hljs-comment">//创建单例实例</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> instance; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用静态内部类，在静态内部类里面声明一个 <code>static</code> 修饰的外部类变量，既实现了懒加载,又保证了线程安全，使用静态内部类需要语言特性支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Initialization on Demand Holder</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">//静态内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HolderClass</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> HolderClass.instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>使用枚举类产生单例，不仅可以解决线程同步，还可以防止利用反序列化和反射来产生单例，这是《Effective Java》中所推荐的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用 Singleton.INSTANCE 来引用单例对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br> INSTANCE;<br>……  <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式 Flyweight"></a>享元模式 Flyweight</h3><p>享元模式：运用共享技术有效地支持大量细粒度对象的复用。</p><blockquote><p>Flyweight Pattern: Use sharing to support large numbers of fine-grained objects efficiently.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>将具有相同内部状态的对象存储在享元池（Flyweight Pool）中，享元池中的对象是可以实现共享的，需要的时候将对象从享元池中取出，即可实现对象的复用，减少内存中对象的数量。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，使得相同或者相似的对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。享元的共享状态值往往是只读的。</p><p>动机：在软件系统采用纯粹面向对象的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。</p><p>应用举例：Java 中 <code>String</code> 字符串类。</p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236094.png" alt="image-20201215182815456"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象享元类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String extrinsicState)</span></span>;<br>&#125;<br><span class="hljs-comment">//具体享元类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFlyweight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-comment">//内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的</span><br>    <span class="hljs-keyword">private</span> String intrinsicState;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteFlyweight</span><span class="hljs-params">(String intrinsicState)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.intrinsicState = intrinsicState;<br>    &#125;<br><br>    <span class="hljs-comment">//外部状态extrinsicState在使用时由外部设置，不保存在享元对象中，即使是同一个对象，在每一次调用时可以传入不同的外部状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String extrinsicState)</span> </span>&#123;<br>        <span class="hljs-comment">//实现业务方法</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//非共享具体享元类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsharedConcreteFlyweight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String extrinsicState)</span> </span>&#123;<br>        <span class="hljs-comment">//实现业务方法</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//享元工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightFactory</span> </span>&#123;<br>    <span class="hljs-comment">//定义一个HashMap用于存储享元对象，实现享元池</span><br>    <span class="hljs-keyword">private</span> HashMap flyweights = <span class="hljs-keyword">new</span> HashMap();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Flyweight <span class="hljs-title">getFlyweight</span><span class="hljs-params">(String key)</span> </span>&#123;<br>       <span class="hljs-comment">//如果对象存在，则直接从享元池获取</span><br>       <span class="hljs-keyword">if</span> (flyweights.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> (Flyweight)flyweights.get(key);<br>        &#125;<br>        <span class="hljs-comment">//如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            Flyweight fw = <span class="hljs-keyword">new</span> ConcreteFlyweight();<br>            flyweights.put(key,fw);<br>            <span class="hljs-keyword">return</span> fw;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口隔离模式"><a href="#接口隔离模式" class="headerlink" title="接口隔离模式"></a>接口隔离模式</h2><p>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</p><h3 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 Facade"></a>外观模式 Facade</h3><p>外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><blockquote><p>Facade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>外观模式又称为门面模式，引入一个新的外观类（Facade）来负责和多个子系统（Subsystem）进行交互，而客户类只需与外观类交互，为多个业务类的调用提供了一个统一的入口，客户类与子系统之间原有的复杂引用关系由外观类来实现，简化了类与类之间的交互，从而降低了系统的耦合度。子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。外观类往往只需要一个实例，可以结合单例模式。</p><p>动机：组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</p><p>应用实例：大型公司的前台是企业内部与外界交互的接口，访客通过前台的窗口来和各个部门打交道，而不是直接进入公司内部的各个部门。</p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236095.png" alt="image-20201215184445383"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//各个子系统</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemA</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//业务实现代码</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemB</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//业务实现代码</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemC</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodC</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//业务实现代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//外观类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> SubSystemA obj1 = <span class="hljs-keyword">new</span> SubSystemA();<br>    <span class="hljs-keyword">private</span> SubSystemB obj2 = <span class="hljs-keyword">new</span> SubSystemB();<br>    <span class="hljs-keyword">private</span> SubSystemC obj3 = <span class="hljs-keyword">new</span> SubSystemC();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        obj1.method();<br>        obj2.method();<br>        obj3.method();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h3><p>代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p><blockquote><p>Proxy Pattern: Provide a surrogate or placeholder for another object to control access to it.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>代理模式又称为经纪人（Surrogate/Broker）模式，两个对象本来可以直接依赖，但是由于性能、安全或者分布式的原因必须隔离。通过引入一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，代理对象中去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。</p><p>几种常见的代理模式：</p><ul><li>远程代理（Remote Proxy）：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使（Ambassador）。</li><li>虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li>保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li>缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li>智能引用代理（Smart Reference Proxy）：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</li><li>动态代理（Dynamic Proxy）：可以让系统在运行时根据实际需要来动态创建代理类，让同一个代理类能够代理多个不同的真实主题类而且可以代理不同的方法。</li></ul><p>动机：在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。</p><p>应用实例：Java RMI 远程代理框架就用到了代理模式。RMI（Remote Method Invocation）是基于 Java 技术的分布式编程模型，为 Java 程序提供远程访问服务。通过 RMI 允许对象在不同的 Java 虚拟机（Java Virtual Machine）之间进行通信。此外 JDK 中的 <code>java.lang.reflect</code> 这个包还提供对了动态代理的支持。</p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236096.png" alt="image-20201215185123943"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象主题类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//真实主题类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//业务方法具体实现代码</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> RealSubject realSubject = <span class="hljs-keyword">new</span> RealSubject();  <span class="hljs-comment">//维持一个对真实主题对象的引用 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preRequest</span><span class="hljs-params">()</span> </span>&#123;<br>        …...<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>        preRequest();<br>        realSubject.request();  <span class="hljs-comment">//调用真实主题对象的方法</span><br>        postRequest();<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postRequest</span><span class="hljs-params">()</span> </span>&#123;<br>        ……<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h3><p>适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p><blockquote><p>Adapter Pattern: Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>适配器模式又名包装器(Wrapper)模式，适配器模式解决的是老旧接口不兼容需要转换的问题。通过引入一个适配器类来重用现有的适配者类，将目标类和适配者类解耦，无须修改原有结构，增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</p><p>类适配器和对象适配器：</p><ul><li>类适配器模式置换一些适配者的方法很方便，但是 Java  中一次最多只能适配一个适配者类，并且目标抽象类只能为接口，因为 Java 不支持多继承。</li><li>对象适配器模式采用对象组合的方式，可以把多个不同的适配者适配到同一个目标，更加推荐使用。</li></ul><p>动机：在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。</p><p>应用实例：给玩具汽车添加上警灯闪烁和警笛音效。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236097.png" alt="image-20201215200322719"></p><p>结构类图：</p><p>类适配器：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236098.png" alt="image-20201215193234377"></p><p>对象适配器：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236099.png" alt="image-20201215193244032"></p><p>双向适配器：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236100.png" alt="image-20201215193406010"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类适配器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.specificRequest();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//对象适配器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Target</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee; <span class="hljs-comment">//维持一个对适配者对象的引用</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.adaptee=adaptee;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>        adaptee.specificRequest(); <span class="hljs-comment">//转发调用</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//双向适配器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span>,<span class="hljs-title">Adaptee</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Target target;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adapter</span><span class="hljs-params">(Target target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.adaptee = adaptee;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>        adaptee.specificRequest();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">specificRequest</span><span class="hljs-params">()</span> </span>&#123;<br>        target.request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式 Mediator"></a>中介者模式 Mediator</h3><p>中介者模式：定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且让你可以独立地改变它们之间的交互。</p><blockquote><p>Mediator Pattern: Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>中介者模式又称为调停者模式，在中介者模式中，通过引入中介者来简化对象之间的复杂交互，中介者模式是迪米特法则的一个典型应用，对象之间多对多的复杂关系转化为相对简单的一对多关系。中介者模式将系统的网状结构变成以中介者为中心的星型结构，同事对象不再直接与另一个对象联系，它通过中介者对象与另一个对象发生相互作用。新对象的引入不会给系统的结构带来大量的修改工作。中介者模式解决的是系统内多个对象之间的通信问题，减少类之间的关联。外观模式解决的是客户类和子系统类的通信问题。中介者模式中对象可以向中介者请求协作。外观模式中子系统对象不会对外观有任何协作请求。</p><p>动机：在软件构建过程中，经常会出现多个对象互相关联交互的情况对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</p><p>应用实例：房屋中介公司扮演了出租者、求租者的中介者。</p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236101.png" alt="image-20201215200807616"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象中介者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> ArrayList&lt;Colleague&gt; colleagues = <span class="hljs-keyword">new</span> ArrayList&lt;Colleague&gt;(); <span class="hljs-comment">//用于存储同事对象</span><br><br>    <span class="hljs-comment">//注册方法，用于增加同事对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Colleague colleague)</span> </span>&#123;<br>        colleagues.add(colleague);<br>    &#125;<br><br>    <span class="hljs-comment">//声明抽象的业务方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体中介者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-comment">//实现业务方法，封装同事之间的调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        ......<br>        ((Colleague)(colleagues.get(<span class="hljs-number">0</span>))).method1(); <span class="hljs-comment">//通过中介者调用同事类的方法</span><br>        ......<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象同事类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Mediator mediator; <span class="hljs-comment">//维持一个抽象中介者的引用</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Colleague</span><span class="hljs-params">(Mediator mediator)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mediator=mediator;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//声明自身方法，处理自己的行为</span><br><br>    <span class="hljs-comment">//定义依赖方法，与中介者进行通信</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        mediator.operation();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体同事类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteColleague</span><span class="hljs-params">(Mediator mediator)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(mediator);<br>    &#125;<br><br>    <span class="hljs-comment">//实现自身方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        ......<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态变化模式"><a href="#状态变化模式" class="headerlink" title="状态变化模式"></a>状态变化模式</h2><p>在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案。</p><h3 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a>状态模式 State</h3><p>状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p><blockquote><p>State Pattern: Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。通常上下文可以共享一个状态实例，结合单例模式可以节省对象开销。</p><p>动机：在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。</p><p>应用实例：银行根据账户的余额实现账户的状态自动装换。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236102.png" alt="image-20201215202655621"></p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236103.png" alt="image-20201215202313003"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象状态类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-comment">//声明抽象业务方法，不同的具体状态类可以有不同的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体状态类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//方法具体实现代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//环境上下文类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> State state; <span class="hljs-comment">//维持一个对抽象状态对象的引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;  <span class="hljs-comment">//其他属性值</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//其他代码</span><br>        state.handle(); <span class="hljs-comment">//调用状态对象的业务方法</span><br>        <span class="hljs-comment">//其他代码</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="备忘录-Memento"><a href="#备忘录-Memento" class="headerlink" title="备忘录 Memento"></a>备忘录 Memento</h3><p>备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样就可以在以后将对象恢复到原先保存的状态。</p><blockquote><p>Memento Pattern: Without violating encapsulation, capture and externalize an object’s internal state so that the object can be restored to this state later.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>备忘录模式又名标记（Token）模式，提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤。首先保存软件系统的历史状态，当用户需要取消错误操作并且返回到某个历史状态时，可以取出事先保存的历史状态来覆盖当前状态。现在很少使用备忘录模式，而是采用效率更高更易实现的序列化方式来实现快照。</p><p>动机：在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</p><p>应用实例：很多软件所提供的撤销（Undo）和重做（Redo）操作中就使用了备忘录模式。</p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236104.png" alt="image-20201215203410088"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//原发器类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Originator</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-comment">//创建一个备忘录对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">createMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//根据备忘录对象恢复原发器状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restoreMemento</span><span class="hljs-params">(Memento m)</span> </span>&#123;<br>        state = m.state;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state=state;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//将Memento类与Originator类定义在同一个包(package)中来实现封装，使用默认可见性定义Memento类，即保证其在包内可见。或者将备忘录类作为原发器类的内部类，使得只有原发器才可以访问备忘录中的数据，其他对象都无法使用备忘录中的数据。</span><br><span class="hljs-comment">//备忘录类，默认可见性，包内可见</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br><br>    Memento(Originator o) &#123;<br>        state = o.getState();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state=state;<br>    &#125;<br><br>    <span class="hljs-function">String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//负责人类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Caretaker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Memento memento;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">getMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> memento;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemento</span><span class="hljs-params">(Memento memento)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.memento=memento;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据结构模式"><a href="#数据结构模式" class="headerlink" title="数据结构模式"></a>数据结构模式</h2><p>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</p><h3 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 Composite"></a>组合模式 Composite</h3><p>组合模式：组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。</p><blockquote><p>Composite Pattern: Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>组合模式又称为“部分-整体”（Part-Whole）模式。组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树形结构的一部分，它描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象，无需关心处理的是叶子对象还是容器对象。</p><p>透明组合模式和安全组合模式：</p><ul><li>透明组合模式：抽象构件 Component 中声明了所有用于管理成员对象的方法，包括 <code>add()</code>、<code>remove()</code>，以及 <code>getChild()</code> 等方法。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象。缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不应该能调用那些容器对象才能拥有的方法。</li><li>安全组合模式：抽象构件 Component 中没有声明任何用于管理成员对象的方法，而是在 <code>Composite</code> 类中声明并实现这些方法。对于叶子对象，客户端不可能调用到这些方法。缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件，要判断某一个对象是是叶子和容器再使用。</li></ul><p>动机：在软件在某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器丙部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</p><p>应用实例：操作系统的目录结构中，包含文件和文件夹两类不同的元素，在文件夹中可以包含文件，还可以继续包含子文件夹，在文件中不能再包含子文件或者子文件夹，文件夹对应着容器（Container）对象，文件对应着叶子（Leaf）对象。</p><p>结构类图：</p><p>透明组合模式：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236105.png" alt="image-20201216104601381"></p><p>安全组合模式：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236106.png" alt="image-20201216104652582"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//透明组合模式</span><br><span class="hljs-comment">//抽象构件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span></span>; <span class="hljs-comment">//增加成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span></span>; <span class="hljs-comment">//删除成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>; <span class="hljs-comment">//获取成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//业务方法</span><br>&#125;<br><span class="hljs-comment">//叶子构件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span> </span>&#123; <br>        <span class="hljs-comment">//异常处理或错误提示</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span> </span>&#123; <br>        <span class="hljs-comment">//异常处理或错误提示</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123; <br>        <span class="hljs-comment">//异常处理或错误提示</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//叶子构件具体业务方法的实现</span><br>    &#125; <br>&#125;<br><span class="hljs-comment">//容器构件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Component&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Component&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span> </span>&#123;<br>        list.add(c);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span> </span>&#123;<br>        list.remove(c);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (Component)list.get(i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//容器构件具体业务方法的实现，将递归调用成员构件的业务方法</span><br>        <span class="hljs-keyword">for</span>(Object obj:list) &#123;<br>            ((Component)obj).operation();<br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式 Iterator"></a>迭代器模式 Iterator</h3><p>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，且不用暴露该对象的内部表示。</p><blockquote><p>Iterator Pattern: Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>迭代器模式又称为游标（Cursor）模式。将遍历数据的行为从聚合对象中分离出来，封装在迭代器对象中，由迭代器来提供遍历聚合对象内部数据的行为，简化聚合对象的设计，更符合单一职责原则。客户端无须了解聚合对象的内部结构即可实现对聚合对象中成员的遍历，还可以根据需要很方便地增加新的遍历方式。Java 中迭代器常常和泛型一起配合使用，保证了编译时的正确，编译后泛型类型会被擦除。</p><p>动机：在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素;同时这种“透明遍历”也为“同一种算法在多种集合对象上进行操作”提供了可能。</p><p>应用实例：<code>java.util.Iterator</code> 这个类提供 Java 集合对迭代器的支持。Java 1.5 出现的增强的 <code>for</code> 循环语句也是利用到了迭代器。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236107.png" alt="image-20201216114755094"></p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236108.png" alt="image-20201216114429923"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象迭代器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">//将游标指向第一个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">//将游标指向下一个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">//判断是否存在下一个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">currentItem</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//获取游标指向的当前元素</span><br>&#125;<br><span class="hljs-comment">//具体迭代器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ConcreteAggregate objects; <span class="hljs-comment">//维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cursor;  <span class="hljs-comment">//定义一个游标，用于记录当前访问位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteIterator</span><span class="hljs-params">(ConcreteAggregate objects)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.objects=objects;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>&#123;  ......  &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;  ......  &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;  ......  &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">currentItem</span><span class="hljs-params">()</span> </span>&#123;  ......  &#125;<br>&#125;<br><span class="hljs-comment">//抽象聚合类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Aggregate</span> </span>&#123;<br>    <span class="hljs-function">Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体聚合类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteAggregate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Aggregate</span> </span>&#123;<br>    ......<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteIterator(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ......<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="职责链模式-Chain-of-Responsibility"><a href="#职责链模式-Chain-of-Responsibility" class="headerlink" title="职责链模式 Chain of Responsibility"></a>职责链模式 Chain of Responsibility</h3><p>职责链模式：避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。</p><blockquote><p>Chain of Responsibility Pattern: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>职责链模式将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上，将请求的发送者和请求的处理者解耦。职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。</p><p>纯与不纯的职责链模式</p><ul><li>纯的职责链模式：一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，一个请求必须被某一个处理者对象所接收，如果请求到职责链的末尾仍得不到处理，应该有一个合理的缺省处理机制，不能出现某个请求未被任何一个处理者对象处理的情况。</li><li>不纯的职责链模式：允许某个请求被一个具体处理者部分处理后向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，一个请求可以最终不被任何处理者对象所接收并处理。</li></ul><p>动机：在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显式指定，将必不可少地带来请求发送者与接受者的紧耦合。</p><p>应用实例：辅导员、系主任、院长、校长都可以处理奖学金申请表，他们构成一个处理申请表的链式结构，申请表沿着这条链进行传递，这条链就称为职责链。JavaScript 的事件浮升（Event Bubbling）处理机制。</p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236109.png" alt="image-20201216120528500"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象处理者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-comment">//维持对下家的引用</span><br>    <span class="hljs-keyword">protected</span> Handler successor;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSuccessor</span><span class="hljs-params">(Handler successor)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.successor=successor;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(String request)</span></span>;<br>&#125;<br><span class="hljs-comment">//具体处理者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(String request)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (请求满足条件) &#123;<br>            <span class="hljs-comment">//处理请求</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.successor.handleRequest(request); <span class="hljs-comment">//转发请求</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端调用职责链代码段</span><br>……<br>Handler handler1, handler2, handler3;<br>handler1 = <span class="hljs-keyword">new</span> ConcreteHandlerA();<br>handler2 = <span class="hljs-keyword">new</span> ConcreteHandlerB();<br>handler3 = <span class="hljs-keyword">new</span> ConcreteHandlerC();<br><span class="hljs-comment">//创建职责链，给处理者指定下家</span><br>handler1.setSuccessor(handler2);<br>handler2.setSuccessor(handler3);<br><span class="hljs-comment">//发送请求，请求对象通常为自定义类型</span><br>handler1.handleRequest(<span class="hljs-string">&quot;请求对象&quot;</span>);<br>……<br></code></pre></td></tr></table></figure><h2 id="行为变化模式"><a href="#行为变化模式" class="headerlink" title="行为变化模式"></a>行为变化模式</h2><p>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</p><h3 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a>命令模式 Command</h3><p>命令模式：将一个请求封装为一个对象，从而让你可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。</p><blockquote><p>Command Pattern: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>命令模式别名为动作（Action）模式或事务（Transaction）模式。命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分开。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。</p><p>动机：在软件构建过程中，“行为请求者”与“行为实现者”通常呈现—种“紧耦合”。但在某些场合——比如需要对行为进行“记录.撤销/重做（undo/redo）、事务”等处理，这种无法抵御变化的紧耦合是不合适的。</p><p>应用实例：</p><ul><li>自定义快捷键：通过修改配置文件，更换具体的命令类，使得按下相同的快捷键可以调用不同的事件处理类方法。快捷键是请求发送者，事件处理类是请求的最终接收者。发送者与接收者之间引入了新的命令对象，将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。</li><li>命令队列：当一个请求发送者发送一个请求时，有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理，增加一个 <code>CommandQueue</code> 类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者。</li><li>记录请求日志：将请求的历史记录保存下来，通常以日志文件（Log File）的形式永久存储在计算机中，将发送请求的命令对象通过序列化写到日志文件中，命令类必须实现接口 <code>Serializable</code>。</li><li>撤销操作：可以通过对命令类添加上 <code>undo()</code> 和 <code>redo()</code> 方法，使得系统支持撤销（Undo）操作和恢复（Redo）操作。</li><li>宏命令：宏命令（Macro Command）又称为组合命令（Composite Command），它是组合模式和命令模式联用的产物。宏命令是一个具体命令类，它拥有一个集合，在该集合中包含了对其他命令对象的引用。当调用宏命令的 <code>execute()</code> 方法时，将递归调用它所包含的每个成员命令的 <code>execute()</code> 方法。一个宏命令的成员可以是简单命令，还可以继续是宏命令，执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理。</li></ul><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236110.png" alt="image-20201216121857882"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象命令类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体命令类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Receiver receiver; <span class="hljs-comment">//维持一个对请求接收者对象的引用</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        receiver.action(); <span class="hljs-comment">//调用请求接收者的业务处理方法action()</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//请求接收者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//具体操作</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//调用者（请求发送者）类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Command command;<br><br>    <span class="hljs-comment">//构造注入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Invoker</span><span class="hljs-params">(Command command)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.command = command;<br>    &#125;<br><br>    <span class="hljs-comment">//设值注入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command command)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.command = command;<br>    &#125;<br><br>    <span class="hljs-comment">//业务方法，用于调用命令类的execute()方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>        command.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问器模式-Visitor"><a href="#访问器模式-Visitor" class="headerlink" title="访问器模式 Visitor"></a>访问器模式 Visitor</h3><p>访问者模式：表示一个作用于某对象结构中的各个元素的操作。访问者模式让你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><blockquote><p>Visitor Pattern: Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>访问者模式的对象结构（Object Structure）中存储了多种不同类型的元素信息，将有关元素对象的访问行为集中到一个访问者对象中，不同的具体访问者对这些元素有不同的处理方式。增加新的元素处理方式只需要增加一个新的具体访问者，但是如果要增加新的具体元素类会破坏 Visitor 的封装。类似于抽象工厂中产品族和产品等级结构的关系，对开闭原则具有倾斜性，适用于对象结构中元素类稳定，对元素的处理操作经常变化的场景。</p><p>动机：在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会合子类带来很繁重的变更负担，甚至破坏原有设计。</p><p>应用实例：公司的人力资源部负责汇总每周员工工作时间，财务部负责计算每周员工工资。员工列表对应对象结构，全职员工和兼职员工对应着具体元素类，人力资源部和财务部对应着不同的具体访问者，分别对员工列表有着不同的操作：计算工作时间和计算工资。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236111.png" alt="image-20201216140651064"></p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236112.png" alt="image-20201216130631797"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象访问者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementA elementA)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementB elementB)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementC elementC)</span> </span>&#123;<br>        <span class="hljs-comment">//元素ConcreteElementC操作代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体访问者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementA elementA)</span> </span>&#123;<br>        <span class="hljs-comment">//元素ConcreteElementA操作代码</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementB elementB)</span> </span>&#123;<br>        <span class="hljs-comment">//元素ConcreteElementB操作代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象元素类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Element</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>;<br>&#125;<br><span class="hljs-comment">//具体元素类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteElementA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Element</span> </span>&#123;<br>    <span class="hljs-comment">//主动去调用访问者的处理操作来处理元素自己</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//业务方法</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//对象结构类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectStructure</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">//定义一个集合用于存储元素对象</span><br>    <span class="hljs-keyword">private</span> ArrayList&lt;Element&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Element&gt;(); <br><br>    <span class="hljs-comment">//接受访问者的访问操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        <span class="hljs-comment">//遍历对象结构中的每一个元素执行访问者的操作</span><br><span class="hljs-keyword">for</span>(Element e : list) &#123;<br>            e.accept(visitor);<br>        &#125;        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addElement</span><span class="hljs-params">(Element element)</span> </span>&#123;<br>        list.add(element);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(Element element)</span> </span>&#123;<br>        list.remove(element);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="领域规则模式"><a href="#领域规则模式" class="headerlink" title="领域规则模式"></a>领域规则模式</h2><p>在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。</p><h3 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式 Interpreter"></a>解释器模式 Interpreter</h3><p>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><blockquote><p>Interpreter Pattern: Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p></blockquote><p>解释器模式定义一套文法规则来实现对这些语句的解释，即使用规定格式和语法的代码设计一个自定义语言。解释器模式适合简单的文法规则，对于复杂的文法需要使用语法分析生成器工具。</p><p>动机：在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频频繁的变化。</p><p>应用实例：解析字符串形式的四则远算表达式。</p><p>结构类图：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192236113.png" alt="image-20201216131849497"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象表达式类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span></span>;<br>&#125;<br><span class="hljs-comment">//终结符表达式类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TerminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> </span>&#123;<br>        <span class="hljs-comment">//终结符表达式的解释操作</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//非终结符表达式类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonterminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AbstractExpression left;<br>    <span class="hljs-keyword">private</span> AbstractExpression right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NonterminalExpression</span><span class="hljs-params">(AbstractExpression left,AbstractExpression right)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.left=left;<br>        <span class="hljs-keyword">this</span>.right=right;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> </span>&#123;<br>        <span class="hljs-comment">//递归调用每一个组成部分的interpret()方法</span><br>        <span class="hljs-comment">//在递归调用时指定组成部分的连接方式，即非终结符的功能</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//上下文环境类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(String key, String value)</span> </span>&#123;<br>        <span class="hljs-comment">//往环境类中设值</span><br>        map.put(key, value);<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">lookup</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-comment">//获取存储在环境类中的值</span><br>        <span class="hljs-keyword">return</span> map.get(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.bilibili.com/video/BV1kW411P7KS">B站视频：C++ 设计模式 Design Patterns李建忠</a></li><li><a href="https://blog.csdn.net/LoveLion/article/details/79602149">刘伟：《Java 设计模式》</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UML</tag>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写给自己看的中文排版规范</title>
    <link href="/2020/12/26/%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/"/>
    <url>/2020/12/26/%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用 Markdown + Typora 写作的过程中，时常对一些排版上的细节感到困惑，特别是频繁出现的汉字与字母数字等西文混排的情形让我纠结不已。参考了网上的一些排版建议，再结合自己的审美和习惯最终总结了这个规范。希望借此规范，让自己在写作时有章可循，使文章的排版风格尽量统一。</p><p>Markdown 的初衷是为了把作者从复杂的排版中解放出来，但这并不意味着可以完全不顾文字的排版格式。统一的段落间隔、中西混排时的适当留白、标点符号的规范使用，处理好这些排版细节，可以让文章看起来更加整体连贯，没有割裂感。不仅提高读者的阅读体验，也是作者认真细心的表现。</p><p>再次提醒，本规范只是用来指导自己写博客，如果是论文写作或者刊物出版，请以文末参考链接中的国家标准和教育部指导草案为准。</p><h2 id="标题和段落"><a href="#标题和段落" class="headerlink" title="标题和段落"></a>标题和段落</h2><ol><li>标题层级数建议不超过四级，同时谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。</li></ol><ul><li>一级标题：文章的标题。</li><li>二级标题：文章主要部分的大标题。</li><li>三级标题：二级标题下面一级的小标题。</li><li>四级标题：三级标题下面某一方面的小标题。</li></ul><p>以 Markdown 语法为例。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><br><br><span class="hljs-section">## 二级标题</span><br><br><span class="hljs-section">### 三级标题</span><br><br><span class="hljs-section">#### 四级标题</span><br></code></pre></td></tr></table></figure><ol start="2"><li>一级标题下，不能直接出现三级标题。</li></ol><p>以 Markdown 语法为例：下面的文章结构，缺少二级标题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><br><br><span class="hljs-section">### 三级标题</span><br></code></pre></td></tr></table></figure><ol start="3"><li>文章的参考来源以二级标题形式放在文末，有多个参考链接应该使用有序列表，但是列表项的先后排序不代表参考的比例或者推荐程度。</li><li>不是用缩进来区分段落，而是使用空行将段落隔开。在 Typora 中使用回车换段会自动在段与段之间加入空行。</li><li>想在段落后插入图片，应使用软换行另起一行再粘贴图片，而不是直接在段落的最后粘贴图片。在 Typora 中，你可以通过 <code>Shift + Enter</code> 完成一次软换行。</li><li>插入大段的原文摘录应该使用 Markdown 的引用块格式。  </li><li>插入大段代码应该使用代码块格式，最好补充代码块的语言让代码能正确地显示高亮，代码块中的代码注释行可以省略结尾标点。</li><li>在行内插入代码语句、文件路径、终端命令、键盘按键应该使用 <code>ˋ</code> 半角重音号括起来以加区分。</li><li>在列表有很多条目时使用有序列表以计数，即使这些条目没有逻辑上的先后顺序。每个条目都应该有结尾标点。</li></ol><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><ol><li><p>英文字母和数字都使用半角的 ASCII 字符，空格使用半角空格。</p></li><li><p>在字母数字汉字三者混排的交界处要有间距，间距可能是空格字符也可以是全角标点。</p></li><li><p>全角中文字符与半角英文字符之间，应有一个半角空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：本文介绍如何快速启动Windows系统。<br><br>正确：本文介绍如何快速启动 Windows 系统。<br></code></pre></td></tr></table></figure></li><li><p>全角中文字符与半角阿拉伯数字之间，应有一个半角空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。<br><br>正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。<br></code></pre></td></tr></table></figure></li><li><p>半角英文字符和半角阿拉伯数字之间，应有一个半角空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：微软确认 Windows10 将是最后一代 Windows。<br><br>错误：微软确认 Windows 10 将是最后一代 Windows。<br></code></pre></td></tr></table></figure></li></ol><h2 id="数值与单位"><a href="#数值与单位" class="headerlink" title="数值与单位"></a>数值与单位</h2><ol><li><p>数值的运算符之间应该有空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：1+2=3<br><br>正确：1 + 2 = 3<br></code></pre></td></tr></table></figure></li><li><p>数字与单位之间应该有空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：我有一块 20TB 的硬盘，鬼知道我是怎么用完的。<br><br>正确：我有一块 20 TB 的硬盘，鬼知道我是怎么用完的。<br></code></pre></td></tr></table></figure></li><li><p>度的标志、百分号、货币标志、表正负数符号和数字之间不用添加空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：17 °, 100 %，$ 10, - 23，<br><br>正确：17°, 100%，$10, -23，<br></code></pre></td></tr></table></figure></li><li><p>数值为千位以上，建议添加千分号（半角逗号）。对于 4 位以下的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于 4 位以上的数值，千分号是必须的。</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs m">正确：实收资本为 ￥<span class="hljs-number">1</span>,<span class="hljs-number">258</span>,<span class="hljs-number">000</span> 人民币。<br></code></pre></td></tr></table></figure></li><li><p>表示数值范围时，用波浪号连接。带有单位或百分号时，两个数字建议都要加上单位或百分号。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：132～234kg、67～89%<br><br>正确：132kg～234kg、67%～89%<br></code></pre></td></tr></table></figure></li></ol><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><ol><li><p>正文是中文，原则上都应该使用中文全角标点，遵守中文标点的习惯用法。但是在中文句子内所夹用的英文句子或英文语段内部使用英文半角标点加空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：乔布斯说过：“Stay hungry，stay foolish。”<br><br>正确：乔布斯说过：“Stay hungry, stay foolish.”。<br></code></pre></td></tr></table></figure></li><li><p>中文句子内所夹用的英文句子或英文语段内部需要使用括号或者引号时，用英文半角标点标示。括号、引号前后加空格，中间内容无空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：Put coins or bills into the slots（the small slot for coins and the bigger one for bills）.<br><br>正确：Put coins or bills into the slots (the small slot for coins and the bigger one for bills).<br></code></pre></td></tr></table></figure></li><li><p>中文句子中夹用了英文词句，但并非处于完整的英文句子或英文语段内部时，用中文全角标点标示，括号、引号前后不需要空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：你就可以通过ATM(Automatic Teller Machine)存取款。<br><br>正确：你就可以通过ATM（Automatic Teller Machine）存取款。<br></code></pre></td></tr></table></figure></li><li><p>省略号使用占两个全角字符空间的下置省略号，实质上是两个并排的英文省略号而不是六个英文句点。通常中文输入法全角标点状态下的键入 <code>Shift + 6</code> 即可输入。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：中国设计还有太长路要走…<br>错误：中国设计还有太长路要走······<br><br>正确：中国设计还有太长路要走……<br></code></pre></td></tr></table></figure></li><li><p>破折号使用占两个全角字符空间的长横线，实质上是两个并排的英文破折号（TWO-EM DASH），少数字体在两个长横线之间会出现空隙。通常中文输入法全角标点状态下的键入 <code>Shift + -</code> 既可输入。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">错误：中国设计还有太长路要走⸺加油罢。<br>错误：中国设计还有太长路要走──加油罢。<br>错误：中国设计还有太长路要走--加油罢。<br><br>正确：中国设计还有太长路要走——加油罢。<br></code></pre></td></tr></table></figure></li><li><p>知乎上有很多人推荐使用直角引号，但个人还是更钟爱弯引号。弯引号的输入更加方便，使用场景更多。况且个人也没觉得直角引号比弯引号美观多少，反而觉得左右对称的弯引号更加清晰明了。</p></li><li><p>标点符号的重要性：标点符号除了停顿断句，还传达着语气、语调等具体的含义。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218637.png" alt="Image"></p></li><li><p>根据内容合理使用句号，避免当断不断，一路逗号走到底。<br>错误：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218638.png" alt="Image"><br>正确：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218639.png" alt="Image"></p></li><li><p>叹号叠用不应该超过三个。<br>错误：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218640.png" alt="Image"><br>正确：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218641.png" alt="Image"></p></li><li><p>同时包含疑问和感叹两种语气时，可以同时使用问号和叹号，但是注意问号居前，叹号居后。<br>错误：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218642.png" alt="Image"><br>正确：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218644.png" alt="Image"></p></li><li><p>书名号出现嵌套时双书名号和单书名号交替使用，双引号和单引号也是同理。<br>错误：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218645.png" alt="Image"><br>正确：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218646.png" alt="Image"></p></li><li><p>多个独立成段的引文，只在每段开头使用前引号，并且在最后一段结尾使用后引号。<br>错误：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218647.png" alt="Image"><br>正确：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218648.png" alt="Image"></p></li><li><p>标有引号或者书名号的并列词语分割已经非常清晰，不需要增加顿号进行分隔。<br>错误：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218649.png" alt="Image"><br>正确：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218650.png" alt="Image"></p></li><li><p>但如果有更多符号穿插其中，比如书名号之后有括注，就需要使用合适的符合进行连接和分隔。<br>错误：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218651.png" alt="Image"><br>正确：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218652.png" alt="Image"></p></li><li><p>点号不能出现在一行的开头，标号的前半部分不能出现在行尾，后半部分不能出现在行首，连接号间隔号也不能出现在行首，分隔号无论收尾都不能出现。可以通过将标点挤在上一行的尾部（推入），或者将上一行末尾的文字推到下一行的头部（推出）来避免。使用 Typora 会自动帮我们自动推出。<br>错误：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192218653.png" alt="Image"></p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/20506092">Hindy：写给大家看的中文排版指南</a></li><li><a href="https://www.bilibili.com/video/BV1AX4y1u7Ag">B 站视频：设计师与标点符号 -oooooohmygosh</a></li><li><a href="https://w3c.github.io/clreq/">W3C：中文排版需求 </a></li><li><a href="https://github.com/ruanyf/document-style-guide">阮一峰：中文技术文档的写作规范</a></li><li><a href="http://www.moe.gov.cn/ewebeditor/uploadfile/2015/01/13/20150113091548267.pdf">国家标准GB/T15834——2011《标点符号用法》</a></li><li><a href="http://www.moe.gov.cn/ewebeditor/uploadfile/2015/01/13/20150113092346124.pdf">教育部：夹用英文的中文文本的标点符号用法（草案）</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>说说</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>Typora</tag>
      
      <tag>排版</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Hexo 搭建个人博客</title>
    <link href="/2020/12/21/Hexo/"/>
    <url>/2020/12/21/Hexo/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><p>本文中将会使用到 Hexo 作为博客框架生成静态文件，GitHub Page 用来存储托管静态网页，Markdown 作为博客的写作语言，Typora 作为本地的 Markdown 编辑器，PicGo 作为图床上传工具。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156971.png" alt="Build-Bog-Sit-With-Markdown-Typora-GitHub"></p><h3 id="为什么要搭建个人博客"><a href="#为什么要搭建个人博客" class="headerlink" title="为什么要搭建个人博客"></a>为什么要搭建个人博客</h3><ul><li>创作教程向的博客是对费曼学习法的很好实践，在输出知识的过程中帮自己很好地梳理知识并查漏补缺，从而真正掌握它。</li><li>将学习所得总结成博客，给自己一个积极的成果反馈，增加学习的快感。</li><li>将本地博客上传到网络可以随时随地通过浏览器访问，相比云笔记软件，博客更加开放正式，给人以仪式感，也能让执键盘者能认真对待。</li><li>有一个个人专属的空间可以写一些东西，或是记录自己的学习心得体会，或是写一些碎碎念输出自己的观点，面对匿名访客不会像空间和朋友圈一样有心理负担。</li><li>发扬互联网分享的精神，向互联网分享自己的经验，有可能会帮助到他人。</li><li>搭建自己的博客站点相比使用平台提供的博客托管服务，自主性更高，可以随意定制，大胆折腾，可玩性更高。</li><li>可以绑定自己的专属域名，逼格更高。</li><li>在搭建博客的过程学习顺带网站的构建部署以及一些前端知识。</li><li>高质量的博客可以给简历加分。</li></ul><h3 id="为什么是-Hexo"><a href="#为什么是-Hexo" class="headerlink" title="为什么是 Hexo"></a>为什么是 Hexo</h3><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 </p></blockquote><p>以上是 Hexo 的<a href="https://hexo.io/zh-cn/docs/">官方中文文档</a>中的介绍，由于此前并没有任何使用其他博客框架的经历，所以也说不出相对 WordPress、Hugo 等其他框架的优缺点。之所以使用 Hexo 完全是因为网上的安利以及教程很多，所以也就跟风选择了 Hexo。</p><h3 id="为什么是-Markdown"><a href="#为什么是-Markdown" class="headerlink" title="为什么是 Markdown"></a>为什么是 Markdown</h3><p>Markdown 是一种轻量级的标记语言，使用 Markdown 写作可以让创作者专注于文字内容本身而不用过多的关心排版。Markdown 格式的文档介于纯文本和富文本之间，相比无格式的纯文本，Markdown 可以渲染出样式辅助表达必要的排版逻辑让文章结构美观清晰，相比富文本例如 Word 文档，不用在文字输入和复杂的排版之间来回切换，沉浸感更强。而相比其他的标记语言例如 HTML，Markdown 语法更加简单，容易上手，使用起来也更加灵活方便。此外 Markdown 还有以下优点：</p><ul><li>越来越多的互联网创作平台如「知乎」、「简书」都提供了对 Markdown 格式的支持，在各个平台都能有相对统一的渲染效果。</li><li>使用的是纯文本格式存储，可以使用任何文本编辑器打开和编辑。</li><li>必要时可以很方便的导出成 HTML 、Word 和 PDF 文档。</li></ul><p>花几十分钟学习一下简书官方的 Markdown 教程：<a href="https://www.jianshu.com/p/q81RER">献给写作者的 Markdown 新手指南</a>，利用简书的在线 Markdown 编辑器体验几种常用的标记语法，熟练后就足以应付绝大多数 Markdown 应用场景。</p><h3 id="为什么是-Typora"><a href="#为什么是-Typora" class="headerlink" title="为什么是 Typora"></a>为什么是 Typora</h3><p>上面提到任何文本编辑器都可以打开和编辑 Markdown 文档，普通文本编辑器虽然能显示 Markdown 文本和编辑，但是却无法渲染出我们想要的格式，所以还是很有必要选择一款专用的 Markdown 的编辑器。而 Typora 就是一款为 Markdown 而生的编辑器。它有以下优点：</p><ul><li>支持 Markdown  即时渲染，不用分屏预览，所见即所得。</li><li>功能强大，对 Markdown 所有的语法都支持，虽然有很多复杂语法可能以后永远都用不上。</li><li>软件颜值很高，自带 6 个主题，官网还有更多主题可供选择。</li><li>即使不熟悉一些 Markdown 语法也能使用菜单或者快捷键来添加格式。</li><li><a href="http://support.typora.io/Markdown-Reference/">最大可能的</a>遵循 <a href="https://github.github.com/gfm/">GitHub Flavored Markdown</a> 的渲染标准，此标准在原有 Markdown 语法的基础上添加了少量新特性使用起来对程序员更加友好，并且这些特性在 GItHub 的页面上都能完美的显示，所以用 Typora 来写项目的 Readme.md 文档会很合适。</li><li>有复杂排版需求时可以直接嵌入 HTML 代码到 Markdown 文件中，也能渲染显示出来。</li><li>通过开发者选项可以自定义 CSS，深度修改定制属于自己的渲染样式。</li><li>最新版支持 PicGo 插件，可以一键调用 PicGo 自动上传图片到图床。</li></ul><h2 id="Hexo-的安装和配置"><a href="#Hexo-的安装和配置" class="headerlink" title="Hexo 的安装和配置"></a>Hexo 的安装和配置</h2><h3 id="Hexo-的安装"><a href="#Hexo-的安装" class="headerlink" title="Hexo 的安装"></a>Hexo 的安装</h3><blockquote><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul></blockquote><p>Node.js 的安装只需到官网下载安装包一路下一步即可，安装后建议把 npm 的镜像源切换到国内，能极大提高 npm 包的下载安装速度。</p><p>Git 安装和配置可以参考我这篇博客：<a href="https://kiku.vip/2020/11/23/Git/">Git 和 GitHub 学习笔记</a>。</p><p>确保成功安装并配置号以上两款软件后，在适当位置创建一个空的文件夹作为自己的 Hexo 博客项目的工作目录。</p><p>在该目录下打开终端，使用 cmd 或者 git bash 作为 shell 均可。</p><p>在终端中输入以下命令运行来安装 Hexo 命令行工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli <br></code></pre></td></tr></table></figure><p>如果中途出现终端长时间无响应的情况请检查网络状况或使用管理员模式打开终端再次尝试上面命令安装。</p><p>安装成功后不要退出终端，也不要切换路径，继续输入以下命令并运行，在当前目录下初始化一个 Hexo 博客项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init <br></code></pre></td></tr></table></figure><p>初始化过程因为要克隆远程 GitHub 仓库，可能出现以下错误。请确保自己的网络能正常访问 GitHub，必要时手动修改 <code>hosts</code> 文件或者使用网络代理。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156972.png" alt="image-20201206220507356"></p><p>初始化完毕后依次运行下面三条命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#生成名为 my first blog 的文章</span><br>hexo new <span class="hljs-string">&quot;my first blog&quot;</span><br><br><span class="hljs-comment">#根据 Markdown 文档生成博客静态文件，可以简写成 hexo g</span><br>hexo generate<br><br><span class="hljs-comment">#在本地启动一个 http 服务器，默认情况下，访问网址为： http://localhost:4000/</span><br>hexo server<br></code></pre></td></tr></table></figure><p>如果上面三条命令运行成功，接下来可以打开浏览器访问 <code>http://localhost:4000/</code> 来预览自己的博客页面了。终端可能会弹出一些警告，不用理会它，可以在终端使用 <code>Ctrl + C</code> 手动结束掉 Hexo 的服务器模块。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156973.png" alt="image-20201207110718539"></p><h3 id="部署到-GitHub-Pages"><a href="#部署到-GitHub-Pages" class="headerlink" title="部署到 GitHub Pages"></a>部署到 GitHub Pages</h3><p>以上我们使用 Hexo 框架搭建了一个本地博客站点，不过只有在自己计算机的所在局域网才能访问到这些页面。接下来我们要把博客部署到 GitHub Pages 上。<a href="https://pages.github.com/">GitHub Pages</a> 是 GitHub 官方提供的静态页面托管服务，我们可以通过 GitHub Pages 直接预览我们仓库中的一些静态网页。</p><p>首先我们需要在 GitHub 上创建一个空的公开的仓库，仓库名要严格符合格式：<code>username.github.io</code>，username 换成自己的 GitHub 用户名，请注意区分用户名和昵称的区别。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156974.png" alt="image-20201206224101092"></p><p>创建完仓库后我们要修改 Hexo 的配置文件来将远程的 GitHub 仓库绑定到我们本地的 Hexo 项目。</p><p>Hexo 项目的根目录下有一个名为 <code>_config.yml</code> 的配置文件，里面是我们的博客站点各种配置。</p><p>打开配置文件，在最后面填上部署方式和我们的刚才创建的仓库 地址以及分支名。</p><p><strong>注意：YAML 格式的键值对在英文冒号后面一定要有一个空格，否则 YAML 将不能正常被解析。并且 YAML 依靠缩进来确定元素间的从属关系。请确保缩进长度相同，并且使用空格缩进。</strong> </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Kiku-CN/Kiku-CN.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>部署方式填 git，仓库地址更改成自己的仓库地址，进入我们刚才创建的仓库页面即可看到地址。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156975.png" alt="image-20201206225221557"></p><p>仓库地址使用 HTTPS 或者 SSH 都可以，使用 HTTPS 需要在第一次部署时输入账号密码，使用 SSH 方式不需要输入账号密码但需要提前绑定自己的 SSH 公钥到 GitHub 上面。有关 SSH 公钥的配置请参考：<a href="https://kiku.vip/2020/11/23/Git/#%E4%BD%BF%E7%94%A8-SSH-%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">使用 SSH 连接到远程仓库</a>。</p><p>改好配置文件后，安装 Hexo 的 Git 自动部署插件。终端中输入以下命令并运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git <br></code></pre></td></tr></table></figure><p>使用插件可以利用部署命令一键将本地静态页面推送到远端的 GitHub 仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将本地页面部署到远端仓库，命令可以缩写成 hexo d</span><br>hexo deploy<br></code></pre></td></tr></table></figure><blockquote><p>当执行 <code>hexo deploy</code> 时，Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容。</p></blockquote><p>提示部署成功后就可以通过 Github Pages 来访问自己博客了。访问的域名为：<code>username.github.io</code>。也就是我们之前创建的仓库名。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156976.png" alt="image-20201207110635474"></p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>将自己的域名和 GitHub Pages 绑定起来，这样就可以通过自己的个性化域名来访问博客。没有域名的同学可以跳过这步。</p><p>首先我们需要到域名服务商购买一个自己喜欢的域名，然后进入服务商的域名管理界面。以 <a href="https://www.namesilo.com/account_domains.php">namesilo</a> 为例，管理入口在右上方。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156977.png" alt="image-20201207114936735"></p><p>进入管理界面后删除原有所有的解析记录，然后添加一条 CNAME 记录指向自己的 GItHub Pages，再添几条 A 记录直接解析到自己的 GItHub Pages 的 IP 地址。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156979.png" alt="image-20201207115444824"></p><p>可以通过 Windows 自带的 <code>nslookup</code> 命令获取自己的 GitHub Pages 对应的 IP 地址。每个人对应的 IP 地址可能不一样。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156980.png" alt="image-20201207115755102"></p><p>绑定好解析记录后进入之前创建的名为  <code>user.name.io</code> GitHub 仓库的设置界面，请注意是仓库的设置界面，不是 GitHub 账号的设置界面。</p><p>在后面找到 GitHub Pages 设置项，填上注册的域名然后保存。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156981.png" alt="image-20201207120715984"></p><p>这样就可以通过自己的域名来访问博客页面了。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156982.png" alt="image-20201207123215633"></p><p><strong>注意：在域名服务商页面修改 DNS 解析记录需要一段时间才能生效，如果通过自己的域名不能访问到博客页面，在检查上面几步操作无误的前提下耐心等待 DNS 记录生效就好。</strong></p><p>回到仓库页面可以发现，刚才 GitHub 自动为我们在仓库下创建了一个名文 <code>CNAME</code> 文件，里面是我们刚才绑定的域名。我们到设置页面绑定域名的实质只是让 GitHub 帮我们自动生成了一个域名映射文件。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156983.png" alt="image-20201207121209374"></p><p>但是注意一点，这个文件是 GitHub 自动帮我们生成的，我们本地的仓库中是没有这个 <code>CNAME</code>  文件。如果我们将 Hexo 博客重新部署一遍过后，GitHub 仓库里的这个 <code>CNAME</code> 文件就会被同步而消失掉，又需要进入仓库设置页重新配置域名。</p><p>为了能让每次部署都能自动绑定自定义域名，我们需要创建一个名为 <code>CNAME</code> 的文本文件置于 Hexo 项目的  <code>source</code> 目录下，只有这样 <code>hexo deploy</code> 时才能将 <code>CNAME</code> 文件一并推送至远程 GitHub 仓库。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156984.png" alt="image-20201207122251487"></p><p><strong>注意：<code>CNAME</code> 是一个纯文本文件，要和 GitHub 帮我们自动生成 <code>CNAME</code> 完全一致：文件名中不能带有任何后缀，文件内容为自己的域名，一定要放在 Hexo 项目的 <code>source</code> 目录下。</strong></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156985.png" alt="image-20201207122719739"></p><h3 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h3><p>到 Hexo 的<a href="https://hexo.io/themes/">主题页</a>选取自己喜欢的主题，我们以 <a href="https://github.com/Fluid-dev/hexo-theme-Fluid.git">Fluid</a> 主题为例进行下面的操作。</p><p>使用 <code>git</code> 命令克隆主题文件到自己的 Hexo 项目下的 <code>themes</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/Fluid-dev/hexo-theme-Fluid.git themes/Fluid<br></code></pre></td></tr></table></figure><p>clone 结束后进入 <code>themes</code> 目录，除了 Hexo 自带的默认主题 landscape 外，应该还有一个名为 <code>Fluid</code> 的主题文件夹。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156986.png" alt="image-20201207124547245"></p><p>打开站点目录下的 <code>_config.yml</code> 配置文件，修改主题为 Fluid，<strong>注意：是 Hexo 项目目录下的 <code>_config.yml</code> 配置文件，而不是 <code>themes</code> 里面的主题配置文件。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><p>修改后保存配置，使用以下命令重新生成并部署博客。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#生成静态文件并立即部署网站，相当于依次运行 hexo generate，hexo deploy</span><br>hexo g -d<br></code></pre></td></tr></table></figure><p>等待部署完毕后就可以看到更换主题后的效果了。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156987.png" alt="image-20201207130311895"></p><p><strong>注意：如果发现自己对站点的更改无论如何也不生效（尤其是更换主题后），尝试运行下面的命令再重新生成部署。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#清除 Hexo 项目的缓存文件和已生成的静态文件 </span><br>hexo clean<br></code></pre></td></tr></table></figure><h3 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h3><p>在 Hexo 项目的根目录下的 <code>_config.yml</code> 文件中可以修改有关博客站点的配置。下面对常用的配置项进行说明，更详细的配置请参考 Hexo 官方文档中的<a href="https://hexo.io/zh-cn/docs/configuration">配置部分</a>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">Hexo</span> <span class="hljs-comment">#网站的标题</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">#网站的副标题，可以为空</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">#网站的简单描述，主要用于SEO</span><br><span class="hljs-attr">keywords:</span><span class="hljs-comment">#网站的关键词，主要用于SEO</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">Kiku</span>  <span class="hljs-comment">#网站作者，用于主题显示文章的作者</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><span class="hljs-comment">#网站使用的语言，建议改成简体中文。</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">#网站时区。Hexo 默认使用您电脑的时区。不用修改</span><br></code></pre></td></tr></table></figure><p><strong>注意：语言的配置需要和自己使用的主题文件夹中提供的一致， 不同的主题可能需要设置成不同的值，常见的有 zh-Hans 和 zh-CN。以 Fluid 主题为例，进入主题的 <code>language</code> 文件夹，里面提供了四种语言支持，中文对应的是 <code>zh-CN.yml</code>。</strong></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156988.png" alt="image-20201207132511808"></p><p>下图是 Fluid 主题的导航栏在<code>language: en</code> 和 <code>language: zh-CN</code> 下的效果示例。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156989.png" alt="image-20201207133720184"></p><h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><p>在调试博客样式的过程中，每次修改都部署到远程仓库是很不必要的。一是这样每次部署到远程需要等待上传文件更新完成，再查看修改后的效果，效率很低；二是这样会在 GitHub 上增加了很多无意义的 commit 记录，污染了时间线。</p><p>所以应该多多利用 Hexo 提供的本地服务器功能，在本地调试博客，等修改满意后再部署到 GitHub 仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#启动服务器。默认情况下，访问网址为：http://localhost:4000/</span><br>hexo server<br></code></pre></td></tr></table></figure><p><strong>注意：Hexo 服务器模块会监视文件变动并自动更新，这样不用每次改动都重新生成部署才能预览改动后的效果。但是如果是修改了 Hexo 项目或者主题的配置文件，可能需要先使用 <code>hexo g</code> 重新生成静态文件才能看到更新后的效果。</strong></p><h2 id="配置-Fluid-主题"><a href="#配置-Fluid-主题" class="headerlink" title="配置 Fluid 主题"></a>配置 Fluid 主题</h2><p>Fluid 官方提供了十分详实的<a href="https://hexo.fluid-dev.com/docs/">中文配置文档</a>，直接阅读官方文档，按需修改配置即可。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="将-Markdown-文章发布到博客"><a href="#将-Markdown-文章发布到博客" class="headerlink" title="将 Markdown 文章发布到博客"></a>将 Markdown 文章发布到博客</h3><p>将在其他位置编辑好的 Markdown 文档直接复制到 Hexo 项目下的 <code>source/_posts</code> 目录下，这样在使用 <code>hexo g</code> 命令时这篇文档就会被解析生成一篇文章页。</p><p>也可以使用以下命令，或者手动在  <code>source/_posts</code>  目录下新建一个 Markdown 文档用来写作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#可以在命令中指定文章的布局（layout），默认为 post，title 是文档的名称</span><br>hexo new [layout] &lt;title&gt; <br></code></pre></td></tr></table></figure><p><strong>注意：Markdown 文档的文件名一定不能以空格结尾，例如 <code>README .md</code>，在解析时一篇 Markdown 文档会生成一个文件夹，而文件名末的空格会被带到文件夹中，而在 Windows 中文件夹末尾是不允许有空格的，这将导致该文件夹将无法被访问，也就无法被提交到远程 Git 仓库</strong></p><h3 id="使用-Front-matter-为文章指定属性"><a href="#使用-Front-matter-为文章指定属性" class="headerlink" title="使用 Front-matter 为文章指定属性"></a>使用 Front-matter 为文章指定属性</h3><p>Front-matter 是 Markdown 文档文件最上方以 <code>---</code> 分隔的区域，用于指定这篇文章的一些属性，优先级最大，也就说这些变量的值会覆盖掉 Fluid 的主题配置和 Hexo 的项目配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">layout:</span> <span class="hljs-comment">#指定 Markdown 文档的渲染模板，默认是 post，会渲染成博客文章页，指定false则是不使用主题，直接解析 Markdown 文档生成网页。不同的主题的提供一些额外的布局模板，例如 Fluid 提供了 index，page，archive，category，about 这些模板。但是这些模板很少有机会手动指定，使用最多的就是 post，用来生成一篇文章</span><br><span class="hljs-attr">title:</span><span class="hljs-comment">#文章主标题，默认 Markdown 文档的文件名</span><br><span class="hljs-attr">author:</span>  <span class="hljs-comment">#文章作者</span><br><span class="hljs-attr">date:</span> <span class="hljs-comment">#文章发布日期，时间日期格式：2019-10-10 10:00:00，默认为 Markdown 文档的创建日期</span><br><span class="hljs-attr">updated:</span><span class="hljs-comment">#文章更新日期，时间日期格式：2019-10-10 10:00:00，默认为 Markdown 文档的修改日期</span><br><span class="hljs-attr">comment:</span>  <span class="hljs-comment">#开启文章的评论功能，默认值为 true，前提是已经在主题配置中已经配置好评论模块的参数，否则不显示</span><br><span class="hljs-attr">tags:</span> <span class="hljs-comment">#给文章添加标签</span><br><span class="hljs-attr">categories:</span> <span class="hljs-comment">#指定文章所属分类</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-comment">#指定摘要，也可以在 Markdown 文档使用 &lt;!-- more --&gt; 来划分摘要区域，不指定则默认自动选取摘要。优先级: excerpt 摘要 &gt; Markdown 划分摘要 &gt; 自动摘要</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-comment">#指定 Markdown 文档解析后生成的路径，默认按照文章年月日来生成路径</span><br></code></pre></td></tr></table></figure><p><strong>注意：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。分类类似文件夹的组织方式，标签则使用起来更加灵活。</strong></p><blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories:<br><span class="hljs-bullet">  -</span> Diary<br><span class="hljs-bullet">  -</span> Life<br></code></pre></td></tr></table></figure><p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">categories:<br><span class="hljs-bullet">- </span>[Diary, PlayStation]<br><span class="hljs-bullet">- </span>[Diary, Games]<br><span class="hljs-bullet">- </span>[Life]<br></code></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p></blockquote><p>接下来这些属性均是在使用 Fluid 主题的前提下，使用其他主题不保证能产生相同效果。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">subtitle:</span> <span class="hljs-comment">#子标题，默认值等于 title，更好的理解是详细标题，进入文章页后显示的是子标题而不是标题</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-comment">#文章在首页的封面图，如果没在主题配置中设置默认封面，则默认不显示文章封面</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-comment">#文章页顶部大图，默认使用主题配置的图片</span><br><span class="hljs-attr">hide:</span><span class="hljs-comment">#把某些文章隐藏起来，会使文章在首页和分类里都不显示，隐藏后依然可以通过文章链接访问,默认值为 false</span><br><span class="hljs-attr">sticky:</span>  <span class="hljs-comment">#为文章设置权重，可以用来给首页文章排序。数值越大，则权重越高，该文章在首页越靠前，默认值为0，设定正数来置顶文章，置顶文章标题会带有一个置顶图标，设为负数保证置尾</span><br></code></pre></td></tr></table></figure><p>下面给出我们经常会用到的 Front-matter 属性，可以当做模板使用。</p><p><strong>注意：使用 Fluid 主题不指定 title 属性会使文章的标题为空。如果想使用自动摘要，就不要添加 excerpt  这个属性，添加了这个属性必须指定一串字符值，否则解析时会报错。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-comment">#标题</span><br><span class="hljs-attr">date:</span>  <span class="hljs-comment">#日期</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-comment">#摘要</span><br><span class="hljs-attr">tags:</span> <span class="hljs-comment">#标签</span><br><span class="hljs-attr">categories:</span><span class="hljs-comment">#分类</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-comment">#封面</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-comment">#顶图</span><br></code></pre></td></tr></table></figure><h2 id="为-Typora-配置图床"><a href="#为-Typora-配置图床" class="headerlink" title="为 Typora 配置图床"></a>为 Typora 配置图床</h2><p>如果在上面发布的 Markdown 文档里面引用了本地图片，会发现文章页中的图片没有正常显示。因为 Markdown 文档本质上还是一个纯文本，它只是引用了本地或者网络上的图片，而我们在 Markdown 中插入的本地图片并没有一同随文档上传到 GitHub 仓库。所以我们需要把图片也上传到网络（图床）上，这样才能在博客中正常显示。</p><p>如果只是简单地把图片和 Markdown 文档一同放在了 <code>_post</code> 目录下，并不能上传图片，因为 Hexo 默认是不会处理 <code>_post</code> 目录下的图片的。</p><p>现在为了让 Hexo 把图片也一起上传到远程 GitHub 仓库，我们有两种选择，一是修改 Hexo 的配置文件中 <code>post_asset_folder</code> 属性，这样 Hexo 在生成静态文件时会把和 Markdown 文档同名的文件夹里面的内容也一起复制到 <code>public</code> 目录，并在部署时一同上传。</p><p>这种上传图片的方式可以参考 Hexo 官方文档中的 <a href="https://hexo.io/zh-cn/docs/asset-folders#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%BC%95%E7%94%A8%E7%9A%84%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6">资源文件夹说明</a>，网上也已经有很多教程，但是这个方法有个问题就是使用 Typora 粘贴剪切板中的图片时生成的路径会多出一个 <code>/</code> 造成路径错误。</p><p>接下来分享的是另外两种配置图床方式。以下两种方法均使用 Typora 作为 Markdown 编辑器，所以请提前到 <a href="https://typora.io/">Typora官网</a> 安装或升级到最新版本，旧版本可能不支持 PicGo 上传图片功能。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><p>在 <code>source</code> 目录下创建一个名为 <code>images</code> 的文件夹专门用于存放图片，Hexo 生成文件时不会处理 <code>_post</code> 下的图片，但是会把 <code>source/images</code> 这个文件夹复制到 <code>public/images</code> ，即部署后的站点根目录下，到时候可以通过绝对路径很方便的获取到 images 里面的图片。</p><p>首先修改 Typora 里面的图像设置如下图。这样当我们在 <code>_post</code> 目录下使用 Typora 进行 Markdown 写作时，插入的图片时会自动拷贝复制一份到<code>../images</code>，也就是我们之前创建的目录下。</p><p><strong>注意：一定要使用相对路径。此外建议网络和本地都勾上，这样即使引用的网络图片被删除或者原来的本地图片被被移动的情况下图片引用都不会失效。</strong></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156990.png" alt="Image"></p><p>但是还有另外一个问题需要解决。在 <code>_post</code> 目录下的 Markdown 文档解析后的生成的 HTML 页面并不在 <code>public/post/</code> 这个目录下（事实上也不存这个目录），而是在以日期命名的路径下面。例如在 <code>_post</code> 目录下有一篇名为 <code>title.md</code> 的 Markdown 文档，其日期属性为 <code>date: 2020-12-3 </code> ，部署后需要通过 <code>主机名/2020/12/03/title/index.html</code> 这个路径才能访问对应的文章页面。</p><p>这时如果我们在这个文档中粘贴一张图片，Typora 自动生成的图片引用为 <code>![](../images/example.jpg)</code>，图片经过解析后生成的 HTML 标签为  <code>&lt;img src=&quot;../images/example.jpg&quot; &gt;</code>，转化为绝对地址就是 <code>&lt;img src=&quot;主机名/2020/12/images/example.jpg&quot; &gt;</code>，然而图片在网络上的所在地址是 <code>主机名/images/example.jpg</code>，所以图片没法正确的加载显示出来。</p><p>我们可以选择更改 Hexo 生成文章时的默认路径，让文章直接在部署到站点根目录下面的某一个文件夹下，而不经过年月日的层叠。</p><p>但我们使用的是另外一种方法：Typora 专门提供了一项<a href="https://support.typora.io/Images/#relative-path-to-certain-folder">设置</a>可以解决这个问题：在 Front-matter 给文档添加如下的 <code>typora-root-url</code> 属性。</p><p><strong>再次提醒：英文冒号后面一定要有空格！</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">typora-root-<span class="hljs-attr">url:</span> ../<br></code></pre></td></tr></table></figure><p>新版 Typora 已经支持直接在菜单中设置图片根目录了，将  <code>_post</code> 目录的上一层 <code>source</code> 目录设为根目录。 Typora 会自动添加一条和上面一样的 YAML Front Matter 属性。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156991.png" alt="Image"></p><p>指定了图片根目录后 Typora 解析图片的相对路径时就会自动添加设置的这段路径。这时粘贴图片到文章中时，图片还是会拷贝到 <code>source/images</code> 下面，但是所生成的 Markdown 引用为 <code>![](/images/example.jpg)</code>，解析成 HTML 图片标签的 src 值为 <code>/images/example.jpg</code> ，正好可以匹配到站点根目录下的 images 路径下的图片。</p><p>优点：</p><ul><li>不用单独搭建图床仓库，也不用手动上传图片，直接把图片和 Markdown 文档一同部署到网络。</li><li>直接在 <code>_post</code> 目录下创作，修改后保存重新生成部署即可生效。</li></ul><p>缺点：</p><ul><li>每篇 Markdown 文档都需要指定根目录属性，虽然可以利用 Hexo 的<a href="https://hexo.io/zh-cn/docs/writing#%E6%A8%A1%E7%89%88%EF%BC%88Scaffold%EF%BC%89">模版</a>功能来解决，但是这样每次都必须通过命令行来创建新的 Markdown 文章。</li><li>所有文章的图片都集中在一个文件夹，后期不好管理。</li><li>图片和文章都在一个仓库中存储，有可能造成后期空间紧张。</li><li>GitHub 在国内访问不是很稳定，造成图片加载很慢甚至加载不出来。</li></ul><p>方法 1 适合那些直接在 <code>_post</code> 目录下写博客的人群，而下面的方法 2 则适合那些以前就使用过 Typora，已经习惯在某个文件夹下创作的人群。</p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2:"></a>方法 2:</h3><p>首先在 GitHub 创建一个新的空仓库用作图床，仓库名可以任意。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156992.png" alt="image-20201207212601641"></p><p>创建一个新的分支用来存储图片，而不是直接使用默认分支，这样做有两点好处。一是上传照片到非默认分支可以避免被 GitHub 统计成 contribution，不会点亮主页的小绿点。二是在前期测试图床的过程中如果上传了一些测试图片可以方便利用删除分支功能来删除这些图片，而不是删除整个仓库再重新建新仓库。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156993.png" alt="image-20201207212954936"></p><p>安装 <a href="https://picgo.github.io/PicGo-Doc/">PicGo</a>，建议直接安装最新的 beta 版本，旧版本容易出现各种端口冲突。</p><p>然后配置 PicGo 的 GitHub 参数。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156994.png" alt="image-20201209201444082"></p><p>仓库名和分支名使用上面自己创建的仓库和分支。<strong>注意：仓库名前要加上自己的 GitHub 账户名称。</strong></p><p>在 Github 的账号设置页右侧找到 Developer settings 进入，生成一个新的 token。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156995.png" alt="image-20201209201757662"></p><p>Note 相当于给这个 token 取个名字，用来以后提示自己当初创建这个 token 的用途。权限范围只用勾上 repo 即可，token 生成后务必立即复制粘贴到 PicGo 的设置中来，页面关闭后将不可见，没复制上就只能选择再新建一个 token。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156996.png" alt="image-20201209201949295"></p><p>指定存储路径可以随意，建议还是指定个一级目录例如 <code>photos/</code> 或者 <code>imgs/</code>，避免图片直接暴露在仓库最外面。</p><p>存储路径务必按照以下路径来填写，这样可以使用 jsdelivr 免费的 CDN 加快图片加载速度。其中 <code>user</code> 换成自己的 GitHub 名称， <code>repo</code> 换成自己的图床仓库名，<code>branch</code> 换成自己设定的分支名。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/u</span>ser/repo@branch<br></code></pre></td></tr></table></figure><p>PicGo 配置完毕后回到 Typora 中的图像设置中来，还是选择方法 1 中一样的复制到指定路径的选项，不同的是这次我们把路径指定为<code>./$&#123;filename&#125; images</code>，即插入图片时在当前目录新建一个文件夹专门用来保存某一篇 Markdown 中的图片。上传服务选择 PicGo（app），并关联到自己的 PicGo 安装路径，然后点击验证图片上传选项看上传是否成功。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156997.png" alt="image-20201210223806429"></p><p>Typora 支持在插入图片时就通过 PicGo 自动上传图片。但是使用 PicGo 上传到 GitHub 不是很稳定，容易出现各种上传失败。所以建议还是先把图片老老实实保存到本地，最后再集中上传。这样即使上传出错，直接全部重传就好。上传失败时多利用 PicGo 的日志来查找失败原因。</p><p><strong>注意：一定要在 PicGo 的设置中开启时间戳重命名，确保上传的图片名称不会和之前上传的图片产生冲突。</strong></p><p>建议在本地创建一个文件夹专门用来 Markdown 写作，引用图片生成图片文件夹也在此文件夹中，等某篇 Markdown 完成无需修改再将 Markdown 文档和对应的图片文件夹复制一份到 Hexo 下的 <code>source/_post/</code> 目录里面，然后按照下图的方式集中上传整篇文档的图片到图床。</p><p><strong>注意：一定要把图片文件夹也一起复制过来，因为我们前面设置的是相对路径，上传成功后图片文件夹可以删掉 。</strong></p><p><strong>注意：一次上传完所有图片后 Typora 会自动把 Markdown 文档中原来的本地图片引用地址替换成我们在 PicGo 中配置的 HTTPS 地址，记得先 <code>Ctrl + s</code> 保存修改后的 Markdown 文档再使用 Hexo 命令生成和部署。</strong></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156998.png" alt="image-20201203220016120"></p><p>这样相当于存在两个版本，一个是引用本地图片的离线版本可以用作存档，一个是引用 GitHub 图床的在线版部用来解析生成博客，实现存档和部署的文件相互分离，以后如果要迁移起来也方便。</p><p>优点：</p><ul><li>不用改变以前使用 Typora 的习惯，只需要将想上传的 Markdown 拷贝到 <code>_post</code> 文件夹然后在 Typora 中一次性上传所有本地图片。</li><li>图床仓库和博客仓库隔离，图片不会挤占博客仓库空间。</li><li>本地版中的图片按篇组织在一个个文件夹，易于检查和整理。</li><li>可以配合 jsDelivr 实现免费的 CDN 加速，加快图片的加载速度，图片也不容易被墙。</li></ul><p>缺点：</p><ul><li>需要单独搭建配置图床。</li><li>本地离线版和在线版两个版本管理起来容易混乱，特别是后期有修改需要同步时。</li><li>PicGo 用起来不是很稳定，但是目前也没有找到更好的替代工具。</li><li>两个版本多了一份重复文件，多占一丢丢几乎可忽略的硬盘空间。</li></ul><p>很多人担心 GitHub 的仓库容量用来图床会不会够用，GitHub 官方关单个仓库容量的<a href="https://docs.github.com/cn/free-pro-team@latest/github/managing-large-files/what-is-my-disk-quota">说法</a>是：理想情况下小于 1 GB，强烈建议小于 5 GB。只是用来存储文章插图是够用的。</p><p>如果是打算上传各种高清大图，或者要上传音频甚至视频的，可以考虑七牛云的对象存储服务，上传身份证照片实名认证后有 10 GB 的免费空间，每月 10 GB 的免费流量。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156999.png" alt="image-20201203162217404"></p><p><strong>注意：一定要备过案的域名能使用免费的 CND 加速，没备案的不能使用自定义域名加速。CND 加速效果相比 jsDelivr 并没有感觉到什么差距，可能和自己的网络环境有关。</strong></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192156000.png" alt="image-20201203161953280"></p><p>至此完成了博客最基础的文章和图片展示功能的搭建，Hexo 还有更多高阶玩法，例如添加文章评论系统，嵌入音乐播放器，自定义主题模板等。建议把博客搭起来后，先把文章写起来，内容才是核心，花里胡哨可以等日后有空可以再慢慢折腾。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/26625249">吴润：GitHub+Hexo 搭建个人网站详细教程</a></li><li><a href="https://me.miqilin21.cn/2020/09/28/%E4%BD%BF%E7%94%A8GitHub%E3%80%81jsDelivr%E3%80%81PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%BF%AB%E9%80%9F%E5%9B%BE%E5%BA%8A/">米淇淋：使用GitHub+jsDelivr+PicGo搭建免费快速图床</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Git</tag>
      
      <tag>Markdown</tag>
      
      <tag>Typora</tag>
      
      <tag>PicGo</tag>
      
      <tag>GitHub</tag>
      
      <tag>网络</tag>
      
      <tag>CDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UML 中的类图</title>
    <link href="/2020/12/19/UMLClassDiagram/"/>
    <url>/2020/12/19/UMLClassDiagram/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>类（Class）封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。类实例化成对象（Object），对象对应于某个具体的事物，是类的实例（Instance）。</p><p>在系统中，每个类都具有一定的职责，职责指的是类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计得好的类通常有且仅有一种职责。在定义类的时候，将类的职责分解成为类的属性和操作（即方法）：类的属性即类的数据职责，类的操作即类的行为职责。</p><p>类图（Class Diagram）使用出现在系统中的不同类来描述系统的静态结构，它用来描述不同的类以及它们之间的关系。</p><p>在 UML 类图中，类一般由三部分组成：</p><ol><li>第一部分是类名：每个类都必须有一个名字，类名是一个字符串。<br>按照 Java 语言的命名规范，类名中每一个单词的首字母均大写。 </li><li>第二部分是类的属性（Attribute）：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。<br>按照 Java 语言的命名规范，属性名中的第一个单词全小写，之后每个单词首字母大写（驼峰命名法）。<br>Java 中成员变量更准确的术语是 variable，又可以根据是否有 static 修饰符分为实例成员变量是（ field，字段）和类成员变量是 （static field，类字段）。 Java 没有 attribute 这个术语，而是使用 property（属性） 特指那些通过 getter 和 setter 方法可以设置的属性。<br>格式：[可见性] 名称:类型 [ = 默认值 ]<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216662.png" alt="image-20201217183458640"></li><li>第三部分是类的操作（Operation）：操作是类的任意一个实例对象都拥有的行为，是类的成员方法。<br>按照 Java 语言的命名规范，方法名中的第一个单词全小写，之后每个单词首字母大写。<br>Java 中成员方法更准确的术语是 method，又可以再细分为实例方法（instance method）和类方法（class method），除非用 static 显示指定，否则默认是是实例方法。<br>格式：[可见性] 名称([参数列表]) [:返回类型 ]<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216663.png" alt="image-20201217183526275"></li></ol><p>UML 类图中可以给属性或方法加上下划线表示 static 。属性和操作前面的可选的四种可见性修饰符，可见范围逐渐变大：</p><ul><li><code>-</code>：private，类访问权限，表明只能只能在当前类中被访问。</li><li><code>~</code> ：package/default，包访问权限，表明只能在当前类或当前包中的其他类被访问。</li><li><code>#</code>：protected，子类访问权限，表明只能在当前类、当前包、该类的子类中被访问。</li><li><code>+</code>：public，公开访问权限， 表明可以在任意地方被访问。</li></ul><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>依赖（Dependency）关系是一种使用（use-a）关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。</p><p>依赖通常指的是编译时依赖而不是运行时依赖。A 依赖 B 简单理解就是类 A 使用到了类 B，A 编译的时候 B 必须要存在。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。这种依赖具有偶然性、临时性，可能传入的参数一旦变化这种依赖就不存在了。</p><p>在 UML 中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。依赖关系通常是单向的，但也可以存在双向的相互依赖。<br>在 Java 中，依赖可以表现为：方法中的形参、方法中的局部变量、静态方法调用。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216664.png" alt="image-20201217170924215"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drive</span><span class="hljs-params">(Car car)</span><span class="hljs-comment">//方法中的形参：将一个类的对象作为另一个类中方法的参数</span></span><br><span class="hljs-function">    </span>&#123;<br>        car.move();<br>        Car c ;<span class="hljs-comment">//方法中的局部变量：在一个类的方法中将另一个类的对象作为其局部变量</span><br>        Car.getInstace（）;  <span class="hljs-comment">//静态方法调用：在一个类的方法中调用另一个类的静态方法</span><br>    &#125;<br>    ……<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Car();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> </span>&#123;<br>        ......<br>    &#125;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>一个类引入其他类的对象作为成员变量，代表这个类可以知道另外一个类的属性和方法。关联关系体现的是两个类，或者类与接口之间的强依赖关系，这种关系很强烈，比依赖更强，不是偶然性的，也不是临时性的，而是一种长期性，相对平等的关系，类定义完成后这种关系就不可改变了。普通关联的两个类之间并没有明显的整体与部分的关系。</p><p>关联（Association）关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系。</p><p>在 UML 类图中，用实线连接有关联的对象所对应的类，带箭头的实线表示单向关联，双向箭头或者没有箭头的实线表示双向关联。在使用类图表示关联关系时可以在关联线上标注角色名，角色关系常作为实例变量的标识符。</p><p>在 Java 中，一个类持有另一个类的对象实例作为成员变量表示关联关系。</p><p>单向关联：类的关联关系也可以是单向的，单向关联用带箭头的实线表示。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216665.png" alt="image-20201217170225262"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Address address;<br>    ……<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><p>双向关联：默认情况下，关联是双向的。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216666.png" alt="image-20201217170159625"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Product[] products;<br>    ……<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Customer customer;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><p>自关联：在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。表示链式结构时经常用到。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216667.png" alt="image-20201217170310273"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Node subNode;<br>    ……<br>&#125; <br></code></pre></td></tr></table></figure><p>多重性关联 ：多重性关联关系又称为重数性（Multiplicity）关联关系，表示两个关联对象在数量上的对应关系。在 UML 中，对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示。</p><table><thead><tr><th><strong>表示方式</strong></th><th><strong>多重性说明</strong></th></tr></thead><tbody><tr><td>1..1</td><td>表示另一个类的一个对象只与该类的一个对象有关系</td></tr><tr><td>0..*</td><td>表示另一个类的一个对象与该类的零个或多个对象有关系</td></tr><tr><td>1..*</td><td>表示另一个类的一个对象与该类的一个或多个对象有关系</td></tr><tr><td>0..1</td><td>表示另一个类的一个对象没有或只与该类的一个对象有关系</td></tr><tr><td>m..n</td><td>表示另一个类的一个对象与该类最少m，最多n个对象有关系 (m≤n)</td></tr></tbody></table><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216668.png" alt="image-20201217170535792"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Form</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Button[] buttons; <span class="hljs-comment">//定义一个集合对象</span><br>    ……<br>&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> </span>&#123;<br>    …<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合（Aggregation）关系是一种特殊的关联关系，体现的是一种 has-a 关系，聚合关系的两个类的对象之间存在整体与部分的关系，并且成员对象可以脱离整体对象独立存在，他们具有各自的生命周期，部分可以属于多个对象，也可以被多个对象共享。</p><p>在 UML 中，聚合关系用带空心菱形的直线表示。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216669.png" alt="image-20201217170642490"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Engine engine;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(Engine engine)</span> </span>&#123;    <span class="hljs-comment">//构造注入</span><br>        <span class="hljs-keyword">this</span>.engine = engine;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEngine</span><span class="hljs-params">(Engine engine)</span> </span>&#123;    <span class="hljs-comment">//设值注入</span><br>        <span class="hljs-keyword">this</span>.engine = engine;<br>    &#125;<br>    ……<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Engine</span> </span>&#123;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合（Composition）关系也是关联关系的一种特例，体现的是一种 contain-a 关系，比聚合更强，是一种强聚合关系。组合关系的两个类的对象之间也存在整体与部分的关系，但此时整体与部分是不可分的，部分不能脱离整体单独存在。组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。</p><p>在 UML 中，组合关系用带实心菱形的直线表示。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216670.png" alt="image-20201217170849349"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Head</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Mouth mouth;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Head</span><span class="hljs-params">()</span> </span>&#123;<br>        mouth = <span class="hljs-keyword">new</span> Mouth();  <span class="hljs-comment">//实例化成员类</span><br>    &#125;<br>    ……<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mouth</span> </span>&#123;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：（普通）关联、聚合、组合这三种关系在代码层面的表现一致的，只能从类所代表的现实意义来区分。</strong></p><h2 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h2><h3 id="泛化（继承）"><a href="#泛化（继承）" class="headerlink" title="泛化（继承）"></a>泛化（继承）</h3><p>泛化可以复用已有的类，为类增加新功能。例如 A 是 B 和 C 的父类，B，C 具有公共类（父类）A。称 A 是 B 和 C 的一般化（概括，也称泛化），或者称 B 和 C 是 A 的特化（Specialization ）。</p><p>泛化（Generalization）关系使用面向对象中的继承（Inheritance）机制实现，用于描述父类与子类（或子接口和父接口）之间的 is-a 关系。父类（Parent class）又称为基类（Base class）或超类（Superclass），子类（Child class，或 Subclass）又称为派生类（Derived classes）。</p><p>在 UML 中，泛化关系用带空心三角形的直线来表示。父类中出现的属性和操作不需要在子类的类图中重复标出，除非要覆盖父类中的属性和操作。<br>在 Java 中通过关键字 <code>extends</code> 来表示。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216671.png" alt="image-20201217171035545"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span>  </span>&#123;<br>        ……<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> </span>&#123;<br>        ……<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span>  </span>&#123;<br>    <span class="hljs-keyword">private</span> String studentNo;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span>  </span>&#123;<br>        ……<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现（Realization / Implementation）关系，可以理解为一种特殊的继承——被继承的父类是接口（完全的抽象类）。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。接口是对行为的抽象，表示具备了某种能力（can-do），实现是类与接口中最常见的关系。</p><p>在 UML 中，类与接口之间的实现关系用带空心三角形的虚线来表示。<br>在 Java 中通过 <code>implements</code> 关键字来表示，Java 中的类不能同时继承多个类但是可以同时实现多个接口。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192216672.png" alt="image-20201217171143240"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Vehicle</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ship</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> </span>&#123;<br>        ……<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> </span>&#123;<br>        ……<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/LoveLion/article/details/79602149">刘伟：《Java 设计模式》</a></li><li><a href="https://mermaid-js.github.io/mermaid/#/classDiagram">Mermaid 官方文档</a></li><li><a href="https://docs.oracle.com/javase/tutorial/information/glossary.html">Java 术语表</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UML</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 和 GitHub 学习笔记</title>
    <link href="/2020/11/23/Git/"/>
    <url>/2020/11/23/Git/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><p>在使用版本控制软件之前，我们往往使用文件和文件夹配合后缀版本编号来管理版本的迭代，而版本控制软件则是可以帮助我们实施高效科学版本控制的一种工具。</p><h3 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h3><ul><li><p>本地版本控制：记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，仅仅适合个人使用，几乎已经被淘汰。如RCS（Revision Control System）。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155305.png" alt="img"></p></li><li><p>集中版本控制：有一个单一的集中管理服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。常见的例如 SVN（Subversion），CVS（Concurrent Versions System）。</p></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155306.png" alt="140221095037232"></p><ul><li><p>分布式版本控制：相比集中版本控制客户端并不只是提取最新的文件快照，而是把原始的代码仓库完整地镜像下来，所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时 push 到远程仓库即可。Git 就是一个典型的分布式版本控制系统。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155308.png" alt="img"></p></li><li><p>集中式和分布式版本控制的区别：</p><ul><li>集中式所有的版本数据都保存在服务器上，客户机只有某个特定版本的特定文件，依赖通信环境以及服务器的高可靠性。</li><li>分布式每个用户都有服务器所有版本的副本，不依赖网络和中央服务器，但是增加了本地存储空间的占用，Git 通过快照索引大大减少了空间的占用。</li></ul></li></ul><h2 id="Git-的安装和配置"><a href="#Git-的安装和配置" class="headerlink" title="Git 的安装和配置"></a>Git 的安装和配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>进入<a href="git-scm.com/downloads">官网</a>下载对应的版本一路 next 即可，安装成功后在资源管理器任意目录空白处鼠标右键可以看到 <code>Git Bash Here</code> 的选项，可以很方便的在任意路径打开 Bash 终端。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155309.png" alt="image-20201125205733637"></p><p>因为 Git 这款软件上是从 Linux 移植而来，通过安装 Git for Windows 我们不仅获得了 Git 这个工具，还拥有了一个 Git Bash 终端以及一些移植而来的 Linux 命令，这让我们可以在 Git bash 终端中运行一些常见 Linux 命令工具，因此建议以后使用 Git Bash 终端来进行 Git 相关操作，顺便还可以熟悉常用的 Linux 命令。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Git 在安装目录（系统配置），用户主目录下（全局配置），仓库目录下（项目配置）存在三级配置文件。 配置文件名为<code>.gitconfig</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看当前的 Git 配置</span><br>git config --list  <br><br><span class="hljs-comment">#查看系统 config</span><br>git config --system --list<br>　　<br><span class="hljs-comment">#查看当前用户（global）配置</span><br>git config --global  --list<br><br><span class="hljs-comment">#编辑当前仓库的 Git 配置文件</span><br>$ git config -e<br><br><span class="hljs-comment">#编辑当前全局的 Git 配置文件</span><br>$ git config -e --global<br></code></pre></td></tr></table></figure><p>当你安装 Git 后首先要做的事情是设置你的用户名称和 e-mail 地址。<br>如果查看配置中没有 <code>user.name</code>  和 <code>user.email</code> 项，需要使用以下命令设置用户名与邮箱，每次 Git 提交都会附带上这些信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name &lt;user name&gt;<br>git config --global user.email &lt;user name&gt;<br></code></pre></td></tr></table></figure><h2 id="Git-操作"><a href="#Git-操作" class="headerlink" title="Git 操作"></a>Git 操作</h2><h3 id="Git-中的四大区域"><a href="#Git-中的四大区域" class="headerlink" title="Git 中的四大区域"></a>Git 中的四大区域</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155310.png" alt="img"></p><ul><li>Workspace：工作区，对应着资源管理器中的一个目录，这个目录由 Git 进行管理</li><li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），里面有本地提交的所有版本的数据。其中存在一个 HEAD 指针指向当前开发的分支最新更改，不一定指向最新的提交，因为可能回滚。</li><li>Remote：远程仓库，托管代码的服务器中的仓库。</li></ul><p>四个区域的转化关系如图，History 对应的就是 Repository 区。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155311.png" alt="img"></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>新建一个需要 Git 进行管理的项目目录，鼠标右键点击 Git Bash Here，在此处打开 Git Bash 终端。</p><ol><li><p>使用<code>git status</code>先查看一次当前目录的 git 状态，命令行错误提示当前目录这不是一个 git 仓库，就是改目录还没有被 git 管理起来。</p></li><li><p>输入<code>git init</code>使用初始化命令将目录初始化，初始化本地仓库时，会在当前目录创建一个名为 .git 的隐藏文件夹，里面存放了一些 git 相关的文件。</p></li><li><p>输入<code>git status</code>再查看一次当前目录的 git 状态，命令行提示当前我们在 Git 为我们自动创建的 master 分支上，并且没有当前没有任何提交，说明当前目录已经被 git 管理起来了。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155312.png" alt="image-20201126105322809"></p></li><li><p>使用 <code>touch demo1.txt </code>在当前目录新建一个文件，用<code>git status</code>查看 git 状态，显示我们刚刚新加的文件没有被跟踪（Untracked）。</p></li><li><p>使用 <code>git add .</code> 将该目录所有文件跟踪起来，并提交暂存区，然后再用<code>git status</code>查看 git 状态，提示有一个更改待提交。因为刚才只是把文件添加到暂存区，还没有提交到本地仓库。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155313.png" alt="image-20201126110128293"></p></li></ol><ol start="4"><li>使用<code>git commit -m &quot;create demo1.txt&quot;</code>，将暂存区中的修改提交到远程仓库 master 分支，-m 后面的字符串消息用来提示本次提交的修改，不可省略。</li><li>再使用<code>git status</code>查看工作区状态，提示没有更改要提交，这样就完成了一个完整创建仓库初始化，创建新文件并提交的流程。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155314.png" alt="image-20201126111336942"></li></ol><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ol><li>使用<code>touch</code>再创建几个新文件并通过<code>git add</code>和<code>git commit</code>，提交到本地仓库 master 分支，这样就有了多次提交记录。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155315.png" alt="image-20201126120803460"></li><li>使用<code>git log</code>可以查看当前分支的提交日志，按提交日期由近及远打印，最上面对应的是最近一次提交。其中 commit 后面的一长串字符串是该次提交的 commit id，通过这个 id 索引可以得到该次提交发生时整个仓库的文件内容。 当日志记录过多的时候一页展示不下时会自动分页，终端左下角会有一个冒号，按「空格」键下一页，按「b」上一页，按「q」退出查看，到尾页左下角显示(END)。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155316.png" alt="image-20201126120826493"></li><li>使用<code>git log --oneline</code>查看精简后的日志，以一行显示。</li><li>使用<code>git reflog</code>查看所有分支的历史提交精简日志，HEAD@ 后面大括号中的数字是当前开发分支和历史更改间的修改次数。这个命令而不仅仅是当前分支的历史提交，还显示整个仓库中其他分支历史提交，因为我们没有创建其他分支所以还是只有 3 条记录。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155317.png" alt="image-20201126122357668"></li></ol><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><h4 id="会滚到暂存区"><a href="#会滚到暂存区" class="headerlink" title="会滚到暂存区"></a>会滚到暂存区</h4><ol><li>如果我们在工作区的某个文件进行了一些修改操作，但还没有提交到暂存区中，想回滚到暂存区之前的状态，可以使用<code>git checkout &lt;file name&gt;</code>回滚指定文件。也可以使用<code>git checkout .</code>回滚整个文件夹，注意：这个操作会清除工作区中所有未添加到暂存区的改动。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155318.png" alt="image-20201126132124585"></li></ol><h4 id="回滚到某次提交"><a href="#回滚到某次提交" class="headerlink" title="回滚到某次提交"></a>回滚到某次提交</h4><ol><li><p>如果修改只是通过 add 添加到了暂存区，但还没有提交到本地仓库，可以使<code>git reset --hard HEAD</code>，因为此时 HEAD 指针还没有移动，可以直接回滚到 HEAD 指针处。</p></li><li><p>如果已经提交到本地仓库，则要使用<code>git reset --hard</code>后面跟上 commit id 就可以回滚到指定版本，一般只输入 commit id 的前几位就足够区分该 id，没必要输入完整的 commit id，一般输入前 7 位，最少要输入 4 位。<code>git reset --hard</code>中 hard 参数会让本地库中 HEAD 指针移动的同时，重置本地仓库、暂存区和暂存区，而 mixed 参数只让本地仓库和暂存区进行回滚，soft 参数只让本地仓库重置，使用最多的就是 hard 参数。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155319.png" alt="image-20201126123405823"></p></li><li><p>用<code>ls</code>查看当前目录下的文件，发现仓库已经回滚到第一次提交时的状态，只剩下 <code>demo1.txt</code> 文件通过<code>git log</code>也只能查看到第一次提交历史。也就是说连日志记录也回滚了，回滚前的一部分日志也消失了，要查看完整的回滚日志记录，应该像上图使用<code>git reflog</code>。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155320.png" alt="image-20201126123756270"></p></li><li><p>前进版本，和回滚一样，利用<code>git reset --hard</code>加上 commit id 也可以前进到回滚前某一次提交的版本。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155321.png" alt="image-20201126124647709"></p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3></li><li><p>使用<code>git diff [file name]</code>将工作区的文件内容和暂存区中文件内容做按行比较，显示差异，后面加上文件名只比较指定文件。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155322.png" alt="image-20201126143234024"></p></li><li><p>使用<code>git diff &lt;commit id | HEAD&gt;  [file name]</code>将工作区和某次提交时的本地仓库中进行按行比较。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155323.png" alt="image-20201126142142484"></p></li><li><p>使用<code>git checkout</code> 将工作区、暂存区，与 HEAD 指向本地库中的文件内容做汇总比较，看是否已经全部同步。</p></li></ol><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>创建一个新的分支，相当于把原来分支的内容复制了一份到新分支上，可以在新分支上做各种功能的开发，等功能开发完毕可以再选择合并到原来的分支，这样便可以在不影响原分支的情况下添加各种新功能，这样可以多个分支并行开发，互不影响，提高开发效率。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155324.png" alt="img"></p><h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><ol><li>使用<code>git branch [-v]</code>查看所有本地分支，分支前面的「*」代表当前所在分支。</li><li><code>git branch &lt;branch-name&gt; [commit-id]</code> 从指定提交处创建一个新的分支，后面没有跟 commit id 则默认从 HEAD 指针处创建一份新的分支。</li><li><code>git checkout &lt;branch-name&gt; </code>切换到指定分支。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155325.png" alt="image-20201126151411013"></li><li>在 dev 分支中新建一个 <code>demo4.txt</code> 文件，add 到暂存区后 commit，可以看到 HEAD 指针已经指向了当前开发分支的最新修改。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155327.png" alt="image-20201126152247294"></li></ol><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><ol><li>切换回 master 分支，dev 分支中的修改并没有影响到 master 分支。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155328.png" alt="image-20201126152547025"></li><li>使用<code>git merge &lt;branch name&gt;</code>将另外一个分支合并到当前分支。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155329.png" alt="image-20201126153034605"></li></ol><h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4><ol><li>当两个分支对了同一文件的同一行位置做了不同的修改时，直接合并这两个分支就会产生冲突，分支会变成 MERGING 状态。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155330.png" alt="image-20201126154608101"></li><li>提示合并出现冲突后，工作区的冲突文件其实已经被修改，但这个文件中保留了两个分支中的冲突代码，并通过分隔符来告诉发生冲突的代码分别属于哪个分支，这时候就需要手动修改冲突的文件来解决冲突。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155331.png" alt="image-20201126155056631"></li><li>修改后先 add 冲突的文件，来告诉 Git 系统已经解决把冲突解决，然后再 commit 整个工作区，合并才是真正的完成，MERGING 状态消失。注意：不能只单独 commit 冲突的文件。<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155332.png" alt="image-20201126160111169"></li></ol><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>前面我们只是把 Git 当作一个本地版本控制系统来使用，接下来学习和远程仓库相关的操作。GitHub，Gitee 给我们提供免费的远程仓库托管服务，我们可以在上面免费创建远程仓库，也可以选择选择自己搭建 GitLab 这样的代码托管平台。进行接下来操作之前先到 <a href="http://github.com/">GitHub </a>注册一个账号。</p><h3 id="将本地仓库上传到远程仓库"><a href="#将本地仓库上传到远程仓库" class="headerlink" title="将本地仓库上传到远程仓库"></a>将本地仓库上传到远程仓库</h3><ol><li>初始化一个本地仓库</li><li>在 GitHub 上新建一个空的远程仓库，仓库名建议和本地工作区目录名一样，这样可以让我们方便把本地的工作区目录和远程的仓库对应起来。</li><li>在 GitHub 上打开仓库可以得到远程仓库的 https 地址<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155333.png" alt="image-20201126161814967"></li><li>给远程仓库的 https 地址取一个别名，常用为 origin，方便后面的操作<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155334.png" alt="image-20201126162243228"></li><li>用<code>git push</code>命令向远程仓库推送本地仓库的内容，第一次git push 会弹出一个窗口让在先登录 GitHub 账号，之后 Windows 会保存凭据自动登录，如果想要推送到远端另一个账号需要先在 Windows 凭据管理器删除原先的凭据。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155335.png" alt="image-20201126162749682"></li><li>打开 GitHub 对应仓库页面，本地仓库的内容已经同步了上去。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155336.png" alt="image-20201126163609357"></li></ol><h3 id="将远程仓库同步到本地仓库"><a href="#将远程仓库同步到本地仓库" class="headerlink" title="将远程仓库同步到本地仓库"></a>将远程仓库同步到本地仓库</h3><ol><li>打开一个 GitHub 仓库页面，找到仓库的 clone 地址并复制<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155337.png" alt="image-20201126163709535"></li><li>任意目录下右键打开 Git Bash 终端，使用<code>git clone</code>命令来克隆远程仓库到本地，并自动创建远程仓库链接的别名<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155338.png" alt="image-20201126164201012"><br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155339.png" alt="image-20201126164549289"></li></ol><h3 id="团队开发"><a href="#团队开发" class="headerlink" title="团队开发"></a>团队开发</h3><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155340.png" alt="image-20201125161147659"></p><ol><li>项目经理在 GitHub 的仓库设置中向其他团队成员的 GitHub 账户发送邀请链接。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155341.png" alt="image-20201126165218019"></li><li>被邀请用户登录 Github 打开邀请链接同意邀请成为协作者。</li><li>协作成员 clone 整个项目到本地后在本就可以直接在本地开发，完成后可以直接利用自己的 GItHub 直接 push 到该仓库中。</li></ol><h3 id="远程冲突"><a href="#远程冲突" class="headerlink" title="远程冲突"></a>远程冲突</h3><ol><li>由于其他协作开发者的对同一文件的更改，可能导致将本地库 push 到远程仓库时产生冲突，这时候远程仓库会拒绝 push。</li><li>需要先把远程仓库 pull 下来，会和本地仓库自动合并，产生冲突文件，修改好冲突文件后，经过 add 和 commit 操作后再 push 到远程仓库。</li><li>为了尽可能的避免冲突每次开发前应该先把远程的仓库 pull 到本地更新完本地仓库后再进行开发，当然更为谨慎的做法是先 fetch 远程库，在checkout 进入远程库，确认改动后再手动 merge，pull = fetch + merge。</li></ol><h3 id="跨团队合作"><a href="#跨团队合作" class="headerlink" title="跨团队合作"></a>跨团队合作</h3><ol><li>先在 GitHub 上 fork 一份目标远程仓库，然后 clone 到本地。至于 clone 上游仓库还是自己的账户里面的 fork 下来的仓库无所谓。使用diff命令比较两次不同地址 clone  下来的文件除了 .git 目录中记录的 clone 日期和 url不一样，其余文件均一样，当然前提是 fork 下来的仓库和原来的上游仓库是同步的，没有落后（behind）版本。GitHub 中 fork 的仓库是原来仓库 fork 时的副本，相当于快照，不会自动更新，需要手动在 fetch 原始上游仓库后合并到本地，再push回远程。详见<a href="https://help.github.com/articles/syncing-a-fork/">Syncing a fork</a> 和 <a href="https://blog.csdn.net/qianghaohao/article/details/79330114">GitHub设置fork仓库和原始仓库同步</a></li><li>因为没有权利提交到上游仓库，每一个小版本提交到自己账户下 fork 而来的仓库进行开发。</li><li>开发完毕后在 GitHub 上创建一个新的 Pull Request。</li><li>等上游审核完毕后，就可以把代码合并进原来的项目了</li></ol><h3 id="使用-SSH-连接到远程仓库"><a href="#使用-SSH-连接到远程仓库" class="headerlink" title="使用 SSH 连接到远程仓库"></a>使用 SSH 连接到远程仓库</h3><ol><li>先使用<code>cd ~</code>切换到当前用户目录，然后输入命令<code>ssh-keygen -t rsa -C &quot;HP-OMEN&quot;</code>，按三次回车确认，会在用户目录生成一个.shh的文件夹，里面存放了公钥和私钥。 -C 后面的参数是生成的秘钥的的注释（comment to identify the key），相当于是这串钥匙的名字，可以任意，不一定为邮箱。</li><li>使用命令<code>cat ~/.ssh/id_rsa.pub</code>打开公钥文件，复制整行，粘贴进GitHub 中。的个人 setting 页面，左侧找到 SSH and GPG keys 选项，点击 New SSH KEy 按钮，进去粘贴公钥，并命名，完成公钥绑定。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155342.png" alt="image-20201125173736244"></li><li>使用命令<code>ssh -T git@github.com</code>测试是否配置成功。第一次连接到陌生主机需要输入 yes 后回车确认，配置成功后可以使用 ssh 的方式来访问远程仓库。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155343.png" alt="image-20201125174610157"></li><li>通过 ssh 地址连接远程仓库 push 操作不用输入密码，缺点是一台电脑只能连接到远端的一个GitHub账户。</li></ol><h2 id="在-IDEA-中集成-Git-操作"><a href="#在-IDEA-中集成-Git-操作" class="headerlink" title="在 IDEA 中集成 Git 操作"></a>在 IDEA 中集成 Git 操作</h2><ol><li><p>打开 IDEA 设置界面，配置 Git 的安装路径。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155344.png" alt="image-20201125175556213"></p></li><li><p>使用 Git 管理该项目并进行本地库的初始化操作，在 IDEA 项目根目录会生成一个 .git 目录<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155345.png" alt="image-20201126180751582"></p></li><li><p>也可以在 IDEA 中利用 Git 从远程仓库直接克隆一个项目，输入GitHub 仓库地址，或者绑定自己的 GitHub 账号，就可以直接在下拉框中选择自己账号中的仓库clone，点击 clone，等待一会 IDEA 会提示是否在新窗口中打开 clone 下来的项目。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155346.png" alt="image-20201125183134274"><br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155347.png" alt="image-20201125193050152"></p></li><li><p>在 IDEA 设置界面中，可以取消 Git 对该项目的管理。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192155348.png" alt="image-20201126181027784"></p></li></ol><h2 id="常用-git-命令补充"><a href="#常用-git-命令补充" class="headerlink" title="常用 git 命令补充"></a>常用 git 命令补充</h2><p>下面列举了工作中常用到的 git 命令，更多 git 命令请参考<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">阮一峰：常用 Git 命令清单</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看工作目录的状态；</span><br>git status<br><br><span class="hljs-comment">#查看工作目录的状态的精简信息，s=summary，总结，b=braanch，分支</span><br>git status  -sb<br><br><span class="hljs-comment">#让 git 开始管理当前目录并初始化</span><br>git init<br><br><span class="hljs-comment">#将指定文件提交到暂存区；用通配符「*」可以把当前目录下所有文件添加到暂存区</span><br>git add &lt;file name&gt;...<br><br><span class="hljs-comment">#将当前目录的所有文件到暂存区，效果同 git add *</span><br>git add .<br><br><span class="hljs-comment">#提交整个暂存区到本地仓库，message 这次提交的备注信息，必须输入,没有直接输入，则会自动打开一个空文本用来输入备注信息</span><br>git commit -m &lt;message&gt;<br><br><span class="hljs-comment">#查看历史提交日志</span><br>git <span class="hljs-built_in">log</span><br><br><span class="hljs-comment">#显示当前分支的版本提交历史，但每次提交以一行显示</span><br>git <span class="hljs-built_in">log</span> --pretty=oneline<br><br><span class="hljs-comment">#显示当前分支的版本提交历史，但每次提交以一行显示，并且 commit-id 只显示前面 7 位 </span><br>git <span class="hljs-built_in">log</span> --oneline<br><br><span class="hljs-comment">#显示整个仓库所有分支的最近提交历史，还包括每个提交距离工作分支的距离，每次提交以一行显示，并且 commit-id 只显示前面 7 位 </span><br>git reflog<br><br><span class="hljs-comment">#将本地库的指针指定指向 commit-id 这次提交，重置这次暂存区与工作区，不指定 commit 默认与最近一次 commit 保持一致；</span><br>git reset --hard [commit-id]<br><br><span class="hljs-comment">#恢复某个commit的指定文件到暂存区和工作区</span><br>git checkout &lt;commit id&gt; &lt;file&gt;<br><br><span class="hljs-comment">#恢复暂存区的所有文件到工作区</span><br>git checkout .<br><br><span class="hljs-comment">#恢复暂存区的指定文件到工作区</span><br>git checkout &lt;file&gt;<br><br><span class="hljs-comment">#将工作区和暂存区的进行按行比较，显示暂存区和工作区的差异</span><br>git diff<br><br><span class="hljs-comment">#显示工作区与当前 HEAD 分支之间的差异</span><br>git diff HEAD<br><br><span class="hljs-comment">#列出所有本地分支，分支前面的「*」代表当前所在分支</span><br>git brach<br><br><span class="hljs-comment">#新建一个分支，但依然停留在当前分支</span><br>git branch &lt;branch-name&gt;<br><br><span class="hljs-comment">#新建一个指向指定 commit 的分支，</span><br>git branch &lt;branch-name&gt; &lt;commit-id&gt;<br><br><span class="hljs-comment">#切换到指定分支，并更新工作区</span><br>git checkout &lt;branch-name&gt;<br><br><span class="hljs-comment">#合并指定分支到当前分支,使用前应该配合 checkout 切换到合适的分支</span><br>git merge &lt;branch-name&gt;<br><br><span class="hljs-comment">#查看远程仓库，还可以用来看仓库的别名</span><br>git remote -v<br><br><span class="hljs-comment">#给远程某一个仓库添加地址别名,只在当前仓库配置中生效</span><br>git remote add &lt;<span class="hljs-built_in">alias</span>&gt; &lt;url&gt;<br><br><span class="hljs-comment"># 取回远程仓库的变化，并与指定分支合并</span><br>git pull [url | <span class="hljs-built_in">alias</span>] &lt;branch name&gt;<br><br><span class="hljs-comment">#从远程克隆一个项目和它的整个代码历史</span><br>git <span class="hljs-built_in">clone</span> [url]<br><br><span class="hljs-comment">#将本地指定分支往远程仓库推送</span><br>git push [url | <span class="hljs-built_in">alias</span>] &lt;branch name&gt;<br><br><br><span class="hljs-comment">#把远程仓库的内容拉取到本地创建一个副本仓库，这个仓库是远程仓库的一个拷贝，区别仅仅是已经下载到本地而已，不会自动更新工作区，需要手动使用 merge 命令来手动把本地仓库的某个分支和已经下载到本地的远程仓库副本的某个分支合并在一起达到 pull 的效果。pull = fetch + merge，工作中最好先fetch 下来，使用 diff 比较检查两个分支再 merge，而不是直接pull。</span><br>git fetch [url | <span class="hljs-built_in">alias</span>] <br><br><span class="hljs-comment">#如果在本地已经有了仓库，并且里面有一些文件，想把远程仓库的文件添加进来，由于两个仓库没有共同的祖先，需要进行无关联拉取。</span><br>git pull [url | <span class="hljs-built_in">alias</span>]  master --allow-unrelated-histories<br><br><span class="hljs-comment">#删除指定的远程分支</span><br>git push origin --delete master<br><br><span class="hljs-comment">#冒号前不指定本地分支，就推送一个空的本地分支到远程分支，也可以达到上面一条删除的效果</span><br>git push origin :master<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.bilibili.com/video/BV185411L7xs">B站视频教程：赵姗姗教你玩转Git</a></li><li><a href="https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ">狂神聊git</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">阮一峰：常用 Git 命令清单</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>SSH</tag>
      
      <tag>GitHub</tag>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理学习笔记</title>
    <link href="/2020/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2020/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第-１章-计算机系统概论"><a href="#第-１章-计算机系统概论" class="headerlink" title="第 １章 计算机系统概论"></a>第 １章 计算机系统概论</h2><h3 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h3><ul><li><p>计算机系统组成：</p><ul><li>硬件：计算机的实体，如主机、外设等</li><li>软件：由具有各类特殊功能的信息（程序）组成，分为应用软件，系统软件</li></ul></li><li><p>计算机体系结构和计算机组成的区别：</p><ul><li>计算机体系结构研究的是程序员所见到的计算机系统的属性概念性的结构与功能特性，具体来说就是指令系统、数据类型、寻址技术、I/O 机理</li><li>计算机组成研究的是如何实现计算机体系结构所体现的属性，例如如何实现乘法指令</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226305.png" alt="image-20200902032458386"></p></li></ul><h3 id="1-2-计算机的基本组成"><a href="#1-2-计算机的基本组成" class="headerlink" title="1.2 计算机的基本组成"></a>1.2 计算机的基本组成</h3><ul><li><p>冯· 诺依曼计算机的基本特点：按地址访问并顺序执行指令。主要原理核心思想是存储程序和程序控制。主要特点</p><ol><li>计算机由五大部件组成：运算器、控制器、存储器、输入设备、输出设备</li><li>指令和数据以同等地位存放于存储器内，并可按地址访问。</li><li>指令和数据用二进制表示</li><li> 指令由操作码和地址码组成。操作码表示操作的性质、地址码表示操作数在存储器中的位置。</li><li>指令在存储器中按顺序存放。通常，指令时顺序执行的。在特殊情况下，可根据运算结果或指定的条件来改变运算顺序。</li><li>以运算器为中心，输入输出设备和存储器之间的数据传送通过运算器完成。（早期的冯诺依曼计算机以运算器为中心,而现代计算机已变为以存储器为中心）</li></ol><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226306.png" alt="早期的冯诺依曼计算机以运算器为中心"></p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226307.png" alt="现代计算机已变为以存储器为中心"></p></li><li><p>现代计算机硬件框图<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226308.png" alt="image-20200902034653719"><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226309.png" alt="image-20200831175528325"></p></li><li><p>存储器的基本组成<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226310.png" alt="image-20200902035911495"></p><ul><li>存储体：由若干个存储单元构成</li><li>存储单元：也叫存储存放一串二进制代码，每个存储单元赋予一个地址号，按地址寻访</li><li>存储字：存储单元中二进制代码的组合，和存储单元意思相近</li><li>存储字长：存储单元中二进制代码的位数存储字长：存储单元中二进制代码的位数，按字编址时，机器字长=存储字长。假如按字节编址，存储器一个存储单元大小为1个字节。现在的计算机都是按字节编址了。</li><li>MAR：主存地址寄存器，连接地址总线，可以反映存储单元的个数</li><li>MDR：主存数据寄存器，连接数据总线，可以反映存储字长</li></ul><p>例如某个储存器 MAR = 4 位，MDR = 8 位，存储单元个数 16（2 ^ 4），存储字长 8</p></li><li><p>运算器的基本组成<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226311.png" alt="image-20200902040801669"></p><ul><li>ALU（Arithmetic&amp;logical Unit）：算术逻辑单元(arithmetic and logic unit) 是能实现多组算术运算和逻辑运算的组合逻辑电路。ALU是组合逻辑电路，要保存就需要用到时序逻辑电路</li><li>ACC（Accumulator）：累加寄存器，专门用来存放操作数或运算结果。两个操作数中的指令的通常一个操作书在累加器A中，运算完成后累加器A中便可得到运算结果两个操作数中的指令的通常一个操作书在累加器A中，运算完成后累加器A中便可得到运算结果。</li><li>MQ（Multiple—Quotient Register）：乘商寄存器。主要负责数据的乘法与除法运算并可保存运算结果</li></ul></li><li><p>控制器的基本组成</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226312.png" alt="image-20200902041025531"></p><ul><li>PC（Program Counter）：程序计数器，存放当前欲执行指令在存储器的存放位置</li><li>IR（Instruction Register）：指令寄存器，用来存放指令的，存放当前正在执行的指令，包括指令的操作码，操作数</li><li>CU（Control Unit）：控制单元，是整个控制器的核心，分析指令，然后发出各种控制信号</li></ul></li><li><p>指令执行过程，以取数指令为例：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226313.png" alt="image-20200902041901334"></p><ul><li>取指令（1、2、3 、4）： PC MAR M MDR IR ,(PC)+1 PC</li><li>分析指令 （5）：OP(IR) CU</li><li>执行指令 （6、7、8、9）Ad(IR) MAR M MDR ACC</li></ul></li></ul><h3 id="1-3-计算机硬件的主要技术指标"><a href="#1-3-计算机硬件的主要技术指标" class="headerlink" title="1.3 计算机硬件的主要技术指标"></a>1.3 计算机硬件的主要技术指标</h3><ul><li>机器字长: CPU 一次能处理数据的位数。一般和 CPU 中的通用寄存器位数以及数据总线宽度相等(也就是字长)。</li><li>总线宽度：数据总线一次能并行传送的最大信息的位数</li><li>主频 f：指CPU内核工作的时钟频率，即CPU内数字脉冲信号振荡的速率。主频 = 外频 × 倍频（外频：指CPU(内存)与主板之间同步的时钟频率(系统总线的工作频率)；倍频：CPU主频与外频之间的倍数）。</li><li>时钟周期T：也称节拍周期，是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。f 与 T的关系互为倒数。</li><li>CPI (Clock cycles Per Instruction)：执行一条指令(平均)需要的时钟周期数(即T周期的个数)<br>指令系统CPI = 程序中所有指令的时钟周期数之和 / 程序指令总数<pre><code>                  =  (程序中各类指令的CPI ×程序中该类指令的比例)</code></pre></li><li>MIPS (Million Instructions Per Second)：每秒钟CPU能执行的指令总条数 (单位：百万条/秒)<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226314.png" alt="image-20200902045007880"><br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226315.png" alt="image-20200902045142109"></li><li>FLOPS：每秒浮点运算次数</li><li>主存容量：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226316.png" alt="image-20200902045453768"></li></ul><h2 id="第２章-计算机的发展及应用"><a href="#第２章-计算机的发展及应用" class="headerlink" title="第２章 计算机的发展及应用"></a>第２章 计算机的发展及应用</h2><h3 id="2-1-计算机的发展史"><a href="#2-1-计算机的发展史" class="headerlink" title="2.1 计算机的发展史"></a>2.1 计算机的发展史</h3><ul><li>世界上第一台现代电子数字计算机埃尼阿克(ENIAC)，诞生于1946年的美国宾夕法尼亚大学，ENIAC 是继ABC（阿塔纳索夫-贝瑞计算机）之后的第二台电子计算机和第一台通用计算机。但ENIAC没有真正的存储器。ENIAC只在20个暂存器，冯诺依曼在此基础上提出了EDVAC方案，是第一台冯·诺伊曼结构的计算机。</li><li>IBM在1964年4月推出了System/360系列机，这一系列是世界上首个指令集可兼容计算机。在此以前，每台计算机都有自己的指令集，计算机厂商要针对每种主机量身定做操作系统，而System/360的问世则让单一操作系统适用于整系列的计算机。IBM兼容机是指其他厂商生产的与IBM的PC机指令集兼容的计算机。</li><li>电子管 –&gt; 晶体管（transistor） –&gt; 中小规模集成电路 –&gt; 大规模集成电路 –&gt; 超大规模集成电路</li></ul><h2 id="第３章-系统总线"><a href="#第３章-系统总线" class="headerlink" title="第３章 系统总线"></a>第３章 系统总线</h2><h3 id="3-1-总线的基本概念"><a href="#3-1-总线的基本概念" class="headerlink" title="3.1 总线的基本概念"></a>3.1 总线的基本概念</h3><ul><li>总线：总线是连接各个部件的信息传输线，是各个部件共享的传输介质，同一时刻只有一对设备使用总线。</li><li>以存储器为中心的双总线结构框图，增加了存储总线来让cpu和存储器直接交换信息，减轻了系统总线的负担，避免称为系统瓶颈。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226317.png" alt="image-20200902153451295"></li></ul><h3 id="3-2-总线的分类"><a href="#3-2-总线的分类" class="headerlink" title="3.2 总线的分类"></a>3.2 总线的分类</h3><ul><li>片内总线：芯片内部各部件之间的的总线，如CPU内部连接各寄存器及运算器之间的总线。</li><li>系统总线：计算机各部件之间 的信息传输线<ul><li>数据总线：双向 与机器字长、存储字长有关，但不一定等于字长，一个字可以分多次传输</li><li>地址总线：单向 与存储地址、 I/O地址有关，和 MAR 位数相等</li><li>控制总线：双向，存储器读、存储器写，总线允许、中断确认，中断请求、总线请求。</li></ul></li><li>通信总线：用于 计算机系统之间 或 计算机系统与其他系统（如控制仪表、移动通信等）</li><li>按照传输方式分类：<ul><li>并行通信总线：同一时刻，可以传输多个bit位的信号，有多少个信号位就需要多少根信号线。并行通讯的效率高，但是对信号线路要求也很高，很容易产生干扰，反而传输速度不能很快。</li><li>串行通信总线：同一时刻，只能传输一个bit位的信号，只需要一根信号线。串行通讯效率较低，但是对信号线路要求低，抗干扰能力强，传输速度可以很快。</li></ul></li></ul><h3 id="3-3-总线特性及性能指标"><a href="#3-3-总线特性及性能指标" class="headerlink" title="3.3 总线特性及性能指标"></a>3.3 总线特性及性能指标</h3><ul><li><p>总线特性</p><ul><li>机械特性：尺寸、形状、管脚数 及 排列顺序  </li><li>电气特性：传输方向 和有效的 电平 范围</li><li>功能特性 ：每根传输线的 功能，如地址线，数据线，控制线，反馈线</li><li>时间特性：信号的 时序 关系 </li></ul></li><li><p>总线的性能指标 </p><ul><li>总线宽度  数据线 的根数 </li><li>标准传输率 ：每秒传输的最大字节数（MBps）</li><li>时钟同步/异步：  同步、不同步  </li><li>总线复用：地址线 与 数据线 复用，8086的20根地址线和16根数据线复用，减少芯片的管脚数量。</li><li>信号线数：地址线、数据线和控制线的 总和</li><li>总线控制方式 ：突发、自动、仲裁、逻辑、计数  </li><li>其他指标：负载能力</li></ul></li><li><p>总线标准</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226318.png" alt="image-20200902155842393"></p></li></ul><h3 id="3-4-总线结构"><a href="#3-4-总线结构" class="headerlink" title="3.4 总线结构"></a>3.4 总线结构</h3><ul><li>单总线结构<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226319.png" alt="image-20200902181748879"></li><li>双总线结构<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226320.png" alt="image-20200902181828092"></li><li>三总线结构<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226321.png" alt="image-20200902182146428"></li><li>三总线结构的又一形式<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226322.png" alt="image-20200902182207115"></li><li>四总线结构<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226324.png" alt="image-20200902182232812"></li><li>传统微型机总线结构<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226325.png" alt="image-20200902182411141"></li><li>VL-BUS局部总线结构<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226326.png" alt="image-20200902182426697"></li><li>PCI 总线结构<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226327.png" alt="image-20200902182454749"></li><li>多层 PCI 总线结构<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226328.png" alt="image-20200902182509966"></li></ul><h3 id="3-5-总线控制"><a href="#3-5-总线控制" class="headerlink" title="3.5 总线控制"></a>3.5 总线控制</h3><ul><li><p>主设备( 模块)： 对总线有 控制权</p></li><li><p>从设备( 模块) ：响应 从主设备发来的总线命令</p></li><li><p>总线判优控制两种方式：</p><ul><li>分布式</li><li>集中式<ul><li>链式查询<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226329.png" alt="image-20200905141313399"></li><li>计数器定时查询<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226330.png" alt="image-20200905141324291"></li><li>独立请求方式<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226331.png" alt="image-20200905141337555"></li></ul></li></ul></li><li><p>总线传输周期</p><ul><li>申请分配阶段：主模块申请，总线仲裁决定 </li><li>寻址阶段：主模块向从模块 给出地址 和 命令</li><li>传输阶段：主模块和从模块 交换数据 </li><li>结束阶段：主模块 撤消有关信息</li></ul></li><li><p>总线通信的四种方式</p><ul><li>同步通信：由 统一时标 控制数据传送 ，一般在总线长度比较短，各个部件速度比较一致的时候使用，存在短板效应。<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226332.png" alt="image-20200905144306412"></li><li>异步通信：采用 应答方式 ，没有公共时钟标准。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226333.png" alt="image-20200905144245167"></li><li>半同步通信：同步、异步 结合，发送方 用系统 时钟前沿 发信号，接收方 用系统 时钟后沿 判断、识别。增加一条 “等待”响应信号。当从设备数据没有准备好时发出WAIT信号，数据准备好了再开始开始同步传输数据。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226334.png" alt="image-20200905144820275"></li><li>分离式通信：主模块申请占用总线发地址 、命令，使用完后放弃总线的使用权，从模块准备数据完毕后，从模块申请占用总线（身份转换为主设备），向主模块发数据。从模块准备数据是不占用总线的，这时候其他设备可以请求总线，充分挖掘系统总线每个瞬间的潜力。</li></ul></li></ul><h2 id="第-４章-存储器"><a href="#第-４章-存储器" class="headerlink" title="第 ４章 存储器"></a>第 ４章 存储器</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><ul><li>存储器分类：<ul><li>按存储介质分类：<ul><li>半导体存储器：TTL，集成度低，功耗高，速度快，MOS反之</li><li>磁表面存储器：磁头、载磁体（磁盘，磁带）</li><li>磁芯储存器：硬磁材料、环状元件</li><li>光盘存储器：激光、磁光材料·</li></ul></li><li>按存取方式分类：<ul><li>随机访问储存器（广义）：存取时间与物理位置无关<ul><li>随机读取储存器（RAM）</li><li>只读储存器（ROM）</li></ul></li><li>串行访问存储器：存取时间与物理位置有关<ul><li>顺序存取存储器：磁带</li><li>直接（半顺序）存取存储器：磁盘</li></ul></li></ul></li><li>按在计算机中的作用分类：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226335.png" alt="image-20200905153116312"></li></ul></li><li>存储器的层次结构：上一层次的存储器是低一层次的高速缓存。在应用程序员中所有层次存储器构成一个存储体系。寄存器不一定都在CPU内部，CPU内部的寄存器也不都是操作系统可见的。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226336.png" alt="image-20200906082042487"></li></ul><h3 id="4-2-主存储器"><a href="#4-2-主存储器" class="headerlink" title="4.2 主存储器"></a>4.2 主存储器</h3><ul><li><p>主存的基本组成：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226337.png" alt="image-20200906095009256"></p></li><li><p>主存和 CPU 的联系：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226338.png" alt="image-20200906095357113"></p></li><li><p>存储单元是可编址的最小单位，通常是一个字节8位，多字节数据存储分为大端和小端<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226339.png" alt="image-20200906095633396"></p></li><li><p>半导体存储芯片的基本结构：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226340.png" alt="image-20200906100017978"><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226341.png" alt="image-20200906100111098"></p></li><li><p>半导体存储芯片的译码驱动方式：</p><ul><li>线选法：每次操作一个一行（通常构成一个存储单元），但是地址线译码器输出线数量很多<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226342.png" alt="image-20200906100336893"></li><li>重合法：每次操作一个位，但是减少了地址线译码器输出线数量<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226343.png" alt="image-20200906100359220"></li></ul></li></ul><ul><li><p>静态 RAM (SRAM)：每一个基本单元电路（虚线框）需要6个晶体管构成一个SR锁存器（也就是RS双稳态触发器）<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226344.png" alt="image-20200906101415995"></p></li><li><p>静态 RAM 芯片Intel 2114 ：存储容量1K × 4 位，RAM矩阵由64 × 64 基本单元组成。64行对应6根行地址线，64列分为4组，每组16列对应4根列地址线，这样可以一次选中四列，就构成了一个基本存储单元。<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226345.png" alt="image-20200906102927159"></p></li><li><p>动态 RAM ( DRAM )：电容中的电量高于某个阈值（通常为50%）表示1，低于表示0</p><ul><li>三管动态 RAM ：下图左侧，每个基本单元电路需要三个晶体管一个电容，读出与原存信息相反，写入与输入信息相同。读写线分开。</li><li>单管管动态 RAM：读出时数据线有电流 为 “1”，写入时 电容充电为 “1” 放电为 “0”</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226346.png" alt="image-20200906104546147"></p></li><li><p>三管动态 RAM 芯片 (Intel 1103) ：不仅地址要进行译码，读写选择线也要译码。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226347.png" alt="image-20200906104640349"></p></li><li><p>单管动态 RAM 4116 (16K × 1位 ) ：6根地址线先后给出行地址和列地址<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226348.png" alt="image-20200906105008068"></p></li><li><p>动态 RAM 刷新：电容可能出现漏电，所以要对电容进行充放电刷新保证数据正确，刷新均是按行刷新，刷新方式有三种：</p><ul><li>集中刷新：存在死区（cpu这时不能读写主存），以128 × 128 存储芯片（存取周期为0.5 μs ）为例：<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226349.png" alt="image-20200906105420307"></li><li>分散刷新：无死区，但是存储周期翻倍，并且一个刷新时间间隔内多次刷新同一行，有些浪费。以128 × 128 存储芯片（存取周期为1 μs ）为例：<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226350.png" alt="image-20200906105454667"></li><li>异步刷新，分散刷新与集中刷新相结合，将刷新安排在指令译码阶段，不会出现 “死区”。以128 × 128 存储芯片（存取周期为0.5 μs ）为例：<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226351.png" alt="image-20200906105958188"></li></ul></li><li><p>动态 RAM 和静态 RAM 的比较：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226352.png" alt="image-20200906110248585"></p></li><li><p>存储器容量的扩展：</p><ul><li>位扩展 （增加存储单元长度（即字长））：<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226354.png" alt="image-20200906111044274"></li><li>字扩展（增加存储字的数量），用高位地址线充当片选线：<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226355.png" alt="image-20200906111118195"></li><li>字、位扩展：<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226356.png" alt="image-20200906111331269"></li></ul></li><li><p>存储器与 CPU 的连接步骤：</p><p>(1) 写出对应的二进制地址码  </p><p>(2) 确定芯片的数量及类型  </p><p>(3) 分配地址线  </p><p>(4) 确定片选信号  </p><p>(5) 确定片选逻辑</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226357.png" alt="image-20200906111921050"></p></li><li><p>存储器的校验：编码的纠错 、检错能力与编码的最小距离（即码距：任意两个合法编码二进数位数的最小差异位数值）有关，码距越大，抗干扰能力越强，纠错能力越强，数据冗余越大，编码效率低，编码电路也相对复杂。</p></li><li><p>汉明码（海明校验）：汉明码采用非划分分组的奇偶校验：</p><ul><li><p>汉明码的组成至少需增添 k 位检测位 ，其中为k为满足下面的最小值，n为要传输的数据位数<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226358.png" alt="image-20200906140001555"></p></li><li><p>检测位的位置在第2^ i-1 （i=1，2，…，r)位上，其余位依次放置被校验的数据位</p></li><li><p>只要数据位的位置二进制中某一位为1，则说明被对应位置检验位检测，例如：</p><ul><li>第一个检测位包含第 1，3，5，7，9，11，  ……位置的二进制编码为X…XXX1</li><li>第二个检测位包含第 2，3，6，7，10，11，…… 位置的二进制编码为X…XX1X</li><li>第三个检测位包含第 4，5，6，7，12，13，…… 位置的二进制编码为X…X1XX</li><li>第四个检测位包含第 8，9，10，11，12，13，  位置的二进制编码为X…1XXX</li></ul></li><li><p>求汉明码<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226359.png" alt="image-20200906141040402"></p></li><li><p>汉明码的纠错（以偶校验的汉明码，最多一位出错为例，）：对每一个分组分别偶校验，如果指错字均为0，则说明没有出错，如果出错分组的交就是错误位置，如果只有一个分组出错说明是只是添加的该分组校验位出错，可不用纠错。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226360.png" alt="image-20200906141513456"></p></li><li><p>汉明码只能检验和纠错1位，如果多位出现错误即使指错字均为0也不一定无措，并且不一定能区别一位错与两位错。</p></li></ul></li><li><p>多体并行系统：高位交叉可以用于容量的扩展，低位交叉可以提高带宽和访问速度</p><ul><li>高位交叉，顺序编址<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226361.png" alt="image-20200906172451439"></li><li>低位交叉，各个体轮流编址<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226362.png" alt="image-20200906172512148"></li><li>四体低位交叉存储器，存取周期为T，总线传输周期（地址信号通过总线传输的时延）为 τ ，为实现流水线方式存取，应满足 T ＝ 4 τ<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226363.png" alt="image-20200906172619416"></li></ul></li></ul><h3 id="4-3-高速缓冲存储器"><a href="#4-3-高速缓冲存储器" class="headerlink" title="4.3 高速缓冲存储器"></a>4.3 高速缓冲存储器</h3><ul><li><p>程序局部性原理：是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域，具体来说，局部性通常有两种形式：时间局部性和空间局部性。</p><ul><li>时间局部性：被引用过一次的存储器位置在未来会被多次引用（通常在循环中）。 </li><li>空间局部性：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</li></ul></li><li><p>为了缓解 CPU 和主存（DRAM）的速度差异，避免 CPU “空等” 现象。根据程序局部性原理提出了告诉缓存，也就是读取内存的时候将将内存所在的内存块整个读进缓存，从而提高访问速度。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226364.png" alt="image-20200907095754487"></p></li><li><p>存储墙：存储器提供数据的速度远远落后处理器处理数据的速度，存储器速度成为各类计算体系的最大瓶颈。</p></li><li><p>主存和缓存按块存储，块的大小相同，一般每块可取 4 ~ 8 个字，B 为块长，缓存共有 C 块，主存共有 M 块 M &gt;&gt; C。用 标记记录与某缓存块建立了对应关系的主存块号。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226365.png" alt="image-20200908215254459"></p></li><li><p>Cache 的命中率：CPU 欲访问的信息在 Cache 中的 比率。命中率 与 Cache 的 容量 与 块长 有关，容量越大命中越高，块由小到大增大时,起初会因局部性原理使命中率提高;若继续增大,则命中率很可能下降。一般每块可取 4 ~ 8 个字，也可以取一个存取周期内从主存调出的信息长度，16体交叉 块长取 16 个存储字，4体交叉 块长取 4 个存储字。</p></li><li><p>主存系统的效率：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226366.png" alt="image-20200908220140783"></p></li><li><p>Cache 的基本结构<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226367.png" alt="image-20200908220551549"></p></li><li><p>Cache 的 读写 操作</p><ul><li>读<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226368.png" alt="image-20200908220613720"></li><li>写直达法（Write – through）：也叫写通过法，写操作时数据既写入Cache又写入主存，写操作时间就是访问主存的时间，Cache和主存一直保存一致，退出时，不需要对主存执行写操作，更新策略比较容易实现，但是可能对一个内存单元反复读写。</li><li>写回法（Write – back）:写操作时只把数据写入 Cache 而不写入主存，Cache和内存不会保证一致，当 Cache 数据被替换出去时才写回主存，写操作时间就是访问 Cache 的时间，Cache块退出时，被替换的块需写回主存，增加了Cache 的复杂性。当有多处理器共用一个Cache时可能一个块在多个处理器的Cache都有副本，需要保证一致性。</li></ul></li><li><p>主存的地址映射：近的采用直接映射，速度快，成本低，但是不灵活效率低。远的采用全相联映射，成本高，速度慢，但是效率高。直接和全相联是两个极端，组相联映射结合两种映射。</p><ul><li>直接映射：每个缓存块 i 可以和 若干 个 主存块 对应，每个主存块 j 只能和 一 个 缓存块 对应，i = j mod C。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226369.png" alt="image-20200908221534594"></li><li>全相联映射：主存 中的 任一块 可以映射到 缓存 中的 任一块<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226370.png" alt="image-20200908221451816"></li><li>组相联映射：某一主存块 j 按模 Q 映射到 缓存 的第 i 组中的 任一块，i = j mod Q。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226371.png" alt="image-20200908221858244"></li></ul></li><li><p>Cache替换算法</p><ul><li>先进先出 （ FIFO ）算法</li></ul><ol start="2"><li>近期最少使用（ LRU）算法</li></ol></li></ul><h3 id="4-4-硬磁盘存储器"><a href="#4-4-硬磁盘存储器" class="headerlink" title="4.4 硬磁盘存储器"></a>4.4 硬磁盘存储器</h3><ul><li><p>硬磁盘存储器结构<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226372.png" alt="image-20200908222507712"></p><ul><li>磁盘控制器：磁盘控制器是主机与磁盘驱动器之间的接口。接收主机发来的命令，转换成磁盘驱动器的控制命令，控制磁盘驱动器读写，实现主机和驱动器之间的数据格式转换。</li><li>磁盘驱动器：<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226373.png" alt="image-20200908222500458"></li></ul></li><li><p>磁盘的记录方式分两种：</p><ul><li>旧式—非分区记录方式（不同磁道扇区数相同），便于磁头管理，但是不利于空间利用，每个地方的访问数据速度一样，越里面数据越拥挤，位密度越高。 0 磁道被放在最外面，因为最低的存储密度带来了更高的可靠性。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226374.png" alt="2b245760ca388dfa2d1c589be6434cb8_b"></li><li>新式–分区记录（Zoned Recording）方式（不同磁道扇区数不同），方式空间利用率大大提高，但是不便于磁头移动管理。0 磁道也被放在最外面，因为外面的磁道访问速度会比内部的快，因此写入的方式是从外（最外圈为0号磁道）到内，先写满最外的磁道，接着再写里面的磁道。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226375.png" alt="92b146b9fc003bf0a54e5127143c4a8e_b"></li></ul></li><li><p>磁盘平均寻址时间：寻道时间 + 等待时间：</p><ul><li>寻道时间：找到磁道的时间叫做 寻址时间 seek time</li><li>等待时间：磁头悬停在特定磁道上，找到寻址扇区的时间叫做 旋转延时 rotational delay</li></ul></li></ul><h2 id="第-５章-输入输出系统"><a href="#第-５章-输入输出系统" class="headerlink" title="第 ５章 输入输出系统"></a>第 ５章 输入输出系统</h2><h3 id="5-1-I-O-设备"><a href="#5-1-I-O-设备" class="headerlink" title="5.1 I/O 设备"></a>5.1 I/O 设备</h3><ul><li><p>连接方式：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226376.png" alt="image-20200909175705327"></p><ul><li>辐射式连接：早期多采用分散连接，每台设备都配有一套，控制线路和一组信号线，不便于增删设备<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226377.png" alt="image-20200909180245357"></li><li>总线连接：多个接口共用地址线、数据线、控制线，便于增删设备<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226378.png" alt="image-20200909180238306"></li></ul></li><li><p>I/O 接口的基本组成：</p><ul><li>地址线：也叫设备选择线，用 设备选择电路识别是否被选中</li><li>命令线和状态线一起也叫控制线</li><li>设备状态标记：反映设备状态<ul><li>完成触发器 D</li><li>工作触发器 B</li><li>中断请求触发器 INTR</li><li>屏蔽触发器 MASK</li></ul></li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226379.png" alt="image-20200909175730719"></p></li><li><p>I/O 设备编址方式</p><ul><li> 统一编址，即把I/O端口当作内存单元对待，从整个内存空间中划出一个子空间给I/O端口，从整个内存空间中划出一个子空间给I/O端口，每一个I/O端口分配一个地址码，用访问存储器的指令对I/O端口进行操作。</li><li>不统一编址，I/O端口编址和存储器的编址相互独立，即I/O端口地址空间和存储器地址空间分开设置，互不影响。采用这种编址方式，对I/O端口的操作使用专门的输入/输出指令(I/O指令)。使用I/O指令，程序清晰，很容易看出是I/O操作还是存储器操作</li></ul></li><li><p>I/O设备与主机信息传送的控制方式：</p><ul><li><p>程序查询方式，CPU 和 I/O 串行工作，IO 准备时 CPU 踏步等待<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226380.png" alt="image-20200909174212868"></p></li><li><p>程序中断方式：CPU 不检查IO设备的状态，不用踏步等待IO准备就绪。而是IO设备就绪后发出中断请求再调用中断服务程序来处理IO，达到 CPU 和 I/O 部分的并行工作，但是调用中断服务时还是会中断现行程序。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226381.png" alt="image-20200909174606960"></p></li><li><p>DMA 方式：主存和 I/O 之间有一条直接数据通道，不需要中断现行程序，但是要占用总线一个或多个存储周期。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226382.png" alt="image-20200909174831841"></p></li><li><p>三种方式的 CPU 工作效率比较：I/O系统的自治能力与来越强，达到 CPU 和 I/O 部分的并行工作，DMA 使 I/O 与主存之间的传送不再通过 CPU。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226383.png" alt="image-20200909212239175"><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226384.png" alt="image-20200909174909609"></p></li></ul></li></ul><h3 id="5-2-程序中断方式"><a href="#5-2-程序中断方式" class="headerlink" title="5.2 程序中断方式"></a>5.2 程序中断方式</h3><ul><li><p>I/O 中断处理过程：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226385.png" alt="image-20200909210525281"></p></li><li><p>中断服务程序流程</p><ol><li>保护现场：<ul><li>程序断点的保护：中断隐指令完成</li><li>寄存器内容的保护：进栈指令</li></ul></li><li>中断服务：对不同的 I/O 设备具有不同内容的设备服务</li><li>恢复现场：出栈指令</li><li>中断返回：中断返回指令</li></ol></li><li><p>主程序和服务程序抢占 CPU：宏观 上 CPU 和 I/O 并行 工作，微观 上 CPU 中断现行程序 为 I/O 服务<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226386.png" alt="image-20200909211238020"></p></li></ul><h3 id="5-3-DMA"><a href="#5-3-DMA" class="headerlink" title="5.3 DMA"></a>5.3 DMA</h3><ul><li><p>DMA 与主存交换数据的三种方式：</p><ul><li>停止 CPU 访问主存，CPU 处于不工作状态或保持状态，未充分发挥 CPU 对主存的利用率<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226387.png" alt="image-20200909212316221"></li><li>周期挪用（或周期窃取）：若CPU 正在访存则等待。如果CPU 与 DMA同时请求访存，此时 CPU 将总线控制权让给 DMA。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226388.png" alt="image-20200909212446595"></li><li>DMA 与 CPU 交替访问：每一个 CPU 工作周期划分一段时间专供 DMA 访存，一段时间专供 CPU 访存，不需要 申请建立和归还 总线的使用权，但是不够灵活效率低。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226389.png" alt="image-20200909212641226"></li><li>DMA 接口</li></ul></li><li><p>DMA 接口功能： </p><ul><li> 向 CPU 申请 DMA 传送</li><li>处理总线 控制权的转交</li><li>管理 系统总线、 控制 数据传送</li><li>确定 数据传送的 首地址和长度，修正 传送过程中的数据 地址 和 长度</li><li>DMA 传送结束时， 给出操作完成信号</li></ul></li><li><p>DMA 接口组成：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226390.png" alt="image-20200909212900595"></p></li><li><p>DMA 传送过程：预处理、数据传送、后处理<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226391.png" alt="image-20200909214829999"></p><ul><li>预处理<ul><li>通过几条输入输出指令预置如下信息</li><li>通知 DMA 控制逻辑传送方向（入/ 出）</li><li>设备地址 DMA 的 DAR</li><li>主存地址 DMA 的 AR</li><li>传送字数 DMA 的 WC</li></ul></li><li>数据传送过程（输出为例）<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226392.png" alt="image-20200909214109836"></li><li>后处理：由中断服务程序完成，校验送入主存的数是否正确，是否继续用 DMA，测试传送过程是否正确，错则转诊断程序。</li></ul></li><li><p>DMA 接口与系统的连接方式</p><ul><li>具有公共请求线的 DMA 请求，可以类比总线的链式查询<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226393.png" alt="image-20200909215047587"></li><li>独立的 DMA 请求，可以类比总线的独立请求<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226394.png" alt="image-20200909215119474"></li></ul></li><li><p>DMA 接口的类型：</p><ul><li>选择型：在物理上连接多个设备但是在逻辑上只允许连接 一个设备<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226395.png" alt="image-20200909215227473"></li><li>多路型：在物理上连接多个设备但是逻辑上允许连接多个设备同时工作<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226396.png" alt="image-20200909215333506"><br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226397.png" alt="image-20200909215403490"></li></ul></li></ul><h2 id="第-６章-计算机的运算方法"><a href="#第-６章-计算机的运算方法" class="headerlink" title="第 ６章 计算机的运算方法"></a>第 ６章 计算机的运算方法</h2><h2 id="第-７章-指令系统"><a href="#第-７章-指令系统" class="headerlink" title="第 ７章 指令系统"></a>第 ７章 指令系统</h2><h3 id="7-1-操作码"><a href="#7-1-操作码" class="headerlink" title="7.1 操作码"></a>7.1 操作码</h3><ul><li>扩展操作码技术：操作码的位数随地址数的减少而增加，短操作码不能是长操作码的前缀，否则不能区分。高频指令用短操作码，低频指令用长操作码<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226398.png" alt="image-20200909222823202"></li></ul><h3 id="7-2-操作数"><a href="#7-2-操作数" class="headerlink" title="7.2 操作数"></a>7.2 操作数</h3><ul><li>数据在存储器中的存放方式<ul><li>从任意位置开始存储<ul><li>优点：不浪费存储资源</li><li>缺点：除了访问一个字节之外，访问其它任何类型的数据，都可能花费两个存储周期的时间。读写控制比较复杂。</li></ul></li><li>从一个存储字的起始位置开始访问：<ul><li>优点：无论访问何种类型的数据，在一个周期内<br>均可完成，读写控制简单。</li><li>缺点：浪费了宝贵的存储资源</li></ul></li><li>边界对准方式——数据 存放的起始地址是数据长度的整数倍，本方案是前两个方案的折衷，在一个周期内<br>可以完成存储访问，空间浪费也不太严重。</li></ul></li></ul><h3 id="7-3-寻址方式"><a href="#7-3-寻址方式" class="headerlink" title="7.3 寻址方式"></a>7.3 寻址方式</h3><ul><li>指令寻址:<ul><li>顺序：PC寄存器自动加“1”，为下条指令地址</li><li>跳跃：由转移指令指出</li></ul></li><li>数据寻址：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226399.png" alt="image-20200909220124934"><ul><li>立即寻址：形式地址 A 就是操作数，指令执行阶段不访存，A 的位数限制了立即数的范围</li><li>直接寻址：有效地址由形式地址直接给出，执行阶段访问一次存储器，A 的位数决定了该指令操作数的寻址范围，操作数的地址不易修改（必须修改A ）</li><li>隐含寻址：某些指令的一个操作数存放在哪个寄存器中已经规定好了，指令字中少了一个地址字段，可缩短指令字长</li><li>间接寻址：有效地址由形式地址间接提供，执行指令阶段 2 次访存</li><li>寄存器寻址：有效地址即为寄存器编号，执行阶段不访存，只访问寄存器，执行速度快</li><li>寄存器间接寻址：有效地址在寄存器中， 操作数在存储器中，执行阶段访存</li><li>基址寻址：将CPU中基址寄存器的内容，加上指令格式中的形式地址而形成操作数的有效地址。基址寄存器可以是专用的基址寄存器或者采用给出的某一个通用寄存器作基址寄存器。形式地址 A 可变，基址寄存器内容不变，一般由操作系统确定。</li><li>变址寻址：和基址寻址很类似。但是形式地址A不变，变址寄存器的内容可变。便于处理数组问题</li><li>相对寻址：程序计数器PC的当前值为基地址，指令中的形式地址A（可正可负，补码表示）作为偏移量， A 的位数决定操作数的寻址范围，广泛用于转移指令</li><li>堆栈寻址：执行push和pop指令后SP寄存器的 SP 的修改与主存编址方法有关，按字编址直接+1/-1就行，按字节编址的话和机器字长有关，机器字长为32时，+4/-4，机器字长为 64 时，+8/-8。</li></ul></li></ul><h3 id="7-4-CISC-和-RISC"><a href="#7-4-CISC-和-RISC" class="headerlink" title="7.4 CISC 和 RISC"></a>7.4 CISC 和 RISC</h3><ul><li><p>CISC 的主要特征：</p><ul><li>系统指令 复杂庞大，各种指令使用频度相差大 </li><li>指令 长度不固定、指令格式种类多、寻址方式多 </li><li>访存 指令 不受限制 </li><li>CPU 中设有 专用寄存器 </li><li>大多数指令需要 多个时钟周期 执行完毕 </li><li> 采用 微程序 控制器  </li></ul></li><li><p>二八定律：典型程序中 80% 的语句仅仅使，用处理机中 20% 的简单指令。执行频度高的简单指令，因复杂指令的存在，执行速度无法提高</p></li><li><p>RISC 的主要特征</p><ul><li>选用使用频度较高的一些 简单指令，复杂指令的功能由简单指令来组合</li><li>指令 长度固定、指令格式种类少、寻址方式少</li><li>只有 LOAD / STORE 指令访存</li><li>CPU 中有 多个 个 通用 寄存器</li><li>采用 流水技术 一个时钟周期 内完成一条指令</li><li>采用 组合逻辑 实现控制器</li></ul></li><li><p>RISC 和CISC 的比较</p><ol><li>RISC 更能 充分利用 VLSI 芯片 的面积</li><li>RISC 更能 提高计算机运算速度，指令数、指令格式、寻址方式少，，通用 寄存器多 ，采用 组合逻辑 ，便于实现 指令流水</li><li>RISC 便于设计 ，可 降低成本 ，提高 可靠性</li><li>RISC 不易 实现 指令系统兼容</li></ol></li><li><p>现代处理器的发展趋势是 RISC 与CISC相结合</p></li></ul><h2 id="第-８章-CPU-的结构和功能"><a href="#第-８章-CPU-的结构和功能" class="headerlink" title="第 ８章 CPU 的结构和功能"></a>第 ８章 CPU 的结构和功能</h2><h3 id="8-1-CPU-的结构"><a href="#8-1-CPU-的结构" class="headerlink" title="8.1 CPU 的结构"></a>8.1 CPU 的结构</h3><ul><li><p>CPU 的功能：</p><ul><li>取指令</li><li>分析指令</li><li>执行指令，发出各种操作命令</li><li>控制程序输入及结果的输出</li><li>总线管理</li><li>处理异常情况和特殊请求</li></ul></li><li><p>CPU 的结构：</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226400.png" alt="image-20200910193928343"></p></li><li><p>控制器的功能：产生全部指令的微操作命令序列。可以分为两类控制器：组合逻辑设计（硬连线逻辑），微程序设计（存储逻辑）。</p></li><li><p>运算器的功能：实现算术运算和逻辑运算</p></li><li><p>寄存器：</p><ul><li>用户可见寄存器：通用寄存器，数据寄存器， 地址寄存器，条件码寄存器</li><li>控制寄存器：控制 CPU 操作，MAR 、MDR 、IR </li><li>状态寄存器：存放条件码，存放程序状态字</li></ul></li></ul><h3 id="8-2-指-令-周-期"><a href="#8-2-指-令-周-期" class="headerlink" title="8.2 指 令 周 期"></a>8.2 指 令 周 期</h3><ul><li><p>指令周期：取出并执行一条指令所需的全部时间，不同的指令的指令周期通常不同。至少可以分为取指周期和执行周期，还可能存在间址周期和中断周期。</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226401.png" alt="image-20200910195632976"><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226402.png" alt="image-20200910195752936"></p><ul><li>取指周期：取指令、分析指令</li><li>间址周期：根据指令中的形式地址得到效地址</li><li>执行周期：根据不同指令发出各种操作命令</li><li>中断周期：处理中断请求</li></ul></li><li><p>取指周期数据流：</p><ol><li>PC 给出 指令地址并传送给 MAR，通过地址总线送给存储器</li><li>CU 发出读操作信号，通过控制总线传送给存储器</li><li>存储器执行读操作，将相应数据通过数据总线送到 MDR，然后再送给 IR</li><li>CU 控制 PC + 1，下一条指令地址保存在 PC 里为取下一条指令做准备</li></ol><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226403.png" alt="image-20200910200255021"></p></li></ul><ul><li><p>间址周期数据流：</p><ol><li>MDR 和 IR 都有 指令的副本，假设从MDR寄存器取出指令的形式地址码部分传送给 MAR ，再通过地址总线送给存储器</li><li>CU 发出读操作信号，通过控制总线传送给存储器</li><li>存储器执行读操作，将有效地址通过数据总线送到 MDR，然后再送给 IR 组装成最终指令。可能存储器返回的仍然是一个形式地址，则需要多次间址得到有效地址。</li></ol><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226404.png" alt="image-20200910201105697"></p></li><li><p>中断周期数据流<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226405.png" alt="image-20200909164707913"></p></li></ul><ol><li>CU 给出保存程序断点信息的的主存堆栈地址，通过MAR传给存储器，同时cu通过控制总线向存储器给出写命令</li><li>PC 中断点地址通过MDR寄存器传给存储器</li><li>CU给出中断服务程序入口地址，直接写入pc当中</li></ol><h3 id="8-3-指-令-流-水"><a href="#8-3-指-令-流-水" class="headerlink" title="8.3 指 令 流 水"></a>8.3 指 令 流 水</h3><ul><li><p>并行的概念</p><ul><li>并行：两个或两个以上事件在 同一时间段 发生</li><li>同时：两个或两个以上事件在 同一时刻 发生</li></ul></li><li><p>并行性的等级</p><ul><li>过程级（程序、进程），粗粒度 ，操作系统软件实现</li><li>指令级（指令之间）（指令内部），细粒度 ，硬件实现</li></ul></li><li><p>指令流水线结构（以6段流水为例）：完成一条指令分 6 段， 每段需一个时钟周期，每个周期结束后需要锁存器将结果保存然后执行下一条指令中的该段操作，理想情况下，6 级流水 的速度是不采用流水技术的6 倍</p><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226406.png" alt="image-20200910204046627"></p></li><li><p>指令流水原理：指令的串行执行总有一个部件 空闲，以二级流水为例， 若 取指 和 执行 阶段时间上 完全重叠并行，理想情况指令周期 减半，速度提高 1 倍 。</p></li><li><p>影响指令流水效率和性能的因素：</p><ul><li>复杂指令的执行时间可能大于取指时间，可以在取指令部件和执行指令部件中添加一个缓冲区。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226407.png" alt="image-20200910202147824"></li><li>控制冲突：条件转移指令对指令流水的影响有很大的影响，因为之前的指令可能更改了标志寄存器的值，影响条件判断的结果，所以必须等 上条 指令执行结束，才能确定 下条 指令的地址，可能使流水线断流，不能充满指令，用分支预测和冒险来减少时间损失。</li><li>资源冲突：不同指令争用同一功能部件产生资源冲突，解决办法：指令存储器和数据存储器分开，指令预取技术 （适用于访存周期短的情况）</li><li>数据冲突：不同指令因重叠操作，可能改变操作数的 读/ 写 访问顺序，解决办法：后推法和旁路技术</li></ul></li><li><p>流水线性能：</p></li></ul><ul><li><p>吞吐率：单位时间内 流水线所完成指令 或 输出结果 的 数量</p><p>  ![image-20200910202936151](计算机组成原理 images\image-20200910202936151.png)<br>  ![image-20200910202740337](计算机组成原理 images\image-20200910202740337.png)</p></li><li><p>加速比 ：m 段的 流水线的速度 与等功能的 非流水线的速度 之比<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226408.png" alt="image-20200910202806693"></p></li><li><p>效率：流水线中各功能段的 利用率，值等于加速比除以m<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226409.png" alt="image-20200910203305515"></p></li><li><p>流水线的多发技术：</p><ul><li>超标量技术：每个时钟周期内可 并发多条独立指令，通过编译优化技术，把可并行执行的指令搭配起来<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226410.png" alt="image-20200910203446268"></li><li>超流水线技术：在 一个时钟周期内再分段 ，在一个时钟周期内 一个功能部件使用多次，也是靠编译程序解决优化问题<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226411.png" alt="image-20200910203531624"></li><li>超长指令字技术：由编译程序 挖掘 出指令间 潜在 的 并行性， 将多条能并行操作 的指令组合成一条具有多个操作码字段的超长指令字 </li><li><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226412.png" alt="image-20200910203632390"></li></ul></li><li><p>运算器也可以采用分段流水线，例如完成浮点加减运算 可分对阶、尾数求和、规格化 三段，分段原则：每段 操作时间 尽量 一致<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226414.png" alt="image-20200910204214331"></p></li></ul><h3 id="8-4-中断系统"><a href="#8-4-中断系统" class="headerlink" title="8.4 中断系统"></a>8.4 中断系统</h3><ul><li><p>引起中断的各种因素：</p><ul><li>人为设置的中断,如 转管指令</li><li>程序性事故,如 溢出、操作码不能识别、除法非法</li><li>硬件故障</li><li>I/O 设备中断申请</li><li>外部事件,用键盘中断 现行程序</li></ul></li><li><p>中断请求标记</p><ul><li>一个请求源，INTR 分散 在各个中断源的 接口电路中</li><li>多个INTR组成中断请求标记寄存器，集中 在 CPU 的中断系统 内</li></ul></li><li><p>中断判优逻辑</p><ul><li>硬件实现（排队器）：链式排队器或者集中 在 CPU 内<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226415.png" alt="image-20200910205216265"></li><li>软件实现（程序查询）<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226416.png" alt="image-20200910205230083"></li></ul></li><li><p>中断服务程序入口地址的寻找：</p><ul><li>硬件向量法：通过一个硬件产生一个地址指向一个跳转指令，或者直接在该存储字中存放中断服务程序入口地址<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226417.png" alt="image-20200910205332171"></li><li>软件查询法：编写一组中断识别程序实现地址跳转</li></ul></li><li><p>中断响应：</p><ul><li>响应中断的前提条件：允许中断触发器 EINT = 1</li><li>响应中断的时间：指令执行周期结束时刻由CPU 发查询信号看是否有中断，有则进入中断周期。除了少数指令特别复杂的机器，指令执行时间比较长，为了及时处理异常时间，允许 CPU 在执行指令的过程中响应中断</li></ul></li><li><p>中断隐指令：隐指令并不是指令集中的一条指令，虽然操作由硬件完成，但并不是在某一条具体指令的驱动下，而是在响应中断的时候自动执行</p><ol><li>保护程序断点：断点存于 特定地址（ 0 号地址，这里的 0 号地址并不是真正主存物理地址） 内或者断点地址 进栈</li><li>寻找服务程序入口地址：硬件向量法和软件查询法</li><li>硬件关中断：单重 中断：执行中断服务程序时不允许再发生中断</li></ol></li><li><p>中断流程</p><ul><li>保护现场<ul><li>程序断点由中断隐指令完成保存</li><li>保存寄存器内容不同的中断服务程序 完成</li></ul></li><li>其它服务程序：对不同的中断类型有不同的服务程序</li><li>恢复现场：中断服务程序 完成</li><li>中断返回：IRET 指令</li></ul></li><li><p>单重中断和多重中断：</p><ul><li>单重中断：不允许中断 现行的 中断服务程序</li><li>多重中断：提前 设置 开中断 指令，允许级别更高 的中断源中断现行的中断服务程序，即中断可以嵌套，但是保护程序软硬件状态的过程中，不允许发生中断</li></ul><p><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226418.png" alt="image-20200909211104631"></p></li><li><p>多重中断中的屏蔽技术：通过重新设置屏蔽字（中断源屏蔽触发器的值的序列）可改变处理优先等级，但是响应优先级不可以改变，还是依据中断判优逻辑（排队器或者查询程序的顺序）。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226419.png" alt="image-20200910212332296"></p><p>下图：响应优先级 A→B→C→D 降序排列，A、B、C、D同时请求中断，先响应A，A不可被BCD中断。处理完A 后，BCD同时请求中断，B响应优先级最高，响应B，执行B的过程CD优先级高于B没有被屏蔽，CD可以提出中断请求并判优C更高，响应C。<img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226420.png" alt="image-20200910212027581"></p></li></ul><h2 id="第-９章-控制单元的功能"><a href="#第-９章-控制单元的功能" class="headerlink" title="第 ９章 控制单元的功能"></a>第 ９章 控制单元的功能</h2><h3 id="9-1-微操作命令的分析"><a href="#9-1-微操作命令的分析" class="headerlink" title="9.1 微操作命令的分析"></a>9.1 微操作命令的分析</h3><ul><li><p>一条机器指令在取址、执行过周期又可以划分为几个微操作命令，一个时钟周期（一个节拍）CU 可以产生一个或几个微操作命令，只要这几个微操作命令可以并行不冲突在一个周期内完成。下面给出执行周期中的微指令，取址，间址，中断周期参考 8.2 指令周期。</p></li><li><p>执行周期</p><ul><li>非访存指令<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226421.png" alt="image-20200910214757482"></li><li>访存指令<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226422.png" alt="image-20200910214828731"></li><li>转移指令：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226423.png" alt="image-20200910214839716"></li></ul></li><li><p>三类指令的指令周期：取指周期、间址周期和中断周期，所有指令都做了相同的工作，取址阶段 pc 就已经+1  ，执行阶段不需要在+1<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226424.png" alt="image-20200910214858311"></p></li></ul><h3 id="9-2-控制单元的功能"><a href="#9-2-控制单元的功能" class="headerlink" title="9.2 控制单元的功能"></a>9.2 控制单元的功能</h3><ul><li><p>控制单元的外特性</p><ul><li>输入信号：<ul><li>时钟：CU 受时钟控制，一个时钟脉冲，发一个操作命令或一组需同时执行的操作命令</li><li>指令寄存器：控制信号与指令操作器中操作码部分有关</li><li>标志：CU 受标志寄存器</li><li>外来信号：来自系统总线的控制信号，如INTR 中断请求，HRQ 总线请求</li></ul></li><li>输出信号：<ul><li>CPU 内的各种控制信号：寄存器之间的内容传送，PC寄存器+“1”，ALU控制信号</li><li>送至控制总线的信号：访存控制信号MREQ、访 IO / 存储器的控制信号IO/M、读命令RD、写命令WR、中断响应信号INTA、总线响应信号HLDA</li></ul></li></ul></li><li><p>机器周期：所有指令执行过程中的一个基准时间，一般以完成 最复杂 指令功能的时间 为准， 因为访存占了通常占了周期绝大部分时间，可以访问一次存储器 的时间为基准 。若指令字长 = 存储字长，取指周期 = 机器周期</p></li><li><p>时钟周期 （节拍、状态）：时钟周期是控制计算机操作的最小单位时间，一个时钟周期（一个节拍）可以产生一个或几个微操作命令，只要这几个微操作命令可以并行不冲突。</p></li><li><p>多级时序系统：机器周期、节拍（状态）组成多级时序系统，一个指令周期包含若干个机器周期，一个机器周期包含若干个时钟周期。只有时钟周期是绝对相等的。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226425.png" alt="image-20200910221305112"></p></li><li><p>机器速度与机器主频的关系：在指令周期所含机器周期数相同,机器周期所含时钟周期数相同 的前提下，两机 平均指令执行速度之比 等于 两机主频之比</p></li></ul><h2 id="第10章-控制单元的设计"><a href="#第10章-控制单元的设计" class="headerlink" title="第10章 控制单元的设计"></a>第10章 控制单元的设计</h2><h3 id="10-1-组合逻辑设计"><a href="#10-1-组合逻辑设计" class="headerlink" title="10.1 组合逻辑设计"></a>10.1 组合逻辑设计</h3><h3 id="10-2-微程序设计"><a href="#10-2-微程序设计" class="headerlink" title="10.2 微程序设计"></a>10.2 微程序设计</h3><ul><li><p>存储逻辑：一条机器指令对应一个微程序,一个微程序包含了若干条微指令，每一条微指令包含了一个或者多个微操作的控制信号，微指令的先后顺序就是微操作的先后顺序。将这些微指令组成的微程序保存在 ROM 中。执行时 CU 把微指令一条一条从 ROM 读出，操作控制字段中每一个位对应的微操作是确定的，根据读出微指令中有效控制信号的个数和位置发出控制信号，进而执行相应操作。<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226426.png" alt="image-20200911220939978"></p></li><li><p>微地址形成部件：根据取来的机器指令的操作码形成这条指令对应的微程序在控制存储器中的位置</p></li><li><p>微指令格式：</p><ul><li>水平型微指令，一次能定义并执行多个并行操作</li><li>垂直型微指令，类似机器指令操作码 的方式，由微操作码字段规定微指令的功能</li></ul></li><li><p>微程序控制单元：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226427.png" alt="image-20200911221651608"></p></li><li><p>微指令序列地址的形成方式：<br><img src="https://kiku-blogpic.oss-cn-shenzhen.aliyuncs.com/img/202110192226428.png" alt="image-20200911221556016"></p><ol><li>微指令的 下地址字段 指出</li><li>根据机器指令的 操作码 形成</li><li>增量计数器</li><li>分支转移，微指令给出转移方式和转移地址，转移方式 指明判别条件，转移地址 指明转移成功后的去向</li><li>由硬件产生微程序入口地址，第一条微指令地址 由专门 硬件 产生，中断周期 由 硬件 产生 中断周期微程序首地址</li></ol></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>  ﻿<a href="https://www.bilibili.com/video/BV1c4411d7jb">计算机组成原理（哈工大刘宏伟）</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>自学笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
