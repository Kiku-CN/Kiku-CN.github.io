

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#515151">
  <meta name="description" content="">
  <meta name="author" content="Kiku">
  <meta name="keywords" content="个人 博客 技术 分享 日记 笔记 学习 文章 教程 指南 程序员">
  <title>Java 设计模式学习笔记 - Kiku 的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/vs.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":90,"cursorChar":"▁","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":"d3e02bccada8177079a692ffc4daabf8","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kiku</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/404.html">
                <i class="iconfont icon-pen"></i>
                留言板
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/404.html">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201040812449.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java 设计模式学习笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-30 21:35" pubdate>
        2020年12月30日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      20.1k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    
	
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java 设计模式学习笔记</h1>
            
            <div class="markdown-body">
              <p>这学期上了设计模式的专业课，感觉是迄今在校上过的对自己代码能力提升最有帮助的专业课了。感谢开设这门课的王老师——在大学生涯中碰到的为数不多对教学充满热情、认真对待的老师之一，让我领略到设计模式的魅力。</p>
<p>笔记的目录结构参考了 B 站上李建忠老师的 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kW411P7KS">C++ 设计模式</a>视频中所讲授的顺序。除了第一二三章外，绝大部分文字和图片摘录于本学期老师指定的设计模式教材 <a target="_blank" rel="noopener" href="https://blog.csdn.net/LoveLion/article/details/79602149">《Java 设计模式》</a>以及配套的 PPT 教学课件。</p>
<p>个人不建议没接触过设计模式的直接从李建忠老师的视频入门，李老师的课程更适合之前学过设计模式的人用来复习。前两节课入门听一听还是可以的，到后面举例和代码越来越少，没有实际的应用场景很难真正理解模式的真正意义。可以先看看其他书籍或视频，多写一些代码，再来看这个就别有一番滋味了。书籍推荐上面提到的王伟的《Java 设计模式》，书中有很好的设计模式应用场景举例，配合给的 Java 代码实现，理解起来轻松多了。网上有免费的电子版，感兴趣的可以去搜搜看。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>设计模式：前人总结的可以解决特定问题的一套模式也就是模版。</p>
<blockquote>
<p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。——Christopher Alexander</p>
</blockquote>
<p>历史性著作《设计模式：可复用面向对象软件的基础》一书中描述了23种经典面向对象设计模式，创立了模式在软件设计中的地位。</p>
<p>由于《设计模式》一书确定了设计模式的地位，通常所说的设计模式隐含地表示“面向对象设计模式”。但这并不意味“设计模式”就等于“面向对象设计模式”。</p>
<p>编程的两种思维模式：</p>
<ul>
<li>底层思维：向下，如何把握机器底层从微观理解对象构造，关注于语言构造、编译转换、内存模型、运行时机制</li>
<li>抽象思维：向上，如何将我们的周围世界抽象为程序代码，面向对象、组件封装、设计模式、架构模式。</li>
</ul>
<p>软件设计复杂的根本原因是要面对各种各样的变化：客户需求的变化、技术平台的变化、开发团队的变化、市场环境的变化。</p>
<blockquote>
<p>建筑商从来不会去想给一栋已建好的 100 层高的楼房底下再新修一个小地下室——这样做花费极大而且注定要失败。然而令人惊奇的是，软件系统的用户在要求作出类似改变时却不会仔细考虑，而且他们认为这只是需要简单编程的事。——《Object-Oriented Analysis and Design with Applications》</p>
</blockquote>
<p>解决复杂性通常有两种思路：</p>
<ul>
<li>分解：人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。例如常见的结构化设计语言：C 语言。分而治之不容易复用，但出现新的变化时针往往要修改已有的代码来应对变化。</li>
<li>抽象：更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。即忽略具体实现，归纳总结提取一类事物的共性。</li>
</ul>
<p>使用了面向对象的机制并不代表就是一个好的面向对象设计，好的软件设计的标准是复用，复用性越高，说明越是一个好的软件设计。所谓“好的面向对象设计”指是那些可以满足 “应对变化，提高复用”的设计 。</p>
<h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><h3 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h3><p>对象是什么？</p>
<ul>
<li>从语言实现层面来看，对象封装了代码和数据。</li>
<li>从规格层面讲，对象是一系列可被使用的公共接口。</li>
<li>从概念层面讲，对象是某种拥有责任的抽象。</li>
</ul>
<p>面向对象三大机制：</p>
<ul>
<li>封装（Encapsulation）：隐藏内部实现，将对象的状态和行为捆绑到一个单一逻辑单元机制。封装并不是面向对象语言（OOPL）独有, 但面向对象的封装更加完美。封装代码和数据的本质是封装变化点，使得一侧变化一侧稳定。使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li>
<li>继承（Inheritance）：复用现有代码，子类自动共享父类数据结构和方法，通过继承可以不加修改地重用和扩展已经测试的代码。即使没有已有类的源代码，仍然可以从已有的类中派生出新类。编译单位级别的复用而不是源代码片段级的复用可以显著地减少代码冗余，提高代码质量，减轻维护代码的负担。</li>
<li>多态（Polymorphism）：改写对象行为，允许不同类的对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。</li>
</ul>
<h3 id="类重用的方式"><a href="#类重用的方式" class="headerlink" title="类重用的方式"></a>类重用的方式</h3><p>类间的六种重用方法的耦合性由弱到强分别是：依赖 &lt; （普通）关联 &lt; 聚合 &lt; 组合 &lt; 实现 = 泛化。优先使用耦合度较低的依赖和关联，少用继承。在 UML 类图中的六种关系的表示如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000215.png" srcset="/img/loading.gif" alt="img"></p>
<p>下图对其中的五种类关系进行了举例，更详细的说明可以移步我的另一篇博客：<a target="_blank" rel="noopener" href="https://kiku.vip/2020/12/19/UMLClassDiagram/">UML 中的类图</a>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000217.png" srcset="/img/loading.gif" alt="image-20201213084132558"></p>
<h3 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h3><p>单一职责原则（Single Responsibility Principle，SRP）</p>
<ul>
<li>一个类应该仅有一个引起它变化的原因，变化的方向隐含着类的责任。</li>
<li>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</li>
</ul>
<p>开放封闭原则（Open-Closed Principle，OCP）</p>
<ul>
<li> 对扩展开放，对更改封闭。</li>
<li> 类模块应该是可扩展的，但是不可修改。</li>
<li> 需求变更时，不应该尝试去更改已有的模块，而是去增加一些模块来应对变化。</li>
</ul>
<p>里氏替换原则（Liskov Substitution Principle，LSP）</p>
<ul>
<li> 所有引用基类的地方必须能透明地使用其子类的对象。</li>
<li> 子类必须能够替换它们的基类（is-a）。</li>
<li> 继承表达类型抽象。</li>
<li> 如果继承是为扩展，子类只能通过新添加方法来扩展功能，而不是覆写父类中的具体方法，否则当子类对象将父类对象替换掉时，程序逻辑可能发生改变。</li>
<li> 如果继承是为了多态，不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承，这样父类是不可实例化的，也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。</li>
</ul>
<p>依赖倒置原则（Dependence Inversion Principle，DIP）</p>
<ul>
<li><p>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。高层模块应该是稳定的，底层模块是容易根据需求功能发生变化的，高层模块如果依赖于变化的底层模块，则高层模块也变得不稳定，要经常去修改。<br><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000218.png" srcset="/img/loading.gif" alt="image-20200918222855319"></p>
</li>
<li><p>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。即在抽象类中不应该使用和子类细节相关的属性和方法。</p>
</li>
<li><p>针对抽象层（接口或抽象类）编程，而不是针对实现编程。在函数的形参列表中或者关联关系中尽量引用抽象类。即不将变量类型声明为某个特定的具体类，而是声明为某个接口或者抽象类。客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。具体类的对象实例通过依赖注入（Dependence Injection）的方式注入到其他对象的函数中，具体可以分为构造注入、设值注入、接口注入。</p>
</li>
<li><p>开闭原则是目标，里氏替换原则是基础，依赖倒转原则是手段。</p>
</li>
</ul>
<p>接口隔离原则（Interface Segregation Principle，ISP）</p>
<ul>
<li>不应该强迫客户程序依赖它们不用的方法。应该使用适当的修饰符控制接口中方法和变量的可见性，使用该接口的客户端仅需知道与之相关的方法和变量即可。</li>
<li>接口应该小而完备。当一个接口太大时，需要将它分割成一些更细小的接口；每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</li>
<li>接口标准化是软件从其他行业，例如制造业，建筑业借鉴过来的经验，接口的标准化，也是一个行业成熟强盛的标志。</li>
</ul>
<p>合成复用原则（Composite Reuse Principle，CRP）</p>
<ul>
<li>优先使用对象组合达到复用的目的，而不是类继承。</li>
<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。</li>
<li>继承在某种程度上破坏了封装性，子类父类耦合度高。而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li>
<li>继承是类属关系，组合是对象关系，只有在两个类直接具有明确的类属关系的时候才能用继承。</li>
</ul>
<p>迪米特法则（Law of Demeter，LoD）</p>
<ul>
<li>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。又称为最少知识原则(Least Knowledge Principle, LKP)</li>
<li>不要和陌生人说话，只与朋友（密切相关的对象）通信，</li>
<li>应当尽可能少地与其他实体发生相互作用，减少对象之间的交互，不必通信则不应该通信，如果必须通信，可以通过第三方转发通信，降低耦合。</li>
<li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案，耦合度越低，越利于复用。</li>
</ul>
<h3 id="三种粒度的软件设计经验"><a href="#三种粒度的软件设计经验" class="headerlink" title="三种粒度的软件设计经验"></a>三种粒度的软件设计经验</h3><ul>
<li>设计习语（Design Idioms）：描述与特定编程语言相关的低层模式，技巧，惯用法。</li>
<li>设计模式（Design Patterns）：主要描述的是“类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式等方面。</li>
<li>架构模式（Architectural Patterns）：描述系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。</li>
</ul>
<p>设计模式解决的是设计思想的复用性，并不针对具体的编程语言。软件体系结构则是构件层面的复用，粒度更大。</p>
<h2 id="设计模式的定义与分类"><a href="#设计模式的定义与分类" class="headerlink" title="设计模式的定义与分类"></a>设计模式的定义与分类</h2><h3 id="设计模式定义"><a href="#设计模式定义" class="headerlink" title="设计模式定义"></a>设计模式定义</h3><p>GoF（Gang of Four，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides，四位作者的被合称为”四人组“）1995 年在他们的著作《设计模式：可复用面向对象软件的基础》中对设计模式是这样定义的：设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定制的解决方案，该方案描述了对象和类之间的相互作用。</p>
<blockquote>
<p>Design patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>设计模式也可以理解为设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。简单说就是前人总结的可以解决特定问题的一套模式也就是模版。</p>
<p>设计模式的基本要素：</p>
<ul>
<li>模式名称 (Pattern Name) </li>
<li>问题 (Problem) </li>
<li>解决方案 (Solution) </li>
<li>效果 (Consequences) </li>
</ul>
<h3 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h3><p>设计模式传统按照目的和范围分类。</p>
<p>根据目的划分：</p>
<ul>
<li>创建型（Creational）模式：将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击。</li>
<li>结构型（Structural）模式：通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。</li>
<li>行为型（Behavioral）模式：通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。</li>
</ul>
<p>根据范围划分：</p>
<ul>
<li>类模式：处理类和子类之间的静态关系，这些关系通过继承建立，在编译时刻就被确定下来，是一种静态关系</li>
<li>对象模式：处理对象间的动态关系，这些关系在运行时变化，更具动态性</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000219.png" srcset="/img/loading.gif" alt="image-20201213090054431"></p>
<p>李建忠老师提出一种从封装变化角度对模式分类的方法：<br><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000220.png" srcset="/img/loading.gif" alt="image-20201213090302933"></p>
<h3 id="模式的使用"><a href="#模式的使用" class="headerlink" title="模式的使用"></a>模式的使用</h3><p>现代软件设计的特征是需求的频繁变化。设计模式的要点是寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化。什么时候、什么地点应用设计模式比理解设计模式结构本身更为重要。</p>
<p>设计模式的宗旨是管理变化，提高复用性。设计模式不是把变化消灭了，而是把变化点和稳定点解耦合，然后将变化点转移集中到某一个或几个类中，来更好地应对变化。例如通过 Java 的反射机制配合配置文件可以方便地替换加载不同的类。</p>
<p>假设一种极端情况，软件中的所有都在变化，那么没有一种设计模式能解决问题。反之如果软件所有部分都是稳定的，没有变坏点，那么也没必要使用设计模式。绝大多数软件则是既有稳定的一部分，也有变化的一部分。通常 Framework 的开发人员对设计模式的理解要求更高，因为 Framework 往往要给 Application 开发者预留下很多接口和扩展点应应对将来可能的变化。</p>
<p>不要拘泥于 GOF 提出的 23 种设计模式，代码只要符合设计原则，解决耦合性问题，提高了复用性，就可以把它当做是一种模式的应用。</p>
<p>在什么时候不应该使用设计模式：</p>
<ul>
<li>代码可读性很差时，先提高代码可读性。</li>
<li>需求理解还很浅时，先搭建一个快速原型版本了解用户需求，再在后续的迭代中使用设计模式。</li>
<li>变化没有显现时，不要过度使用设计模式去预测变化。</li>
<li>不是系统过的关键依赖点，优先在关键依赖点使用模式。</li>
<li>项目没有复用价值时，典型的就是一些外包软件，甲方没有后期的软件升级迭代计划，就没有去使用设计模式的价值。反之，如果是自己公司的软件产品，前期使用好的设计模式能够大大减少后期需求变更时的工作量。</li>
<li>项目将要发布时，使用模式重构可能给项目带来新的 Bug。</li>
</ul>
<h3 id="重构到模式"><a href="#重构到模式" class="headerlink" title="重构到模式"></a>重构到模式</h3><p>设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的“Refactoring to Patterns”是目前普遍公认的最好的使用设计模式的方法。</p>
<p>重构获得模式（Refactoring to Patterns）：审视现有代码违反了哪些设计原则，在重构软件的过程中改善现有设计，一步步迭代到设计模式。良好的设计模式是演化的结果，不要追求一步到位，除非你是一个设计模式大师。</p>
<p>可以从下面 5 个重构的关键技法考虑优化代码的可能性：</p>
<ul>
<li>静态 → 动态</li>
<li>早绑定 → 晚绑定</li>
<li>继承 → 组合</li>
<li>编译时依赖 → 运行时依赖</li>
<li>紧耦合 → 松耦合</li>
</ul>
<h2 id="组件协作模式"><a href="#组件协作模式" class="headerlink" title="组件协作模式"></a>组件协作模式</h2><p>现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。通过组件协作模式，我们可以调用这些第三方库或框架，补充上特定的上层应用业务代码，就可以快速搭建出产品，而不用去造底层的轮子。</p>
<h3 id="模板方法-Template-Method"><a href="#模板方法-Template-Method" class="headerlink" title="模板方法 Template Method"></a>模板方法 Template Method</h3><p>模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<blockquote>
<p>Template Method Pattern: Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>某个算法框架由很多基本方法 （Primitive Method）组成，在抽象的父类中提供一个称之为模板方法（Template Method）的方法来定义这些基本方法的执行次序，而通过其子类来覆盖重写（override）某些步骤，从而使得相同的算法框架可以有不同的执行结果。</p>
<p>被模板调用的基本方法可以是具体方法（Concrete Method），空实现的钩子方法（Hook Method，钩子方法通常返回一个 <code>boolean</code> 类型的值，并以此来判断是否执行某一基本方法，因此在子类中可以通过覆盖钩子方法来决定是否执行父类中的某一方法，从而实现子类对父类行为的控制。），也可以是没有任何实现的抽象方法(Abstract Method)，一般推荐将它们设置为 <code>protected</code> 方法，因为这些方法通常只会让子类来重写才有意义，而不直接提供对外访问。</p>
<p>动机：在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p>
<p>应用实例：“不要调用我，让我来调用你”的反向控制结构（Inverse of Control：Don’t call me, Let me call you.）是 Template Method 的典型应用。在早期应用程序开发者往往会写一个程序主流程来调用早已经写好的库和框架中的方法（早绑定）。而现在很多框架则是根据写好的模板方法的流程来调用应用程序开发者对基本方法的实现或者覆写（晚绑定）。这样应用程序开发者将程序的流程控制权还给框架，让框架来调用自己写的应用程序中的方法，而不是自己写程序去主动调用框架中的方法。但这样可能会让应用程序开发者只见树木，不见森林，看不到框架中调用方法的步骤和细节，所以必要时还是需要阅读框架源码查看底层细节。</p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000221.png" srcset="/img/loading.gif" alt="image-20201213094249455"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span> </span>&#123;<br>    <span class="hljs-comment">//模板方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        primitiveOperation1();<br>        primitiveOperation2();<br>        primitiveOperation3();<br>&#125;<br><br>    <span class="hljs-comment">//基本方法—具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">primitiveOperation1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//实现代码</span><br>    &#125;<br><br>    <span class="hljs-comment">//基本方法—抽象方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">primitiveOperation2</span><span class="hljs-params">()</span></span>;    <br><br>    <span class="hljs-comment">//基本方法—钩子方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">primitiveOperation3</span><span class="hljs-params">()</span>   </span><br><span class="hljs-function">    </span>&#123;  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 Strategy"></a>策略模式 Strategy</h3><p>策略模式：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它的客户变化。</p>
<blockquote>
<p>Strategy Pattern: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>策略模式又被称为政策（Policy）模式，每一个封装算法的类称之为策略（Strategy）类，策略模式提供了一种可插入式（Pluggable）算法的实现方案，同过传入不同的实现策略接口的对象，为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。通常上下文可以共享同一个 Strategy 对象，结合单例模式可以节省对象开销。</p>
<p>动机：在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都硬编码（Hard Coding）到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担（因为要白白执行很多判断语句）。</p>
<p>应用实例：当实现某个目标的算法不止一条，例如排序、查找、折扣计算等，使用策略模式可以在运行时方便地根据需要在各个算法之间进行切换。当含有大量嵌套的像 <code>if-else</code> 或者 <code>switch-case</code> 条件判断语句的代码通常往往都要考虑都需 Strategy 模式来消除条件判断语句解耦合。但是如果是性别和星期这种绝对稳定不变，没有变化可能的就不需要使用策略模式。</p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000222.png" srcset="/img/loading.gif" alt="image-20201214220657032"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象策略类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//声明抽象算法</span><br>&#125;<br><span class="hljs-comment">//具体策略类A</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span> </span>&#123;<br>    <span class="hljs-comment">//算法的具体实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//算法A</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体策略类A</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span> </span>&#123;<br>    <span class="hljs-comment">//算法的具体实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//算法B</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//上下文环境类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Strategy strategy; <span class="hljs-comment">//维持一个对抽象策略类的引用</span><br><br>    <span class="hljs-comment">//注入策略对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStrategy</span><span class="hljs-params">(Strategy strategy)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.strategy= strategy;<br>    &#125;<br><br>    <span class="hljs-comment">//调用策略类中的算法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">algorithm</span><span class="hljs-params">()</span> </span>&#123;<br>        strategy.algorithm();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式 Observer"></a>观察者模式 Observer</h3><p>观察者模式：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。</p>
<blockquote>
<p>Observer Pattern: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>观察者模式又被称为发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式、从属者（Dependents）模式。</p>
<p>定义了对象之间一种一对多的依赖关系，让一个对象的改变能够影响其他对象。发生改变的对象称为观察目标，被通知的对象称为观察者。一个观察目标可以对应多个观察者，观察目标发送通知时，无需指定观察者，通知会自动传播。观察者自己决定是否需要订阅通知，目标对象对此一无所知。</p>
<p>动机：在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。</p>
<p>应用实例：</p>
<ul>
<li>网上商店中商品在名称、价格等发生变化，系统自动通知收藏该商品的会员。</li>
<li>基于事件的 UI 框架。</li>
<li>在传统的 MVC（Model-View-Controller）模式中，模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者，当模型层的数据发生改变时，视图层将自动改变其显示内容。</li>
<li>JDK 中 <code>java.util.Observer</code>、<code>java.util.Observable</code> 这两个类提供 Java 对观察者模式的支持：</li>
</ul>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000223.png" srcset="/img/loading.gif" alt="image-20201214223247310"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象目标类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-comment">//定义一个观察者集合用于存储所有观察者对象</span><br>    <span class="hljs-keyword">protected</span> ArrayList observers&lt;Observer&gt; = <span class="hljs-keyword">new</span> ArrayList();<br><br>    <span class="hljs-comment">//注册方法，用于向观察者集合中增加一个观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        observers.add(observer);<br>    &#125;<br><br>    <span class="hljs-comment">//注销方法，用于在观察者集合中删除一个观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        observers.remove(observer);<br>    &#125;<br><br>    <span class="hljs-comment">//声明抽象通知方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体目标类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-comment">//实现通知方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//遍历观察者集合，调用每一个观察者的响应方法</span><br>        <span class="hljs-keyword">for</span>(Object obs:observers) &#123;<br>            ((Observer)obs).update();<br>        &#125;<br>    &#125;	<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h2><p>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。</p>
<h3 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 Decorator"></a>装饰模式 Decorator</h3><p>装饰模式：动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。</p>
<blockquote>
<p>Decorator Pattern: Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>装饰模式通过一种无须定义子类的方式给对象动态增加职责，采用组合而非继承的手法，在不改变一个对象本身功能的基础上给对象增加额外的新行为，是一种用于替代继承的技术。Decorator 模式实现了在运行时<br>动态扩展对象功能的能力，而且可以根据需要扩展多个功能。在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能。Decorator 类在接口上表现为 is-a Component 的继承关系，即 Decorator 类继承了 Component 类所具有的接口。但在实现上又表现为 has-a Component 的组合关系，即 Decorator 类又关联了一个 Component 对象。</p>
<p>透明（Transparent）装饰模式：要求客户端完全针对抽象编程，不将对象的引用声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别，可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象，但是无法在客户端单独调用装饰类里面的新增方法。</p>
<p>半透明（Semi-transparent）装饰模式：用具体装饰类型来声明装饰之后的对象，而具体构件使用抽象构件类型来声明。对于客户端而言，具体构件类型无须关心，是透明的，但是具体装饰类型必须指定，这是不透明的。可以单独调用装饰类里面的新增方法，但是不能如果对用一个对象的多次装饰，只能调用到最后一次装饰时具体装饰类中新增加的方法，无法调用到之前装饰时新增的方法。</p>
<p>动机：在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p>
<p>应用实例：当一个类既继承某一个类又聚合了这个类的对象，并且存在一个以这个类的对象为参数的构造方法，往往就使用到了装饰模式。Java 的 I/O 中使用装饰模式来为输入和输出字符流添加期望的功能。嵌套地调用构造方法也是使用到装饰模式的显著特征：<code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in))</code>.。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000224.png" srcset="/img/loading.gif" alt="image-20201215110448194"></p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000225.png" srcset="/img/loading.gif" alt="image-20201214225133922"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Component component; <span class="hljs-comment">//维持一个对抽象构件对象的引用</span><br><br>    <span class="hljs-comment">//注入一个抽象构件类型的对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Decorator</span><span class="hljs-params">(Component component)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.component=component;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        component.operation();  <span class="hljs-comment">//调用原有业务方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 Bridge"></a>桥接模式 Bridge</h3><p>桥接模式：将抽象部分与它的实现部分解耦，使得两者都能够独立变化。</p>
<blockquote>
<p>Bridge Pattern: Decouple an abstraction from its implementation so that the two can vary independently.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>桥接模式又被称为柄体（Handle and Body）模式或接口（Interface）模式。Bridge 模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。Bridge 模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge 模式是比多继承方案更好的解决方法。</p>
<p>动机：由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个维度的变化。</p>
<p>应用实例：Bridge 模式的应用一般在“两个非常强的变化维度”，例如一款毛笔在型号和颜色有两个变化维度，使用桥接模式让颜色和型号实现了分离，增加新的颜色或者型号对另一方没有任何影响。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000226.png" srcset="/img/loading.gif" alt="image-20201215111848313"></p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000227.png" srcset="/img/loading.gif" alt="image-20201215111239464"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现类接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Implementor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationImpl</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteImplementor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Implementor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationImpl</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//具体业务方法的实现</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Abstraction</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Implementor impl; <span class="hljs-comment">//定义实现类接口对象</span><br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImpl</span><span class="hljs-params">(Implementor impl)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.impl=impl;<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//声明抽象业务方法</span><br>&#125;<br><span class="hljs-comment">//扩充抽象类（细化抽象类）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefinedAbstraction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Abstraction</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//业务代码</span><br>        impl.operationImpl(); <span class="hljs-comment">//调用实现类的方法</span><br>        <span class="hljs-comment">//业务代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="对象创建模式"><a href="#对象创建模式" class="headerlink" title="对象创建模式"></a>对象创建模式</h2><p>通过“对象创建” 模式绕开 new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</p>
<h3 id="简单工厂模式-Simple-Factory"><a href="#简单工厂模式-Simple-Factory" class="headerlink" title="简单工厂模式 Simple Factory"></a>简单工厂模式 Simple Factory</h3><p>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p>
<p>简单工厂模式又被称为静态工厂方法（Static Factory Method）模式，因为在简单工厂模式中用于创建实例的方法通常是静态（static）方法。对象创建和使用的分离，客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可。简单工厂模式并不在 GOF 所提出的 23 种设计模式之列。</p>
<p>动机：客户端只知道传入工厂类的参数，对于如何创建对象并不关心。工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p>
<p>应用实例：下图的图表工厂可以通过传入不同的类型参数即可得到不同类型的图表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000228.png" srcset="/img/loading.gif" alt="image-20201215114345630"></p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000229.png" srcset="/img/loading.gif" alt="image-20201215112908212"></p>
<p>简单工厂的简化：将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000230.png" srcset="/img/loading.gif" alt="image-20201215113630774"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-comment">//静态工厂方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Product <span class="hljs-title">getProduct</span><span class="hljs-params">(String arg)</span> </span>&#123;<br>        Product product = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (arg.equalsIgnoreCase(<span class="hljs-string">&quot;A&quot;</span>)) &#123;<br>            product = <span class="hljs-keyword">new</span> ConcreteProductA();<br>            <span class="hljs-comment">//初始化设置product</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arg.equalsIgnoreCase(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>            product = <span class="hljs-keyword">new</span> ConcreteProductB();<br>            <span class="hljs-comment">//初始化设置product</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="工厂方法-Factory-Method"><a href="#工厂方法-Factory-Method" class="headerlink" title="工厂方法 Factory Method"></a>工厂方法 Factory Method</h3><p>工厂方法模式：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p>
<blockquote>
<p>Factory Method Pattern: Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>工厂模式（Factory Pattern）又被称为虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern），工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>
<p>动机：在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。</p>
<p>应用举例：日志记录器（Logger）工厂可以封装记录器的初始化过程并保证多种记录器切换的灵活性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000231.png" srcset="/img/loading.gif" alt="image-20201215115120118"></p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000233.png" srcset="/img/loading.gif" alt="image-20201215114920393"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="抽象工厂-Abstract-Factory"><a href="#抽象工厂-Abstract-Factory" class="headerlink" title="抽象工厂 Abstract Factory"></a>抽象工厂 Abstract Factory</h3><p>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p>
<blockquote>
<p>Abstract Factory Pattern: Provide an interface for creating families of related or dependent objects without specifying their concrete classes.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>抽象工厂模式又称为工具（Kit）模式，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品，也可以叫它家族工厂，产品族工厂。抽象工厂可以很方便的增加新的产品族，无须修改已有系统，只需要增加具体产品并对应增加一个新的具体工厂。但若是要增加新的产品等级结构，则需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。如果没有多个产品族对象创建的需求变化，完全可以使用简单工厂模式，如果一个产品族只有一种产品，则完全可以使用抽象工厂模式。</p>
<p>动机：在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。</p>
<p>应用实例：海尔工厂生产海尔产品族中的所有产品。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000234.png" srcset="/img/loading.gif" alt="image-20201215120824157"></p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000235.png" srcset="/img/loading.gif" alt="image-20201215120210674"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractProductA <span class="hljs-title">createProductA</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//工厂方法一</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractProductB <span class="hljs-title">createProductB</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//工厂方法二</span><br>    ……<br>&#125;<br><span class="hljs-comment">//具体工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-comment">//工厂方法一</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractProductA <span class="hljs-title">createProductA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductA1();<br>    &#125;<br><br>    <span class="hljs-comment">//工厂方法二</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractProductB <span class="hljs-title">createProductB</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductB1();<br>    &#125;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h3><p>原型模式：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。</p>
<blockquote>
<p>Prototype Pattern: Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>原型方法通过复制一个原型对象得到与原型对象一模一样的新对象，相比使用工厂方法，原型方法把创建任务回归到类本身中来，创建新对象（也称为克隆对象）的工厂就是原型类自身，原型对象通过复制自己来实现创建过程。原型模式常用来创建结构复杂的对象，使用工厂方还需要对创建的对象进行大量初始化操作才能得到自己想要的状态，使用原型模式可以直接从一个理想的中间状态的原型对象克隆出新对象，再根据需要对其成员变量稍作修改。</p>
<p>浅克隆与深克隆：</p>
<ul>
<li>浅克隆（Shallow Clone）：当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制<br><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000236.png" srcset="/img/loading.gif" alt="image-20201215130409732"></li>
</ul>
<ul>
<li>深克隆（Deep Clone）：除了对象本身被复制外，对象所包含的所有成员变量也将被复制<br><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000237.png" srcset="/img/loading.gif" alt="image-20201215130353383"></li>
</ul>
<p>动机：在软件系统中，经常面临着“某些结构复杂的对象”的创建工作;由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。</p>
<p>应用实例：Java 中 <code>Object</code> 类已经提供了浅克隆的实现，可以根据自己需要来在类中实现 <code>Cloneable</code> 接口来重写 <code>clone()</code> 方法，手动给成员变量赋值或者利用序列化来实现深克隆，<code>clone()</code> 方法并不是 <code>Cloneable</code> 接口中的方法，而是 <code>Object</code> 类中的方法，<code>Cloneable</code> 只是一个空的标记接口。</p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000238.png" srcset="/img/loading.gif" alt="image-20201215122228277"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcretePrototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-comment">//浅克隆</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        Object object = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = <span class="hljs-keyword">super</span>.clone();<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(CloneNotSupportedExecption exception) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Not support cloneable&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (ConcretePrototype)object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="构建器-Builder"><a href="#构建器-Builder" class="headerlink" title="构建器 Builder"></a>构建器 Builder</h3><p>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<blockquote>
<p>Builder Pattern: Separate the construction of a complex object from its representation so that the same construction process can create different representations.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>建造者模式可以将部件本身和它们的组装过程分开，关注如何一步步创建一个包含多个组成部分的复杂对象，用户只需要指定复杂对象的类型即可得到该对象，而无须知道其内部的具体构造细节。Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</p>
<p>动机：在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p>应用实例：使用建造者模式来实现游戏人物模型的创建，根据不同的角色先逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000239.png" srcset="/img/loading.gif" alt="image-20201215171434220"></p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000240.png" srcset="/img/loading.gif" alt="image-20201215161637683"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//复杂对象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> String partA; <span class="hljs-comment">//定义部件，部件可以是任意类型，包括值类型和引用类型</span><br>	<span class="hljs-keyword">private</span> String partB;<br>	<span class="hljs-keyword">private</span> String partC;<br><br>	<span class="hljs-comment">//partA的Getter/Setter方法省略</span><br>	<span class="hljs-comment">//partB的Getter/Setter方法省略</span><br>	<span class="hljs-comment">//partC的Getter/Setter方法省略</span><br>&#125;<br><span class="hljs-comment">//抽象建造者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>    <span class="hljs-comment">//创建产品对象</span><br>   <span class="hljs-keyword">protected</span> Product product=<span class="hljs-keyword">new</span> Product();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span></span>;<br>	<br>    <span class="hljs-comment">//返回产品对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体建造者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartA</span><span class="hljs-params">()</span> </span>&#123;<br>        product.setPartA(<span class="hljs-string">&quot;A1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartB</span><span class="hljs-params">()</span> </span>&#123;<br>        product.setPartB(<span class="hljs-string">&quot;B1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPartC</span><span class="hljs-params">()</span> </span>&#123;<br>        product.setPartC(<span class="hljs-string">&quot;C1&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//指挥者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Builder builder;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.builder=builder;<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBuilder</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.builder=builer;<br>    &#125;<br>	<br>    <span class="hljs-comment">//产品构建与组装方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.buildPartA();<br>        builder.buildPartB();<br>        builder.buildPartC();<br>        <span class="hljs-keyword">return</span> builder.getResult();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="对象性能模式"><a href="#对象性能模式" class="headerlink" title="对象性能模式"></a>对象性能模式</h2><p>面向对象很好地解决了“抽象”的问题，但是必不可免地要付出—定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。</p>
<h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h3><p>单例模式：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</p>
<blockquote>
<p>Singleton Pattern: Ensure a class has only one instance, and provide a global point of access to it.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>让类自身负责创建和保存它的唯一实例，保证不能创建其他实例，并提供一个访问该实例的方法。和工厂不同，单例模式之所以不直接用 <code>new</code> 来创建创建，绕过常规的构造器，不是为了解耦合，而是为了逻辑正确、安全和性能（节省对象开销）。</p>
<p>动机：在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。</p>
<p>应用实例：Windows 操作系统中的任务管理器和回收站、Java 的 <code>Runtime</code> 类实例、各种连接池。</p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000241.png" srcset="/img/loading.gif" alt="image-20201215173916775"></p>
<p>代码：</p>
<ol>
<li><p>饿汉式单例模式（EagerSingleton）：类加载到内存就实例化一个单例，JVM会保证线程安全，无须考虑多个线程同时访问的问题，调用速度和反应时间优于懒汉式单例。不管用到与否,只要加载了这个类就会实例化，，系统加载时间可能会比较长，资源利用效率不及懒汉式单例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EagerSingleton</span> </span>&#123; <br>    <span class="hljs-comment">//声明实例为 static 类变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EagerSingleton instance = <span class="hljs-keyword">new</span> EagerSingleton(); <br>    <span class="hljs-comment">//构造器 private 防止被其他类调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">EagerSingleton</span><span class="hljs-params">()</span> </span>&#123; &#125; <br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EagerSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>懒汉式单例类（LazySingleton）：实现了延迟加载，解决了饿汉式的缺点,但是带来了线程不安全问题,可能导致有多个实例被创建，需通过双重检查锁定等机制进行控制，处理多个线程同时访问的问题，这将导致系统性能受到一定影响。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法锁，在获取实例方法上加锁,有较高的性能损耗,</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazySingleton</span> </span>&#123; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LazySingleton instance = <span class="hljs-keyword">null</span>; <br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazySingleton</span><span class="hljs-params">()</span> </span>&#123; &#125; <br>    <span class="hljs-comment">//给获取实例加锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> LazySingleton(); <br>        &#125;<br>        <span class="hljs-keyword">return</span> instance; <br>    &#125;<br>&#125;<br><span class="hljs-comment">//锁代码块，在局部代码块加锁，并双重检查锁定（Double-Check Locking）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazySingleton</span> </span>&#123; <br>    <span class="hljs-comment">//由于编译器指令重排（reorder）优化导致多线程不安全，可能在一个线程拿到锁但还没有来得及执行构造器，另一线程就提前得到了返回地址使用静态内部类,在静态内部类里面声明一个static修饰的外部类变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> LazySingleton instance = <span class="hljs-keyword">null</span>; <br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazySingleton</span><span class="hljs-params">()</span> </span>&#123; &#125; <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-comment">//第一重判断</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//锁定代码块</span><br>            <span class="hljs-keyword">synchronized</span> (LazySingleton.class) &#123;<br>                <span class="hljs-comment">//第二重判断，instance 要用 volatile 修饰</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> LazySingleton(); <span class="hljs-comment">//创建单例实例</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> instance; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用静态内部类，在静态内部类里面声明一个 <code>static</code> 修饰的外部类变量，既实现了懒加载,又保证了线程安全，使用静态内部类需要语言特性支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Initialization on Demand Holder</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">//静态内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HolderClass</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> HolderClass.instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>使用枚举类产生单例，不仅可以解决线程同步，还可以防止利用反序列化和反射来产生单例，这是《Effective Java》中所推荐的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用 Singleton.INSTANCE 来引用单例对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br> INSTANCE;<br>	……  	<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式 Flyweight"></a>享元模式 Flyweight</h3><p>享元模式：运用共享技术有效地支持大量细粒度对象的复用。</p>
<blockquote>
<p>Flyweight Pattern: Use sharing to support large numbers of fine-grained objects efficiently.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>将具有相同内部状态的对象存储在享元池（Flyweight Pool）中，享元池中的对象是可以实现共享的，需要的时候将对象从享元池中取出，即可实现对象的复用，减少内存中对象的数量。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，使得相同或者相似的对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。享元的共享状态值往往是只读的。</p>
<p>动机：在软件系统采用纯粹面向对象的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。</p>
<p>应用举例：Java 中 <code>String</code> 字符串类。</p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000242.png" srcset="/img/loading.gif" alt="image-20201215182815456"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象享元类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String extrinsicState)</span></span>;<br>&#125;<br><span class="hljs-comment">//具体享元类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFlyweight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-comment">//内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的</span><br>    <span class="hljs-keyword">private</span> String intrinsicState;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteFlyweight</span><span class="hljs-params">(String intrinsicState)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.intrinsicState = intrinsicState;<br>    &#125;<br>	<br>    <span class="hljs-comment">//外部状态extrinsicState在使用时由外部设置，不保存在享元对象中，即使是同一个对象，在每一次调用时可以传入不同的外部状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String extrinsicState)</span> </span>&#123;<br>        <span class="hljs-comment">//实现业务方法</span><br>    &#125;	<br>&#125;<br><span class="hljs-comment">//非共享具体享元类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsharedConcreteFlyweight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Flyweight</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(String extrinsicState)</span> </span>&#123;<br>        <span class="hljs-comment">//实现业务方法</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//享元工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightFactory</span> </span>&#123;<br>    <span class="hljs-comment">//定义一个HashMap用于存储享元对象，实现享元池</span><br>    <span class="hljs-keyword">private</span> HashMap flyweights = <span class="hljs-keyword">new</span> HashMap();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Flyweight <span class="hljs-title">getFlyweight</span><span class="hljs-params">(String key)</span> </span>&#123;<br>       <span class="hljs-comment">//如果对象存在，则直接从享元池获取</span><br>       <span class="hljs-keyword">if</span> (flyweights.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> (Flyweight)flyweights.get(key);<br>        &#125;<br>        <span class="hljs-comment">//如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            Flyweight fw = <span class="hljs-keyword">new</span> ConcreteFlyweight();<br>            flyweights.put(key,fw);<br>            <span class="hljs-keyword">return</span> fw;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="接口隔离模式"><a href="#接口隔离模式" class="headerlink" title="接口隔离模式"></a>接口隔离模式</h2><p>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</p>
<h3 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 Facade"></a>外观模式 Facade</h3><p>外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<blockquote>
<p>Facade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>外观模式又称为门面模式，引入一个新的外观类（Facade）来负责和多个子系统（Subsystem）进行交互，而客户类只需与外观类交互，为多个业务类的调用提供了一个统一的入口，客户类与子系统之间原有的复杂引用关系由外观类来实现，简化了类与类之间的交互，从而降低了系统的耦合度。子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。外观类往往只需要一个实例，可以结合单例模式。</p>
<p>动机：组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</p>
<p>应用实例：大型公司的前台是企业内部与外界交互的接口，访客通过前台的窗口来和各个部门打交道，而不是直接进入公司内部的各个部门。</p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000243.png" srcset="/img/loading.gif" alt="image-20201215184445383"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//各个子系统</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemA</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//业务实现代码</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemB</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//业务实现代码</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemC</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodC</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//业务实现代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//外观类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> SubSystemA obj1 = <span class="hljs-keyword">new</span> SubSystemA();<br>    <span class="hljs-keyword">private</span> SubSystemB obj2 = <span class="hljs-keyword">new</span> SubSystemB();<br>    <span class="hljs-keyword">private</span> SubSystemC obj3 = <span class="hljs-keyword">new</span> SubSystemC();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        obj1.method();<br>        obj2.method();<br>        obj3.method();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h3><p>代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p>
<blockquote>
<p>Proxy Pattern: Provide a surrogate or placeholder for another object to control access to it.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>代理模式又称为经纪人（Surrogate/Broker）模式，两个对象本来可以直接依赖，但是由于性能、安全或者分布式的原因必须隔离。通过引入一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，代理对象中去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。</p>
<p>几种常见的代理模式：</p>
<ul>
<li>远程代理（Remote Proxy）：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使（Ambassador）。</li>
<li>虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>
<li>保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li>缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>智能引用代理（Smart Reference Proxy）：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</li>
<li>动态代理（Dynamic Proxy）：可以让系统在运行时根据实际需要来动态创建代理类，让同一个代理类能够代理多个不同的真实主题类而且可以代理不同的方法。</li>
</ul>
<p>动机：在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。</p>
<p>应用实例：Java RMI 远程代理框架就用到了代理模式。RMI（Remote Method Invocation）是基于 Java 技术的分布式编程模型，为 Java 程序提供远程访问服务。通过 RMI 允许对象在不同的 Java 虚拟机（Java Virtual Machine）之间进行通信。此外 JDK 中的 <code>java.lang.reflect</code> 这个包还提供对了动态代理的支持。</p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000244.png" srcset="/img/loading.gif" alt="image-20201215185123943"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象主题类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//真实主题类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//业务方法具体实现代码</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> RealSubject realSubject = <span class="hljs-keyword">new</span> RealSubject();  <span class="hljs-comment">//维持一个对真实主题对象的引用 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preRequest</span><span class="hljs-params">()</span> </span>&#123;<br>        …...<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>        preRequest();<br>        realSubject.request();  <span class="hljs-comment">//调用真实主题对象的方法</span><br>        postRequest();<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postRequest</span><span class="hljs-params">()</span> </span>&#123;<br>        ……<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h3><p>适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p>
<blockquote>
<p>Adapter Pattern: Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>适配器模式又名包装器(Wrapper)模式，适配器模式解决的是老旧接口不兼容需要转换的问题。通过引入一个适配器类来重用现有的适配者类，将目标类和适配者类解耦，无须修改原有结构，增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</p>
<p>类适配器和对象适配器：</p>
<ul>
<li>类适配器模式置换一些适配者的方法很方便，但是 Java  中一次最多只能适配一个适配者类，并且目标抽象类只能为接口，因为 Java 不支持多继承。</li>
<li>对象适配器模式采用对象组合的方式，可以把多个不同的适配者适配到同一个目标，更加推荐使用。</li>
</ul>
<p>动机：在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。</p>
<p>应用实例：给玩具汽车添加上警灯闪烁和警笛音效。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000245.png" srcset="/img/loading.gif" alt="image-20201215200322719"></p>
<p>结构类图：</p>
<p>类适配器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000246.png" srcset="/img/loading.gif" alt="image-20201215193234377"></p>
<p>对象适配器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000247.png" srcset="/img/loading.gif" alt="image-20201215193244032"></p>
<p>双向适配器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000248.png" srcset="/img/loading.gif" alt="image-20201215193406010"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类适配器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.specificRequest();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//对象适配器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Target</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee; <span class="hljs-comment">//维持一个对适配者对象的引用</span><br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.adaptee=adaptee;<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>        adaptee.specificRequest(); <span class="hljs-comment">//转发调用</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//双向适配器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span>,<span class="hljs-title">Adaptee</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Target target;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adapter</span><span class="hljs-params">(Target target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.adaptee = adaptee;<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>        adaptee.specificRequest();<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">specificRequest</span><span class="hljs-params">()</span> </span>&#123;<br>        target.request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式 Mediator"></a>中介者模式 Mediator</h3><p>中介者模式：定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且让你可以独立地改变它们之间的交互。</p>
<blockquote>
<p>Mediator Pattern: Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>中介者模式又称为调停者模式，在中介者模式中，通过引入中介者来简化对象之间的复杂交互，中介者模式是迪米特法则的一个典型应用，对象之间多对多的复杂关系转化为相对简单的一对多关系。中介者模式将系统的网状结构变成以中介者为中心的星型结构，同事对象不再直接与另一个对象联系，它通过中介者对象与另一个对象发生相互作用。新对象的引入不会给系统的结构带来大量的修改工作。中介者模式解决的是系统内多个对象之间的通信问题，减少类之间的关联。外观模式解决的是客户类和子系统类的通信问题。中介者模式中对象可以向中介者请求协作。外观模式中子系统对象不会对外观有任何协作请求。</p>
<p>动机：在软件构建过程中，经常会出现多个对象互相关联交互的情况对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</p>
<p>应用实例：房屋中介公司扮演了出租者、求租者的中介者。</p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000249.png" srcset="/img/loading.gif" alt="image-20201215200807616"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象中介者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> ArrayList&lt;Colleague&gt; colleagues = <span class="hljs-keyword">new</span> ArrayList&lt;Colleague&gt;(); <span class="hljs-comment">//用于存储同事对象</span><br><br>    <span class="hljs-comment">//注册方法，用于增加同事对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Colleague colleague)</span> </span>&#123;<br>        colleagues.add(colleague);<br>    &#125;<br><br>    <span class="hljs-comment">//声明抽象的业务方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体中介者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-comment">//实现业务方法，封装同事之间的调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        ......<br>        ((Colleague)(colleagues.get(<span class="hljs-number">0</span>))).method1(); <span class="hljs-comment">//通过中介者调用同事类的方法</span><br>        ......<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象同事类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> Mediator mediator; <span class="hljs-comment">//维持一个抽象中介者的引用</span><br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Colleague</span><span class="hljs-params">(Mediator mediator)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mediator=mediator;<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//声明自身方法，处理自己的行为</span><br>	<br>    <span class="hljs-comment">//定义依赖方法，与中介者进行通信</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        mediator.operation();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体同事类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteColleague</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Colleague</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteColleague</span><span class="hljs-params">(Mediator mediator)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(mediator);<br>    &#125;<br>	<br>    <span class="hljs-comment">//实现自身方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        ......<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="状态变化模式"><a href="#状态变化模式" class="headerlink" title="状态变化模式"></a>状态变化模式</h2><p>在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案。</p>
<h3 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a>状态模式 State</h3><p>状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
<blockquote>
<p>State Pattern: Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。通常上下文可以共享一个状态实例，结合单例模式可以节省对象开销。</p>
<p>动机：在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。</p>
<p>应用实例：银行根据账户的余额实现账户的状态自动装换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000250.png" srcset="/img/loading.gif" alt="image-20201215202655621"></p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000251.png" srcset="/img/loading.gif" alt="image-20201215202313003"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象状态类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-comment">//声明抽象业务方法，不同的具体状态类可以有不同的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体状态类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//方法具体实现代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//环境上下文类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> State state; <span class="hljs-comment">//维持一个对抽象状态对象的引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;  <span class="hljs-comment">//其他属性值</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(State state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//其他代码</span><br>        state.handle(); <span class="hljs-comment">//调用状态对象的业务方法</span><br>        <span class="hljs-comment">//其他代码</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="备忘录-Memento"><a href="#备忘录-Memento" class="headerlink" title="备忘录 Memento"></a>备忘录 Memento</h3><p>备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样就可以在以后将对象恢复到原先保存的状态。</p>
<blockquote>
<p>Memento Pattern: Without violating encapsulation, capture and externalize an object’s internal state so that the object can be restored to this state later.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>备忘录模式又名标记（Token）模式，提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤。首先保存软件系统的历史状态，当用户需要取消错误操作并且返回到某个历史状态时，可以取出事先保存的历史状态来覆盖当前状态。现在很少使用备忘录模式，而是采用效率更高更易实现的序列化方式来实现快照。</p>
<p>动机：在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</p>
<p>应用实例：很多软件所提供的撤销（Undo）和重做（Redo）操作中就使用了备忘录模式。</p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000252.png" srcset="/img/loading.gif" alt="image-20201215203410088"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//原发器类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Originator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Originator</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-comment">//创建一个备忘录对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">createMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//根据备忘录对象恢复原发器状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restoreMemento</span><span class="hljs-params">(Memento m)</span> </span>&#123;<br>        state = m.state;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state=state;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//将Memento类与Originator类定义在同一个包(package)中来实现封装，使用默认可见性定义Memento类，即保证其在包内可见。或者将备忘录类作为原发器类的内部类，使得只有原发器才可以访问备忘录中的数据，其他对象都无法使用备忘录中的数据。</span><br><span class="hljs-comment">//备忘录类，默认可见性，包内可见</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String state;<br><br>    Memento(Originator o) &#123;<br>        state = o.getState();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state=state;<br>    &#125;<br><br>    <span class="hljs-function">String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//负责人类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Caretaker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Memento memento;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">getMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> memento;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemento</span><span class="hljs-params">(Memento memento)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.memento=memento;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="数据结构模式"><a href="#数据结构模式" class="headerlink" title="数据结构模式"></a>数据结构模式</h2><p>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</p>
<h3 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 Composite"></a>组合模式 Composite</h3><p>组合模式：组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。</p>
<blockquote>
<p>Composite Pattern: Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>组合模式又称为“部分-整体”（Part-Whole）模式。组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树形结构的一部分，它描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象，无需关心处理的是叶子对象还是容器对象。</p>
<p>透明组合模式和安全组合模式：</p>
<ul>
<li>透明组合模式：抽象构件 Component 中声明了所有用于管理成员对象的方法，包括 <code>add()</code>、<code>remove()</code>，以及 <code>getChild()</code> 等方法。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象。缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不应该能调用那些容器对象才能拥有的方法。</li>
<li>安全组合模式：抽象构件 Component 中没有声明任何用于管理成员对象的方法，而是在 <code>Composite</code> 类中声明并实现这些方法。对于叶子对象，客户端不可能调用到这些方法。缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件，要判断某一个对象是是叶子和容器再使用。</li>
</ul>
<p>动机：在软件在某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器丙部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</p>
<p>应用实例：操作系统的目录结构中，包含文件和文件夹两类不同的元素，在文件夹中可以包含文件，还可以继续包含子文件夹，在文件中不能再包含子文件或者子文件夹，文件夹对应着容器（Container）对象，文件对应着叶子（Leaf）对象。</p>
<p>结构类图：</p>
<p>透明组合模式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000253.png" srcset="/img/loading.gif" alt="image-20201216104601381"></p>
<p>安全组合模式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000254.png" srcset="/img/loading.gif" alt="image-20201216104652582"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//透明组合模式</span><br><span class="hljs-comment">//抽象构件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span></span>; <span class="hljs-comment">//增加成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span></span>; <span class="hljs-comment">//删除成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>; <span class="hljs-comment">//获取成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//业务方法</span><br>&#125;<br><span class="hljs-comment">//叶子构件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span> </span>&#123; <br>        <span class="hljs-comment">//异常处理或错误提示</span><br>    &#125;	<br>		<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span> </span>&#123; <br>        <span class="hljs-comment">//异常处理或错误提示</span><br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123; <br>        <span class="hljs-comment">//异常处理或错误提示</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//叶子构件具体业务方法的实现</span><br>    &#125; <br>&#125;<br><span class="hljs-comment">//容器构件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Component&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Component&gt;();<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Component c)</span> </span>&#123;<br>        list.add(c);<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Component c)</span> </span>&#123;<br>        list.remove(c);<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Component <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (Component)list.get(i);<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//容器构件具体业务方法的实现，将递归调用成员构件的业务方法</span><br>        <span class="hljs-keyword">for</span>(Object obj:list) &#123;<br>            ((Component)obj).operation();<br>        &#125;<br>    &#125; 	<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式 Iterator"></a>迭代器模式 Iterator</h3><p>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，且不用暴露该对象的内部表示。</p>
<blockquote>
<p>Iterator Pattern: Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>迭代器模式又称为游标（Cursor）模式。将遍历数据的行为从聚合对象中分离出来，封装在迭代器对象中，由迭代器来提供遍历聚合对象内部数据的行为，简化聚合对象的设计，更符合单一职责原则。客户端无须了解聚合对象的内部结构即可实现对聚合对象中成员的遍历，还可以根据需要很方便地增加新的遍历方式。Java 中迭代器常常和泛型一起配合使用，保证了编译时的正确，编译后泛型类型会被擦除。</p>
<p>动机：在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素;同时这种“透明遍历”也为“同一种算法在多种集合对象上进行操作”提供了可能。</p>
<p>应用实例：<code>java.util.Iterator</code> 这个类提供 Java 集合对迭代器的支持。Java 1.5 出现的增强的 <code>for</code> 循环语句也是利用到了迭代器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000255.png" srcset="/img/loading.gif" alt="image-20201216114755094"></p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000256.png" srcset="/img/loading.gif" alt="image-20201216114429923"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象迭代器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">//将游标指向第一个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">//将游标指向下一个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">//判断是否存在下一个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">currentItem</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//获取游标指向的当前元素</span><br>&#125;<br><span class="hljs-comment">//具体迭代器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ConcreteAggregate objects; <span class="hljs-comment">//维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cursor;  <span class="hljs-comment">//定义一个游标，用于记录当前访问位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteIterator</span><span class="hljs-params">(ConcreteAggregate objects)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.objects=objects;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>&#123;  ......  &#125;<br>		<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;  ......  &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;  ......  &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">currentItem</span><span class="hljs-params">()</span> </span>&#123;  ......  &#125;<br>&#125;<br><span class="hljs-comment">//抽象聚合类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Aggregate</span> </span>&#123;<br>    <span class="hljs-function">Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体聚合类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteAggregate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Aggregate</span> </span>&#123;	<br>    ......	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteIterator(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ......<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="职责链模式-Chain-of-Responsibility"><a href="#职责链模式-Chain-of-Responsibility" class="headerlink" title="职责链模式 Chain of Responsibility"></a>职责链模式 Chain of Responsibility</h3><p>职责链模式：避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。</p>
<blockquote>
<p>Chain of Responsibility Pattern: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>职责链模式将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上，将请求的发送者和请求的处理者解耦。职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。</p>
<p>纯与不纯的职责链模式</p>
<ul>
<li>纯的职责链模式：一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，一个请求必须被某一个处理者对象所接收，如果请求到职责链的末尾仍得不到处理，应该有一个合理的缺省处理机制，不能出现某个请求未被任何一个处理者对象处理的情况。</li>
<li>不纯的职责链模式：允许某个请求被一个具体处理者部分处理后向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，一个请求可以最终不被任何处理者对象所接收并处理。</li>
</ul>
<p>动机：在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显式指定，将必不可少地带来请求发送者与接受者的紧耦合。</p>
<p>应用实例：辅导员、系主任、院长、校长都可以处理奖学金申请表，他们构成一个处理申请表的链式结构，申请表沿着这条链进行传递，这条链就称为职责链。JavaScript 的事件浮升（Event Bubbling）处理机制。</p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000257.png" srcset="/img/loading.gif" alt="image-20201216120528500"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象处理者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-comment">//维持对下家的引用</span><br>    <span class="hljs-keyword">protected</span> Handler successor;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSuccessor</span><span class="hljs-params">(Handler successor)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.successor=successor;<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(String request)</span></span>;<br>&#125;<br><span class="hljs-comment">//具体处理者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(String request)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (请求满足条件) &#123;<br>            <span class="hljs-comment">//处理请求</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">this</span>.successor.handleRequest(request); <span class="hljs-comment">//转发请求</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端调用职责链代码段</span><br>……<br>Handler handler1, handler2, handler3;<br>handler1 = <span class="hljs-keyword">new</span> ConcreteHandlerA();<br>handler2 = <span class="hljs-keyword">new</span> ConcreteHandlerB();<br>handler3 = <span class="hljs-keyword">new</span> ConcreteHandlerC();<br><span class="hljs-comment">//创建职责链，给处理者指定下家</span><br>handler1.setSuccessor(handler2);<br>handler2.setSuccessor(handler3);<br><span class="hljs-comment">//发送请求，请求对象通常为自定义类型</span><br>handler1.handleRequest(<span class="hljs-string">&quot;请求对象&quot;</span>);<br>……<br></code></pre></td></tr></table></figure>

<h2 id="行为变化模式"><a href="#行为变化模式" class="headerlink" title="行为变化模式"></a>行为变化模式</h2><p>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</p>
<h3 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a>命令模式 Command</h3><p>命令模式：将一个请求封装为一个对象，从而让你可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。</p>
<blockquote>
<p>Command Pattern: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>命令模式别名为动作（Action）模式或事务（Transaction）模式。命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分开。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。</p>
<p>动机：在软件构建过程中，“行为请求者”与“行为实现者”通常呈现—种“紧耦合”。但在某些场合——比如需要对行为进行“记录.撤销/重做（undo/redo）、事务”等处理，这种无法抵御变化的紧耦合是不合适的。</p>
<p>应用实例：</p>
<ul>
<li>自定义快捷键：通过修改配置文件，更换具体的命令类，使得按下相同的快捷键可以调用不同的事件处理类方法。快捷键是请求发送者，事件处理类是请求的最终接收者。发送者与接收者之间引入了新的命令对象，将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。</li>
<li>命令队列：当一个请求发送者发送一个请求时，有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理，增加一个 <code>CommandQueue</code> 类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者。</li>
<li>记录请求日志：将请求的历史记录保存下来，通常以日志文件（Log File）的形式永久存储在计算机中，将发送请求的命令对象通过序列化写到日志文件中，命令类必须实现接口 <code>Serializable</code>。</li>
<li>撤销操作：可以通过对命令类添加上 <code>undo()</code> 和 <code>redo()</code> 方法，使得系统支持撤销（Undo）操作和恢复（Redo）操作。</li>
<li>宏命令：宏命令（Macro Command）又称为组合命令（Composite Command），它是组合模式和命令模式联用的产物。宏命令是一个具体命令类，它拥有一个集合，在该集合中包含了对其他命令对象的引用。当调用宏命令的 <code>execute()</code> 方法时，将递归调用它所包含的每个成员命令的 <code>execute()</code> 方法。一个宏命令的成员可以是简单命令，还可以继续是宏命令，执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理。</li>
</ul>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000258.png" srcset="/img/loading.gif" alt="image-20201216121857882"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象命令类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//具体命令类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Receiver receiver; <span class="hljs-comment">//维持一个对请求接收者对象的引用</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        receiver.action(); <span class="hljs-comment">//调用请求接收者的业务处理方法action()</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//请求接收者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Receiver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//具体操作</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//调用者（请求发送者）类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Command command;<br><br>    <span class="hljs-comment">//构造注入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Invoker</span><span class="hljs-params">(Command command)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.command = command;<br>    &#125;<br><br>    <span class="hljs-comment">//设值注入</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command command)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.command = command;<br>    &#125;<br><br>    <span class="hljs-comment">//业务方法，用于调用命令类的execute()方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>        command.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="访问器模式-Visitor"><a href="#访问器模式-Visitor" class="headerlink" title="访问器模式 Visitor"></a>访问器模式 Visitor</h3><p>访问者模式：表示一个作用于某对象结构中的各个元素的操作。访问者模式让你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<blockquote>
<p>Visitor Pattern: Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>访问者模式的对象结构（Object Structure）中存储了多种不同类型的元素信息，将有关元素对象的访问行为集中到一个访问者对象中，不同的具体访问者对这些元素有不同的处理方式。增加新的元素处理方式只需要增加一个新的具体访问者，但是如果要增加新的具体元素类会破坏 Visitor 的封装。类似于抽象工厂中产品族和产品等级结构的关系，对开闭原则具有倾斜性，适用于对象结构中元素类稳定，对元素的处理操作经常变化的场景。</p>
<p>动机：在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会合子类带来很繁重的变更负担，甚至破坏原有设计。</p>
<p>应用实例：公司的人力资源部负责汇总每周员工工作时间，财务部负责计算每周员工工资。员工列表对应对象结构，全职员工和兼职员工对应着具体元素类，人力资源部和财务部对应着不同的具体访问者，分别对员工列表有着不同的操作：计算工作时间和计算工资。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000259.png" srcset="/img/loading.gif" alt="image-20201216140651064"></p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000260.png" srcset="/img/loading.gif" alt="image-20201216130631797"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象访问者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementA elementA)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementB elementB)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementC elementC)</span> </span>&#123;<br>        <span class="hljs-comment">//元素ConcreteElementC操作代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体访问者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Visitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementA elementA)</span> </span>&#123;<br>        <span class="hljs-comment">//元素ConcreteElementA操作代码</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ConcreteElementB elementB)</span> </span>&#123;<br>        <span class="hljs-comment">//元素ConcreteElementB操作代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象元素类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Element</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>;<br>&#125;<br><span class="hljs-comment">//具体元素类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteElementA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Element</span> </span>&#123;<br>    <span class="hljs-comment">//主动去调用访问者的处理操作来处理元素自己</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        visitor.visit(<span class="hljs-keyword">this</span>);<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//业务方法</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//对象结构类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectStructure</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">//定义一个集合用于存储元素对象</span><br>    <span class="hljs-keyword">private</span> ArrayList&lt;Element&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Element&gt;(); <br><br>    <span class="hljs-comment">//接受访问者的访问操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;<br>        <span class="hljs-comment">//遍历对象结构中的每一个元素执行访问者的操作</span><br>		<span class="hljs-keyword">for</span>(Element e : list) &#123;<br>            e.accept(visitor);<br>        &#125;        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addElement</span><span class="hljs-params">(Element element)</span> </span>&#123;<br>        list.add(element);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(Element element)</span> </span>&#123;<br>        list.remove(element);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="领域规则模式"><a href="#领域规则模式" class="headerlink" title="领域规则模式"></a>领域规则模式</h2><p>在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。</p>
<h3 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式 Interpreter"></a>解释器模式 Interpreter</h3><p>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
<blockquote>
<p>Interpreter Pattern: Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.——《Design Patterns: Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>解释器模式定义一套文法规则来实现对这些语句的解释，即使用规定格式和语法的代码设计一个自定义语言。解释器模式适合简单的文法规则，对于复杂的文法需要使用语法分析生成器工具。</p>
<p>动机：在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频频繁的变化。</p>
<p>应用实例：解析字符串形式的四则远算表达式。</p>
<p>结构类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201041000261.png" srcset="/img/loading.gif" alt="image-20201216131849497"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象表达式类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span></span>;<br>&#125;<br><span class="hljs-comment">//终结符表达式类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TerminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> </span>&#123;<br>        <span class="hljs-comment">//终结符表达式的解释操作</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//非终结符表达式类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonterminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AbstractExpression left;<br>    <span class="hljs-keyword">private</span> AbstractExpression right;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NonterminalExpression</span><span class="hljs-params">(AbstractExpression left,AbstractExpression right)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.left=left;<br>        <span class="hljs-keyword">this</span>.right=right;<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> </span>&#123;<br>        <span class="hljs-comment">//递归调用每一个组成部分的interpret()方法</span><br>        <span class="hljs-comment">//在递归调用时指定组成部分的连接方式，即非终结符的功能</span><br>    &#125;	<br>&#125;<br><span class="hljs-comment">//上下文环境类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(String key, String value)</span> </span>&#123;<br>        <span class="hljs-comment">//往环境类中设值</span><br>        map.put(key, value);<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">lookup</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-comment">//获取存储在环境类中的值</span><br>        <span class="hljs-keyword">return</span> map.get(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kW411P7KS">B站视频：C++ 设计模式 Design Patterns李建忠</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/LoveLion/article/details/79602149">刘伟：《Java 设计模式》</a></li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/">自学笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/UML/">UML</a>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/09/HTML+CSS/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">HTML 和 CSS 学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/26/%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/">
                        <span class="hidden-mobile">写给自己看的中文排版规范</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2"></div>
    
  </div>
</div>

<!-- Custom -->



    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     © 2020 - 2021 @ <a href="https://kiku.vip" target="_blank" rel="nofollow noopener"><span>Kiku</span></a><br> Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> | Theme -  <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>





  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?d3e02bccada8177079a692ffc4daabf8";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
