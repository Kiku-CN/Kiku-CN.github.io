

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#515151">
  <meta name="description" content="">
  <meta name="author" content="Kiku">
  <meta name="keywords" content="个人 博客 技术 分享 日记 笔记 学习 文章 教程 指南 程序员">
  <title>JavaScript Web API 学习笔记 - Kiku 的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/vs.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":90,"cursorChar":"▁","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":false,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":"d3e02bccada8177079a692ffc4daabf8","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kiku</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/404.html">
                <i class="iconfont icon-pen"></i>
                留言板
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/404.html">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://cdn.jsdelivr.net/gh/Kiku-CN/picsHost@img2/img/202201040806793.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JavaScript Web API 学习笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-10 00:00" pubdate>
        2021年3月10日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.9k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    
	
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JavaScript Web API 学习笔记</h1>
            
            <div class="markdown-body">
              <h2 id="Web-API-简介"><a href="#Web-API-简介" class="headerlink" title="Web API 简介"></a>Web API 简介</h2><p>API（Application Programming Interface，应用程序编程接口）指的是一些函数，这些函数对一些常用功能进行了封装，专门用来方便程序员在此基础上做开发，而不用重复造轮子。</p>
<p>例如 C 语言中有一个函数 <code>fopen()</code>，通过此函数接口可以打开硬盘上的文件，Java 中的 JDK 中各种函数，这些函数库可能由编程语言提供，也可能由一些第三方软件厂商提供，我们无需访问源码了解内部实现细节，只需要阅读 API 手册引用了对应的库文件就可以直接调用函数使用特定的功能。</p>
<p>Web API 特指的是浏览器厂商提供的一套用来操作浏览器和 HTML 页面中的元素的 API，以方便程序员在此基础上开发 Web 应用程序或网站。</p>
<p>Web  API 根据操作对象不同又可以分为 DOM 和 BOM 两大类，Web API 主要用于 JavaScript，但也可能有例外。所有的 API 列表可以查阅 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API">MDN：Web  API 列表</a>。</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML 或者 XML）的标准编程接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。</p>
<p>把 HTML 或 XML 文档解析映射成树形结构，这棵树称为 DOM 树，又称为文档树模型，这样可以更加方便对各个节点对象处理。</p>
<p>![1550731974575](JavaScript Web API images/1550731974575.png)</p>
<ul>
<li>文档：一整个 HTML 页面就是一个文档，DOM 中使用 document 表示。</li>
<li>节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用 node 表示。</li>
<li>标签节点：又称为元素节点，简称为“元素”，文档中的所有 HTML 标签括包裹起来的内容，使用 element 表示。</li>
</ul>
<p>![img](JavaScript Web API images/dom-crude-map.png)</p>
<h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>如果我们想要操作网页上的某部分内容，需要先获取到该部分对应的元素，才能对其进行操作。</p>
<ul>
<li><p>根据 ID 获取：使用 <code>getElementById()</code> 方法可以根据元素 ID 属性值获取元素对象，因为 ID 属性值在整个文档中应该是唯一或者不存在的，这个方法返回的一个 HTML 对象 或 null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div id=<span class="hljs-string">&quot;year&quot;</span>&gt;<span class="hljs-number">2021</span>&lt;/div&gt;<br>    &lt;!-- 因为我们文档页面从上往下加载，所以所以我们 script 写到元素的下面,否则将获取不到元素 --&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> time = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;year&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(time);<br>        <span class="hljs-comment">// 使用 console.dir() 可以打印对象里面的属性和方法详细信息</span><br>        <span class="hljs-built_in">console</span>.dir(time);<br>    &lt;/script&gt;<br>&lt;/body&gt;		<br></code></pre></td></tr></table></figure>
</li>
<li><p>根据标签名获取：使用 <code>getElementsByTagName()</code> 方法可以返回带有指定标签名的对象的集合，以伪数组的形式存储,想要操作里面的元素常常需要遍历伪数组。即使整个文档只有一个该标签节点，返回的仍是伪数组而不是直接返回唯一的元素对象，如果整个文档没有这个标签节点，返回的是空的伪数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div&gt;<br>        &lt;ul&gt;<br>            &lt;li&gt;&lt;/li&gt;<br>            &lt;li&gt;&lt;/li&gt;<br>            &lt;li&gt;&lt;/li&gt;<br>        &lt;/ul&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> divs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(divs);<br>        <span class="hljs-built_in">console</span>.log(divs[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 获取某个元素（父元素）内部所有指定标签名的子元素.</span><br>        <span class="hljs-keyword">var</span> lis = divs[<span class="hljs-number">0</span>].getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(lis);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.length; i++) &#123;<br>            <span class="hljs-built_in">console</span>.log(lis[i]);<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>根据类名获取：使用 <code>getElementsByClassName()</code> 方法根据元素的 class 属性值返回元素对象的伪数组集合，此方法是 HTML5 新增的方法，可能存在兼容性问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;box&quot;</span>&gt;盒子<span class="hljs-number">1</span>&lt;/div&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;box&quot;</span>&gt;盒子<span class="hljs-number">2</span>&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> boxs = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;box&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(boxs);<br>	&lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>根据选择器获取：使用 <code>querySelector()</code> 方法返回指定选择器的第一个元素对象，使用  <code>querySelectorAll()</code> 方法返回指定选择器的所有元素对象的伪数组集合。传入的选择器字符串不要忘了带上符号，例如 .box  #nav，这两个方法也是 HTML5 新增的方法，可能存在兼容性问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div id=<span class="hljs-string">&quot;nav&quot;</span>&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;box&quot;</span>&gt;盒子<span class="hljs-number">1</span>&lt;/div&gt;<br>        &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;box&quot;</span>&gt;盒子<span class="hljs-number">2</span>&lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> nav = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#nav&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(nav);<br>        <span class="hljs-keyword">var</span> boxs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.box&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(boxs);<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>获取特殊元素：可以根据 document 对象的某些属性直接获取特殊元素对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">doucumnet.body 				<span class="hljs-comment">// 返回body元素对象</span><br><span class="hljs-built_in">document</span>.documentElement 	<span class="hljs-comment">// 返回html元素对象</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="JavaScript-事件"><a href="#JavaScript-事件" class="headerlink" title="JavaScript 事件"></a>JavaScript 事件</h3><p>事件是可以被 JavaScript 侦测到的行为。</p>
<p>网页中的每个元素都可以触发某些 JavaScript 事件，例如，用户鼠标点击某元素，鼠标滑过某元素，当事件发生时，然后去执行某些操作。</p>
<p>常见的鼠标事件：</p>
<p>![1550734506084](JavaScript Web API images/1550734506084.png)</p>
<p>事件三要素：</p>
<ul>
<li>事件源（谁）：触发事件的 HTML 元素对象。</li>
<li>事件类型（什么事件）： 如何触发事件，比如鼠标点击元素，鼠标经过元素，键盘某个键按下。</li>
<li>事件处理程序（做啥）：事件触发后要执行的函数代码，即事件处理函数，可以通过给元素的事件属性赋函数值的来注册事件。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div&gt;<span class="hljs-number">123</span>&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-comment">// 1. 获取事件源</span><br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        <span class="hljs-comment">// 2.绑定事件处理程序 </span><br>        div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我被选中了&#x27;</span>);<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<h3 id="操作元素属性"><a href="#操作元素属性" class="headerlink" title="操作元素属性"></a>操作元素属性</h3><p>使用 DOM API 可以获得页面中 HTML 元素对象的属性，通过修改这些属性可以动态改变网页内容、结构和样式。</p>
<p>常见的元素属性有 innerText、innerHTML、src、href、id、alt、title、type、value、checked、selected、disabled、style、className 等。</p>
<p>innerText、innerHTML 两个属性用来改变元素的内容，两者的区别是 innerText 不会识别 HTML 标签，而 innerHTML 会识别 HTML 标签。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div id=<span class="hljs-string">&quot;box1&quot;</span>&gt;box&lt;strong&gt;<span class="hljs-number">1</span>&lt;<span class="hljs-regexp">/strong&gt;&lt;/</span>div&gt;<br>    &lt;div id=<span class="hljs-string">&quot;box2&quot;</span>&gt;box&lt;strong&gt;<span class="hljs-number">2</span>&lt;<span class="hljs-regexp">/strong&gt;&lt;/</span>div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.body);<br>        <span class="hljs-keyword">var</span> box1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;box1&#x27;</span>);<br>        <span class="hljs-keyword">var</span> box2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;box2&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(box1.innerText);	<span class="hljs-comment">// box1</span><br>        <span class="hljs-built_in">console</span>.log(box2.innerHTML);	<span class="hljs-comment">// box&lt;strong&gt;2&lt;/strong&gt;</span><br>    &lt;/script&gt;	<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<p>通过 style 属性及其中的子属性可以直接修改元素的的行内样式表，优先级很高。注意 style 属性的子属性名遵循驼峰命名法，比如 fontSize  对应 CSS 中的 font-size 、backgroundColor 对应 CSS 中的 background-color。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;img src=<span class="hljs-string">&quot;images/tao.png&quot;</span> alt=<span class="hljs-string">&quot;&quot;</span>&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;img&#x27;</span>);<br>        img.style.width = <span class="hljs-string">&quot;300px&quot;</span>;<br>        <span class="hljs-comment">// img.style = &#x27;width:300px&#x27;; 与上面等效</span><br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<p>在 JavaScript 中 class 是个保留字，因此使用元素对象的 className 属性来操作 HTML 元素的 class 属性值。修改元素的类名从而匹配 CSS 文件中预先写好不同类选择器样式表是更为常见的修改样式做法。注意 className 会直接更改元素的类名，会覆盖原先的类名，如果想要添加新的样式，应该在原来的类名字符串后面拼接新的样式类名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.className += <span class="hljs-string">&#x27;newclass&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>classList 属性是 HTML 5 新增的一个属性，返回元素对象的类名列表，IE 10 以上的版本才支持。通过该属性的方法可以方便地在元素中添加，移除及切换 CSS 类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.classList.add(<span class="hljs-string">&#x27;current&#x27;</span>);		<span class="hljs-comment">// 添加类</span><br>element.classList.remove(<span class="hljs-string">&#x27;current&#x27;</span>);	<span class="hljs-comment">// 移除类</span><br>focus.classList.toggle(<span class="hljs-string">&#x27;current&#x27;</span>);		<span class="hljs-comment">// 切换类</span><br></code></pre></td></tr></table></figure>

<h3 id="排他思想"><a href="#排他思想" class="headerlink" title="排他思想"></a>排他思想</h3><p>如果有同一组元素，我们想要其中某一个元素实现某种样式， 需要用到循环的排他思想算法：</p>
<ol>
<li>所有元素全部清除样式（干掉其他人）</li>
<li>给当前元素设置样式 （留下我自己）</li>
<li>注意顺序不能颠倒，首先干掉其他人，再设置自己</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;button&gt;按钮<span class="hljs-number">1</span>&lt;/button&gt;<br>    &lt;button&gt;按钮<span class="hljs-number">2</span>&lt;/button&gt;<br>    &lt;button&gt;按钮<span class="hljs-number">3</span>&lt;/button&gt;<br>    &lt;button&gt;按钮<span class="hljs-number">4</span>&lt;/button&gt;<br>    &lt;button&gt;按钮<span class="hljs-number">5</span>&lt;/button&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> btns = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;button&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;<br>            btns[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-comment">// 先把所有的按钮背景颜色去掉，即干掉所有人</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;<br>                    btns[i].style.backgroundColor = <span class="hljs-string">&#x27;&#x27;</span>;<br>                &#125;<br>                <span class="hljs-comment">// 然后让当前的元素背景颜色为 pink，即留下我自己</span><br>                <span class="hljs-built_in">this</span>.style.backgroundColor = <span class="hljs-string">&#x27;pink&#x27;</span>;<br><br>            &#125;<br>        &#125;<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>有时候为了给 HTML 元素做一些特殊标记或者保存一小段数据，我们会用给元素添加一些自定义的属性。元素的自定义属性只能通过 <code>getAttribute(attrName)</code> 和 <code>setAttribute(name, value)) </code>方法读写，必要时使用 <code>removeAttribute(attrName)</code> 移除属性值。</p>
<p><strong>注意：class 属性在通过这几个方法访问时不需要转换为 className，若要彻底移除一个属性的效果，应当使用 <code>removeAttribute()</code>，而不是使用 <code>setAttribute()</code> 将属性值设置为 <code>null</code>。对于许多属性，如果仅将其值设为 <code>null</code>，这不会造达成和预期一样的效果。。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div id=<span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> </span>= <span class="hljs-string">&#x27;test&#x27;</span>&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(div.id);<br>        <span class="hljs-built_in">console</span>.log(div.className);<br>        <span class="hljs-built_in">console</span>.log(div[<span class="hljs-string">&#x27;id&#x27;</span>]);<br>        <span class="hljs-built_in">console</span>.log(div[<span class="hljs-string">&#x27;className&#x27;</span>]);<br>        <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;id&#x27;</span>));<br>        <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;class&#x27;</span>));<br>        div.setAttribute(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;demo&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(div.id);<br>		div.removeAttribute(<span class="hljs-string">&#x27;id&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;id&#x27;</span>));<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<p>通过 JS 对象 <code>.</code> 和 <code>[]</code> 操作符只能设置 Element 对象预先定义的内置属性，并不能访问到 HTML 元素的自定义属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div index=<span class="hljs-string">&#x27;1&#x27;</span>&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);	<br>        div.index = <span class="hljs-number">2</span>; <span class="hljs-comment">// index 为自定义属性，实际是为 JS 中 div 对象本身新增了一个属性 index，并没有和 HTML 文档中的 div 元素的 index 属性关联起来，两个 index 属性是相互独立的。</span><br>        <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;index&#x27;</span>));	<span class="hljs-comment">// 1</span><br>        <span class="hljs-built_in">console</span>.log(div.index);					<span class="hljs-comment">// 2</span><br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<p>为了防止自定义属性和 Element 对象预先定义的内置属性混淆，H5 规定自定义属性应该以 data- 开头，遵循这个规定的自定义属性可以通过元素对象的 dataset 属性读写并自动映射到 HTML 元素的自定义属性上面（IE 11才开始支持）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    &lt;div  data-index=<span class="hljs-string">&#x27;1&#x27;</span>&gt;&lt;/div&gt;<br>    &lt;script&gt;<br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        div.dataset.index = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        <span class="hljs-built_in">console</span>.log(div.getAttribute(<span class="hljs-string">&#x27;data-index&#x27;</span>));<br>        <span class="hljs-built_in">console</span>.log(div.dataset.index);<br>    &lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>

<h3 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h3><p>网页中的所有内容都是节点，包括标签、属性、文本、注释等，在 DOM 中，节点使用 node 来表示。</p>
<p>![1550970944363](JavaScript Web API images/1550970944363.png)</p>
<p>任意一个节点至少拥有 nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p>
<ul>
<li>元素节点 nodeType 为 1。</li>
<li>属性节点 nodeType 为 2。</li>
<li>文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等）。</li>
</ul>
<p>除了利用 DOM 提供的获取元素对象的方法，还可以利用节点层级关系来获取元素对象，这种方式逻辑性强， 但是兼容性稍差。DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。</p>
<ul>
<li><p>父级节点：parentNode 属性可返回离该节点最近的父节点， 如果指定的节点没有父节点则返回 <code>null</code>。</p>
</li>
<li><p>子节点：childNodes 属性返回该节点的子节点的集合，该集合为即时更新的集合。返回值里面包含了所有的子节点，包括元素节点，文本节点等。如果只想要获得里面的元素节点，则需要通过节点的 nodeType 值做筛选处理。所以我们一般不提倡使用 childNodes 属性，而是使用 children 属性，children 是一个只读属性，返回该节点的子元素节点（伪数组）集合。它只返回子元素节点，其余节点不返回。</p>
</li>
<li><p>首尾子节点：firstChild 属性返回第一个子节点，lastChild 属性返回最后一个子节点，找不到则返回 null，包括元素节点，文本节点等所有类型节点。firstElementChild 返回第一个子元素节点，lastElementChild 返回最后一个子元素节点，找不到则返回null。但是这两个属性存在兼容性问题，IE9 以上才支持。使用节点的 children 属性加上数组下标访问首尾子元素节点，既可以避开非元素节点，也可以完美兼容 IE 低版本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ol&gt;<br>	&lt;li&gt;我是li1&lt;/li&gt;<br>	&lt;li&gt;我是li2&lt;/li&gt;<br>	&lt;li&gt;我是li3&lt;/li&gt;<br>	&lt;li&gt;我是li4&lt;/li&gt;<br>	&lt;li&gt;我是li5&lt;/li&gt;<br>&lt;/ol&gt;<br>&lt;script&gt;<br>    <span class="hljs-keyword">var</span> ol = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ol&#x27;</span>);<br>    <span class="hljs-comment">// 1. firstChild 第一个子节点 不管是文本节点还是元素节点</span><br>    <span class="hljs-built_in">console</span>.log(ol.firstChild);<br>    <span class="hljs-built_in">console</span>.log(ol.lastChild);<br>    <span class="hljs-comment">// 2. firstElementChild 返回第一个子元素节点 ie9才支持</span><br>    <span class="hljs-built_in">console</span>.log(ol.firstElementChild);<br>    <span class="hljs-built_in">console</span>.log(ol.lastElementChild);<br>    <span class="hljs-comment">// 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素</span><br>    <span class="hljs-built_in">console</span>.log(ol.children[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">console</span>.log(ol.children[ol.children.length - <span class="hljs-number">1</span>]);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>兄弟节点：nextSibling 属性返回当前元素的下一个兄弟元素节点，previousSibling 属性返回当前元素上一个兄弟元素节点找不到则返回null。和首尾子节点一样，也是包含所有的节点。nextElementSibling 属性返回当前元素下一个兄弟元素节点，previousElementSibling 属性返回当前元素上一个兄弟节点，找不到则返回null。同样这两个属性存在兼容性问题，IE9 以上才支持。可以通过判断 nodeType 自己封装一个的函数来解决兼容性问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNextElementSibling</span>(<span class="hljs-params">element</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> el = element;<br>    <span class="hljs-keyword">while</span> (el = el.nextSibling) &#123;<br>        <span class="hljs-keyword">if</span> (el.nodeType === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> el;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;  <br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><p><code>document.createElement(&#39;tagName&#39;)</code> 方法创建由 tagName 指定的 HTML 元素。</p>
<p><code>node.appendChild(child)</code> 方法将一个节点添加到指定父节点的子节点列表末尾。类似于 CSS 里面的 after 伪元素。</p>
<p><code>node.insertBefore(child, 指定元素)</code> 方法将一个节点添加到父节点的指定子节点前面。类似于 CSS 里面的 before 伪元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    &lt;li&gt;<span class="hljs-number">123</span>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;script&gt;<br>    <span class="hljs-comment">// 1. 创建节点元素节点</span><br>    <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);<br>	<span class="hljs-comment">// 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素</span><br>    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>);<br>    ul.appendChild(li);<br>    <span class="hljs-comment">// 3. 添加节点 node.insertBefore(child, 指定元素);</span><br>    <span class="hljs-keyword">var</span> lili = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);<br>    ul.insertBefore(lili, ul.children[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p><code>node.removeChild(child)</code> 方法从 DOM 中删除一个子节点，返回删除的节点。</p>
<p><code>node.cloneNode(deep)</code> 方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点。deep 参数是可选的，如果括号参数为空或者为 <code>false</code> ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点（包括文本节点）。如果括号参数为 <code>true</code> ，则是深度拷贝，会复制节点本身以及里面所有的子节点。注意：克隆一个元素节点会拷贝它所有的属性以及属性值,也包括属性上绑定的事件。如果原始节点设置了 ID，并且克隆节点会被插入到相同的文档中，为了防止一个文档中出现两个 ID 重复的元素，那么应该更新克隆节点的 ID 以保证唯一性。</p>
<p>三种动态创建元素区别：</p>
<ul>
<li><code>document.write()</code>：直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘。</li>
<li><code>element.innerHTML</code>：是将内容写入某个 DOM 节点，不会导致页面全部重绘， 创建多个元素节点的效率更高（采取数组形式拼接字符串而不是使用 <code>+</code> 来拼接字符串），但是使用数组拼接起来稍微复杂。</li>
<li><code>document.createElement()</code>：创建多个元素效率稍低一点点，但是结构更清晰。·</li>
</ul>
<h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><p>除了通过给元素对象的事件属性（<code>onclick</code>、<code>onmouseover</code> 等）赋值一个函数对象这种传统的方式来给元素注册事件，还可以使用事件监听方式给元素绑定事件。</p>
<p>传统方式同一个元素的同一个事件属性只能注册一个事件处理函数，最后注册的处理函数将会覆盖前面注册的处理函数。事件监听方式可以给同一个元素同一个事件注册多个监听器。</p>
<p><code>eventTarget.addEventListener(type, listener[, useCapture])</code> 方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。该方法接收三个参数：</p>
<ul>
<li>type：事件类型字符串，比如 ‘click’ 、’mouseover’，注意这里不要带 on。</li>
<li>listener：事件处理函数，事件发生时，会调用该监听函数。</li>
<li>useCapture：可选参数，是一个布尔值，默认是 <code>false</code>，指定该事件在捕获阶段还是冒泡阶段触发。。</li>
</ul>
<p>IE 9 之前的版本使用 <code>eventTarget.attachEvent(eventNameWithOn, callback)</code> 来添加事件监听器。该方法接收两个参数：</p>
<ul>
<li>eventNameWithOn：事件类型字符串，比如 ‘onclick’、’onmouseover ‘，这里要带 on。</li>
<li>callback： 事件处理函数，当目标触发事件时回调函数被调用</li>
</ul>
<p>可以封装如下的函数解决兼容性问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventListener</span>(<span class="hljs-params">element, eventName, fn</span>) </span>&#123;<br><span class="hljs-comment">// 判断当前浏览器是否支持 addEventListener 方法</span><br>    <span class="hljs-keyword">if</span> (element.addEventListener) &#123;<br>        element.addEventListener(eventName, fn); <span class="hljs-comment">// 第三个参数 默认是false</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.attachEvent) &#123;<br>    	element.attachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + eventName, fn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    	<span class="hljs-comment">// 相当于 element.onclick = fn;</span><br>    	element[<span class="hljs-string">&#x27;on&#x27;</span> + eventName] = fn;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="事件删除"><a href="#事件删除" class="headerlink" title="事件删除"></a>事件删除</h3><p>根据注册事件方法的不同，有下面三种的删除（解绑）事件的方式：</p>
<ul>
<li><code>eventTarget.onclick = null;</code></li>
<li><code>eventTarget.removeEventListener(type, listener[, useCapture]);</code></li>
<li><code>eventTarget.detachEvent(eventNameWithOn, callback);</code></li>
</ul>
<p>也可以封装以下的删除事件函数来解决兼容性问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEventListener</span>(<span class="hljs-params">element, eventName, fn</span>) </span>&#123;<br><span class="hljs-comment">// 判断当前浏览器是否支持 removeEventListener 方法</span><br>    <span class="hljs-keyword">if</span> (element.removeEventListener) &#123;<br>    	element.removeEventListener(eventName, fn); <span class="hljs-comment">// 第三个参数 默认是false</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.detachEvent) &#123;<br>   		element.detachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + eventName, fn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    	element[<span class="hljs-string">&#x27;on&#x27;</span> + eventName] = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。</p>
<p>![1551169007768](JavaScript Web API images/1551169007768.png)</p>
<p>事件可能处于三个阶段：</p>
<ol>
<li>捕获阶段（capturing phase）</li>
<li>目标阶段（target phase）</li>
<li>冒泡阶段（bubbling phase）</li>
</ol>
<p>对于事件目标元素注册的事件来说，事件会处于目标阶段。</p>
<p>事件目标元素的父元素对象如果注册了事件也会触发，但是只能在捕获或者冒泡其中的一个阶段被调用。通过 <code>onclick</code> 和 <code>attachEvent()</code> 注册的事件在冒泡阶段触发。<code>addEventListener(type, listener[, useCapture])</code>第三个参数如果是 <code>true</code>，表示在事件捕获阶段调用事件处理程序；如果是 <code>false</code>（不写默认就是 <code>false</code>），表示在事件冒泡阶段调用事件处理程序。 有些事件是没有冒泡的，比如 <code>onblur</code>、<code>onfocus</code>、<code>onmouseenter</code>、<code>onmouseleave</code>。</p>
<p>实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>事件对象代表事件的状态，事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。比如就鼠标事件而言，谁绑定了这个鼠标事件、鼠标的位置、鼠标按钮的状态这些信息都可以由事件对象得到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">eventTarget.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;&#125;<br>eventTarget.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;&#125;）<br></code></pre></td></tr></table></figure>

<p>给元素注册事件处理函数的时候可以为事件对象指定形参 event，或者写成 e 或者 evt。当事件发生时事件对象就会被浏览器自动创建，并传递给事件监听器（事件处理函数）。</p>
<p>在 IE 6 ~ 8 中，浏览器不会给监听器传递事件对象，如果需要的话，需要到<code>window.event</code> 中获取。可以使用以下的方法做兼容性处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">e = e || <span class="hljs-built_in">window</span>.event;<br></code></pre></td></tr></table></figure>

<p>事件对象的常见属性和方法：</p>
<p>![1551169931778](JavaScript Web API images/1551169931778.png)</p>
<p><code>e.target</code> 和 <code>this</code> 的区别：</p>
<ul>
<li><code>this</code> 是事件绑定的元素对象， 这个函数的调用者（绑定这个事件的元素），而这个函数可能是在冒泡阶段或者捕获阶段执行。</li>
<li><code>e.target</code> 是真正触发事件的具体元素对象。</li>
<li>当事件在目标阶段被调用执行时，<code>e.target</code> 和 <code>this</code> 指向同一个元素对象。</li>
</ul>
<p>利用事件对象的 <code>preventDefault()</code> 方法可以阻止对象的默认行为，例如 a 标签点击后默认会跳转到新地址，表单提交按钮点击后默认会提交整个表单。IE 6 ~ 8 设置事件对象 <code>returnValue</code> 为 <code>false</code> 也可以阻止默认行为，直接在事件处理函数中 <code>return false;</code> 也可以阻止默认行为，不存在兼容性问题。</p>
<p>利用事件对象的 <code>stopPropagation()</code> 方法可以阻止事件冒泡，IE 6 ~ 8 设置事件对象 <code>cancelBubble</code> 属性可以阻止冒泡。阻止事件冒泡的兼容性写法：</p>
<p>利用事件对象的 <code>stopPropagation()</code> 方法可以阻止事件冒泡，IE 6 ~ 8 设置事件对象 <code>cancelBubble</code> 属性可以阻止冒泡。阻止事件冒泡的兼容性写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(e &amp;&amp; e.stopPropagation)&#123;<br>	e.stopPropagation();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>	<span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托也称为事件代理， 在 jQuery 里面称为事件委派。</p>
<p>事件委托即当多个子元素需要注册相同或者接近的事件时，不直接给子元素注册事件，而是给它们的父元素注册事件，利用事件冒泡，当子元素的事件冒泡到父元素，执行父元素绑定的事件处理函数。</p>
<p>这样只操作了一次 DOM 就给所有子元素注册了事件，提高了程序的性能，并且以后新创建的子元素，也自动拥有了这个事件。</p>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>![1551172699854](JavaScript Web API images/1551172699854.png)</p>
<p>mouseenter 事件和 mouseover 很相似，当鼠标移动到元素上时就会触发它们。两者之间的差别：mouseover 事件会在冒泡阶段触发，鼠标经过元素自身会触发，经过子元素也会触发。 mouseenter 事件不冒泡，只会经过元素自身触发。mouseenter 行为方式与 CSS 中的 <code>:hover</code> 伪类非常相似。</p>
<p>mouseout 鼠标离开事件也有对应的 mouseleave 事件不会冒泡。</p>
<p>禁止鼠标右键菜单：<code>contextmenu</code> 主要控制应该何时显示上下文菜单，主要用于取消默认的上下文（鼠标右键）菜单。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;contextmenu&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>	e.preventDefault();<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>禁止鼠标选中：<code>selectstart</code> 控制开始选中文字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;selectstart&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>	e.preventDefault();<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>鼠标事件对象常用属性：</p>
<p>![image-20210322222524116](JavaScript Web API images/image-20210322222524116.png)</p>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>常用键盘事件：</p>
<p>![1551318122855](JavaScript Web API images/1551318122855.png)</p>
<ol>
<li>如果使用 <code>addEventListener()</code> 注册事件需要去掉 on。</li>
<li><code>onkeypress</code> 和其他两个键盘事件的区别是，它不识别功能键，比如左右箭头，<code>shift</code> 等。</li>
<li>三个事件的执行顺序是： keydown –&gt; keypress –&gt; keyup。</li>
</ol>
<p>键盘事件对象的 <code>keyCode</code> 属性返回该键的 ASCII 码的数值。</p>
<p><strong>注意：<code>onkeydown</code> 和 <code>onkeyup</code> 不区分字母大小写，<code>onkeypress</code> 区分字母大小写。</strong><br>在实际开发中，我们更多的使用 keydown 和 keyup， 它能识别所有的键（包括功能键），Keypress 不识别功能键，但是它的 keyCode 属性能区分大小写，返回不同的 ASCII 值。</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>BOM（Browser Object Model）即浏览器对象模型，它提供了与浏览器窗口进行交互的对象，BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性，其核心对象是 <code>window</code>。</p>
<p>![1551319344183](JavaScript Web API images/1551319344183.png)</p>
<p>DOM 就是把整个 HTML 文档当做一个对象来看待，DOM 的顶级对象 <code>document</code>。BOM 把整个浏览器标签页当做一个对象来看待，BOM 的顶级对象是 <code>window</code>。<code>document</code> 是 <code>window</code> 对象的一个属性。</p>
<p><code>window</code> 是一个全局对象（global object），定义在全局作用域中的变量、函数都会变成 <code>window</code> 对象的属性和方法。但是使用 <code>var</code> 声明的全局变量，<code>var</code> 声明的函数表达式，<code>function</code> 声明的函数，不能被 <code>delete</code> 删除。详见：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete">MDN：delete 操作符</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a1 = <span class="hljs-number">1</span>;<br>a2 = <span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;in f1()&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;in f2()&#x27;</span>);<br>&#125;<br>f3 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;in f3()&#x27;</span>);<br>&#125;<br>f4 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f4</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;in f4()&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> a1); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> a2); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> f1); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> f2); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> f3); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> f4); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h3 id="window-事件"><a href="#window-事件" class="headerlink" title="window 事件"></a>window 事件</h3><ul>
<li><p>窗口加载事件：当文档内容(包括图像、脚本文件、CSS文件等)完全加载完成会触发该事件, 调用处理函数。可以把 JS 代码放到回调函数里，这样 <code>script</code> 标签就可以放在文档的任意位置，等页面内容全部加载完毕，再去执行处理函数，避免了获取元素失败的情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;load&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);<br></code></pre></td></tr></table></figure>

<p>IE 9 以上支持 <code>DOMContentLoaded</code> 事件，仅当 DOM 加载完成就触发时间，不包括样式表，图片，flash 等等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;)<br></code></pre></td></tr></table></figure>

<p>如果页面的要加载的资源很多或者网络情况不好的话, 从用户访问到 <code>onload</code> 事件触发可能需要较长的时间，很多 JS 效果就不能生效，影响用户的体验，此时用 <code>DOMContentLoaded</code> 事件比较合适。</p>
</li>
<li><p>调整窗口大小事件：当浏览器窗口大小发生变化，就会触发这个事件。利用这个事件配合 <code>window.innerWidth</code>（当前屏幕的宽度）属性可以完成响应式布局。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>页面滚动事件：常结合 <code>window.pageYOffset</code> 和 <code>window.pageXOffset</code> 这两个属性使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onscroll = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;)<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="window-属性"><a href="#window-属性" class="headerlink" title="window 属性"></a>window 属性</h3><ul>
<li><p><code>location</code>：用于获取或设置窗体的 URL，并且可以用于解析 URL 。 因为<br>这个属性返回的是一个对象，所以我们将这个属性也称为 <code>location</code> 对象。URL (Uniform Resource Locator, URL) 的格式为：<code>protocol://host[:port]/path/[?query]#fragment</code><br>![1551322387201](JavaScript Web API images/1551322387201.png)<br> <code>location</code> 对象的属性：<br>![1551322416716](JavaScript Web API images/1551322416716.png)</p>
<p>利用 <code>location.search</code> 可以在页面跳转中传递少量参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 1.先去掉？  substr(&#x27;起始的位置&#x27;，截取几个字符);</span><br>    <span class="hljs-keyword">var</span> params = location.search.substr(<span class="hljs-number">1</span>); <span class="hljs-comment">// uname=andy</span><br>    <span class="hljs-built_in">console</span>.log(params);<br>    <span class="hljs-comment">// 2. 利用=把字符串分割为数组 split(&#x27;=&#x27;);</span><br>    <span class="hljs-keyword">var</span> arr = params.split(<span class="hljs-string">&#x27;=&#x27;</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p><code>location</code> 对象的方法：<br>![1551322750241](JavaScript Web API images/1551322750241.png)</p>
</li>
<li><p><code>navigator</code>：该对象包含有关浏览器的信息，我们最常用的是 <code>userAgent</code> 属性，该属性是一个只读的字符串，返回浏览器用于 HTTP 请求的用户代理头的值。利用该值可以对用户的终端信息进行判断，实现跳转不同的页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>((navigator.userAgent.match(<span class="hljs-regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;<br>    <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 跳转到手机页面</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">window</span>.location.href = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 跳转到电脑页面</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>history</code>：使用该对象与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的 URL。<br>![1551322885216](JavaScript Web API images/1551322885216.png)</p>
</li>
<li><p><code>sessionStorage</code>、<code>localStorage</code>：这两个对象可以将少量数据以键值对的形式存储在用户本地浏览器中，<code>sessionStorage</code> 的容量约 5 MB、<code>localStorage</code> 约 20 MB，不同浏览器的大小不统一。键和值都只能是字符串形式，如果要存储对象可以先使用 <code>JSON.stringify()</code> 编码后再存储。 <code>sessionStorage</code> 的生命周期为关闭浏览器窗口，在同一个窗口（页面）下的数据可以共享，<code>localStorage</code> 存储的数据永久生效，关闭了浏览器也会依旧存在，除非手动删除数据，同一浏览器的多个窗口（页面）之间可以共享 <code>localStorage</code> 存储的数据，前提是这些页面访问的域名相同（同源策略）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">sessionStorage.setItem(key, value);		<span class="hljs-comment">// 存储数据</span><br>sessionStorage.getItem(key);			<span class="hljs-comment">// 获取数据</span><br>sessionStorage.removeItem(key);			<span class="hljs-comment">// 删除数据</span><br>sessionStorage.clear();					<span class="hljs-comment">// 删除所有数据</span><br><span class="hljs-built_in">localStorage</span>.setItem(key, value);		<span class="hljs-comment">// 存储数据</span><br><span class="hljs-built_in">localStorage</span>.getItem(key);				<span class="hljs-comment">// 获取数据</span><br><span class="hljs-built_in">localStorage</span>.removeItem(key);			<span class="hljs-comment">// 删除数据</span><br><span class="hljs-built_in">localStorage</span>.clear();					<span class="hljs-comment">// 删除所有数据</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p><code>window</code> 对象提供了 2 个设定定时器方法：<code>setTimeout()</code> 和 <code>setInterval()</code>。</p>
<p><code>window.setTimeout(调用函数, [延迟的毫秒数])</code>方法用于设置一个定时器，该定时器在定时器到期后执行调用函数，<code>window</code> 可以省略。 这个调用函数也称为回调函数（callback），可以直接写匿名函数表达式，或者写函数名或者字符串形式的‘函数名()’三种形式，第三种不推荐。 延迟时间单位只能是毫秒，只需写数值不用写单位，默认值是 0。该方法返回值 <code>timeoutID</code> 是一个正整数，表示定时器的编号。这个值可以传递给 <code>window.clearTimeout(timeoutID)</code> 来取消该定时器。</p>
<p>回调函数原理：函数可以作为一个参数。将这个函数作为实参传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。</p>
<p><code>window.setInterval(回调函数, [间隔的毫秒数])</code>方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。其他两个参数的用法和 <code>setTimeout()</code> 一样，但是如果这个时间参数值小于 10，则默认使用值为 10 ms，真正延迟的时间或许更长。该方法返回值 <code>intervalID</code> 是一个正整数，表示计时器的编号。这个值可以传递给 <code>window.clearTimeout(intervalID)</code> 来取消该计时器。</p>
<p>对于同一个 <code>window</code> 对象，<code>setTimeout()</code> 或者 <code>setInterval()</code> 在后续的调用不会重用同一个定时器编号，不同的 <code>window</code> 对象使用独立的编号池。</p>
<p><strong>注意：<code>setTimeout()</code> 和 <code>setInterval()</code> 共用一个编号池，技术上，<code>clearTimeout()</code> 和 <code>clearInterval()</code> 可以互换。但是，为了避免混淆，不要混用取消定时函数。</strong></p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JavaScript 是单线程的非阻塞的脚本语言。这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。HTML 5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>
<p>单线程意味着，对于一个 JS 程序而言，都只有一个主线程来处理所有的任务。</p>
<p>非阻塞则是当 JS 需要进行一项无法立刻返回结果异步任务的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p>
<p>一般而言，异步任务有以下三种类型:<br>1、普通事件，如 click、resize 等。<br>2、资源请求加载，如 load、error 等。<br>3、定时器，包括 setInterval、setTimeout 等。</p>
<p>尽管 JS 是单线程执行的，但是（宿主环境）浏览器是多线程的，浏览器中的其他线程去协助 JS 引擎的运行实现了 JS 在浏览器运行环境的非阻塞。</p>
<p>浏览器中的线程举例：</p>
<ol>
<li>GUI 渲染线程</li>
<li>JS 引擎线程</li>
<li>定时触发器线程（setTimeout和setInteval）</li>
<li>浏览器事件触发线程（onclick）</li>
<li>异步 HTTP 请求线程（ajax）</li>
<li>事件轮询处理线程（event loop）</li>
</ol>
<p>JS 执行步骤</p>
<ol>
<li>执行主线程执行栈中的同步任务。</li>
<li>遇到异步任务交给异步线程（定时器触发线程 (setTimeout)、http 异步线程（ajax ）、浏览器事件线程（onclick））执行。</li>
<li>异步成功后，异步任务的回调函数放入任务队列（也叫消息队列）中。</li>
<li>当执行栈中的所有同步任务执行完毕，事件循环（event loop）线程，就会按入队次序读取（消息队列）中的回调函数进入执行栈，开始执行。</li>
</ol>
<p>JS 主线程从任务队列中读取任务，执行任务，这个过程是循环不断的，所以这种运行机制又称为事件循环（event loop）。</p>
<p>![img](JavaScript Web API images/f237b2fd943e41229de3d32388c7b68d~tplv-k3u1fbpfcp-zoom-1.image)</p>
<h2 id="网页特效相关"><a href="#网页特效相关" class="headerlink" title="网页特效相关"></a>网页特效相关</h2><h3 id="元素偏移量-offset-系列"><a href="#元素偏移量-offset-系列" class="headerlink" title="元素偏移量 offset 系列"></a>元素偏移量 offset 系列</h3><p>使用 offset 系列相关属性可以动态的得到该元素距离带有定位的父元素的偏移量、元素自身的大小（宽度高度）等。<strong>注意： 返回的都是数字型不带单位。</strong></p>
<p>![图片2](JavaScript Web API images/图片2.png)</p>
<p>offset 系列常用属性：</p>
<p>![图片1](JavaScript Web API images/图片1.png)</p>
<p>offset 系列属性 与 <code>style</code> 属性区别 ：</p>
<ul>
<li>offset 系列可以得到任意样式表中的样式值，<code>style</code> 只能得到行内样式表中的样式值。</li>
<li>offset 系列获得的数值是没有单位的，<code>style.width</code> 获得的是带有单位的字符串。</li>
<li>offsetWidth 包含padding+border+width，<code>style.width</code> 获得不包 padding 和 border 的值。</li>
</ul>
<ul>
<li>offset 系列等属性是只读属性，只能获取不能赋值，<code>style.width</code> 是可读写属性，可以获取也可以赋值。</li>
</ul>
<p>想要获取元素大小位置，用 offset 系列属性更合适，想要给更改元素样式，则需要用 <code>style</code> 属性。<strong>注意：通过 style 属性赋值时一定要记得补上单位字符串。</strong></p>
<h3 id="元素可视区-client-系列"><a href="#元素可视区-client-系列" class="headerlink" title="元素可视区 client 系列"></a>元素可视区 client 系列</h3><p>使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列的相关属性可以动态的得到该元素的边框大小、元素自身的大小（不包含边框）。</p>
<p>![图片4](JavaScript Web API images/图片4.png)</p>
<p>client 系列常用属性：</p>
<p>![图片3](JavaScript Web API images/图片3.png)</p>
<h3 id="元素滚动-scroll-系列"><a href="#元素滚动-scroll-系列" class="headerlink" title="元素滚动 scroll 系列"></a>元素滚动 scroll 系列</h3><p>使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</p>
<p>![图片6](JavaScript Web API images/图片6.png)</p>
<p>scroll 系列常用属性：</p>
<p>![图片5](JavaScript Web API images/图片5.png)</p>
<p>如果元素的高（或宽）度不足以显示整个元素内容时，会自动出现滚动条。当滚动条向下滚动时，内容上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 <code>onscroll</code> 事件。如果是整个页面滚动，事件源是 <code>document</code> 对象，如果是某个元素的内容滚动则事件源是该元素对象。</p>
<p><strong>注意：给元素添加 <code>overflow:auto</code> 样式才会在内容溢出时显示滚动条。</strong></p>
<p>页面被卷去的头部：可以通过 <code>window.pageYOffset</code> 获得 如果是被卷去的左侧 <code>window.pageXOffset</code>。元素被卷去的头部是 <code>element.scrollTop</code>，如果是被卷去的左侧是 <code>element.scrollLeft</code>。 </p>
<p><code>window.pageYOffset</code> 和 <code>window.pageXOffset</code> 这两个属性 IE 9 开始支持，如果文档开头声明了 DOCTYPE，IE 9 以下可以使用<code>document.documentElement.scrollTop</code>，没声明 DTD 可以使用 <code>document.body.scrollTop</code>。封装如下的兼容性函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScroll</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      left: <span class="hljs-built_in">window</span>.pageXOffset || <span class="hljs-built_in">document</span>.documentElement.scrollLeft || <span class="hljs-built_in">document</span>.body.scrollLeft||<span class="hljs-number">0</span>,<br>      top: <span class="hljs-built_in">window</span>.pageYOffset || <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-number">0</span><br>    &#125;;<br> &#125; <br><span class="hljs-comment">// 通过 getScroll().left 和 `getScroll().top 使用</span><br></code></pre></td></tr></table></figure>

<p>三个系列对比：</p>
<p>![图片7](JavaScript Web API images/图片7.png)</p>
<p>client 系列不仅不包括边框，如果有滚动条也不包括滚动条。scroll 系列则计算元素完整内容的大小，尽管这些内容可能发生了溢出。</p>
<ol>
<li>offset 系列主要使用 <code>offsetLeft</code>、<code>offsetTop</code> 获取元素位置 。</li>
<li>client 系列主要使用 <code>clientWidth</code> 、<code>clientHeight</code> 获取元素大小 。</li>
<li>scroll 系列主要使用 <code>scrollTop</code> 、<code>scrollLeft</code> 获取滚动距离。</li>
<li>整个页面滚动的距离通过 <code>window.pageXOffset</code> 获得。</li>
</ol>
<h3 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h3><p>动画实现原理：通过定时器 <code>setInterval()</code> 不断移动元素位置。</p>
<p>缓动动画：让元素运动速度有所变化，最常见的是让移动速度慢慢停下来，既让每步的步长慢慢变小，步长公式：（目标值 - 现在的位置） / 10，但是在接近终点时步长会无线趋近于 0 而始终无法准确到达终点，所以要对步长往数轴两端取整。如果步长是正值，利用 <code>Math.ceil()</code> 往上取整，如果是负值，则利用 <code>Math.floor()</code> 向下取整。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">obj, target, callback</span>) </span>&#123;<br>    <span class="hljs-comment">// 先清除以前的定时器，只保留当前的一个定时器执行,</span><br>    <span class="hljs-comment">// 让每一个元素至始至终只有一个定时器，防止多次调用会使动画加速</span><br>    <span class="hljs-built_in">clearInterval</span>(obj.timer);<br>    obj.timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 步长公式</span><br>        <span class="hljs-keyword">var</span> step = (target - obj.offsetLeft) / <span class="hljs-number">10</span>;<br>        step = step &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.ceil(step) : <span class="hljs-built_in">Math</span>.floor(step);<br>        <span class="hljs-comment">// 到达目标则停止动画 本质是停止定时器</span><br>        <span class="hljs-keyword">if</span> (obj.offsetLeft == target) &#123;<br>            <span class="hljs-built_in">clearInterval</span>(obj.timer);<br>            <span class="hljs-comment">// 回调函数写到定时器结束里面 </span><br>            callback &amp;&amp; callback(); <span class="hljs-comment">// 等价为 if (callback) &#123;callback();&#125;</span><br>        &#125;             <br>        obj.style.left = obj.offsetLeft + step + <span class="hljs-string">&#x27;px&#x27;</span>;<br>    &#125;, <span class="hljs-number">15</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用封装号的动画函数需要传递 3 个参数，动画对象（obj）、移动到的距离（target）和回调函数（callback）。</p>
<p><code>callback &amp;&amp; callback ()</code></p>
<h3 id="移动端触屏事件"><a href="#移动端触屏事件" class="headerlink" title="移动端触屏事件"></a>移动端触屏事件</h3><p>移动端没有鼠标点击的概念，取而代之的是手指触屏事件 touch（也称触摸事件），触屏事件可响应用户手指（或触控笔）对屏幕或者触控板的操作。</p>
<p>常见的触屏事件如下：</p>
<p>![image-20210515130450548](JavaScript Web API images/image-20210515130450548.png)</p>
<p>触摸事件对象（TouchEvent）保存触屏事件有关的状态信息，通过该对象的属性和方法可以检测触点的移动，触点的增加和减少等等。</p>
<p>touchstart、touchmove、touchend 三个事件都有各自的事件对象，但都有以下属性：</p>
<p>![image-20210515132352287](JavaScript Web API images/image-20210515132352287.png)</p>
<p>大多数情况使用 <code>targetTouches</code> 属性，该属性本质是一个伪数组，当只有一个手指触摸时使用 <code>e.targetTouches[0].pageX</code> 和 <code>e.targetTouches[0].pageY</code> 来获取触点在页面上的坐标。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p><a target="_blank" rel="noopener" href="http://www.quirksmode.org/js/events_order.html">JavaScript Event order</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jeffjade.com/2016/01/10/2016-01-10-javacript-setTimeout/">你所不知道的 setTimeout</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jeffjade.com/2016/01/10/2016-01-10-javaScript-setInterval/">你所不知道的 setInterval</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33058983">详解 JavaScript中 的 Event Loop（事件循环）机制</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903752621637645">JS 线程、Event Loop、事件循环、任务队列、宏任务</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/">自学笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JavaScript/">JavaScript</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a>
                    
                      <a class="hover-with-bg" href="/tags/API/">API</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/05/10/JavaScript%20%E8%BF%9B%E9%98%B6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JavaScript 进阶学习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/26/%E9%98%BF%E9%87%8C%E4%BA%91%20OSS%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/">
                        <span class="hidden-mobile">使用阿里云 OSS 服务搭建博客图床</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2"></div>
    
  </div>
</div>

<!-- Custom -->



    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     © 2020 - 2021 @ <a href="https://kiku.vip" target="_blank" rel="nofollow noopener"><span>Kiku</span></a><br> Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> | Theme -  <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>





  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?d3e02bccada8177079a692ffc4daabf8";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
